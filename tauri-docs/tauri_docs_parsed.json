{
  "metadata": {
    "version": "2.0",
    "parsed_at": "2025-09-01T04:17:11.630536",
    "total_files": 28
  },
  "quick_reference": {
    "common_commands": [
      {
        "name": "tauri_dev",
        "description": "This file is used by the Tauri runtime and the Tauri CLI. You can define build settings (such as the [command run before `tauri build`][before-build-command] or [`",
        "syntax": "tauri dev"
      },
      {
        "name": "tauri_build",
        "description": "This file is used by the Tauri runtime and the Tauri CLI. You can define build settings (such as the [command run before `",
        "syntax": "tauri build"
      },
      {
        "name": "tauri_init",
        "description": "npm=\"npx",
        "syntax": "tauri init"
      },
      {
        "name": "tauri_migrate",
        "description": "npm=\"npm install @tauri-apps/cli@latest",
        "syntax": "npm run tauri migrate"
      },
      {
        "name": "tauri_add_fs",
        "description": "If it is an existing plugin from our workspace you can use the automated way:",
        "syntax": "pnpm tauri add fs"
      },
      {
        "name": "tauri_icon",
        "description": "npm=\"",
        "syntax": "npm run tauri icon"
      }
    ],
    "essential_concepts": [
      {
        "name": "Create a Project",
        "category": "general",
        "summary": "import { Steps } from '@astrojs/starlight/components';"
      },
      {
        "name": "Create a Project",
        "category": "general",
        "summary": "import { Steps } from '@astrojs/starlight/components';"
      },
      {
        "name": "Calling the Frontend from Rust",
        "category": "general",
        "summary": "The `@tauri-apps/api` NPM package offers APIs to listen to both global and webview-specific events."
      },
      {
        "name": "Configuration Files",
        "category": "communication",
        "summary": "import CommandTabs from '@components/CommandTabs.astro';"
      }
    ],
    "frequent_patterns": [
      {
        "name": "plugin_usage",
        "frequency": 77,
        "example": null
      },
      {
        "name": "command_definition",
        "frequency": 60,
        "example": {
          "language": "rust",
          "code": "use tauri::{AppHandle, Emitter};\n\n#[tauri::command]\nfn download(app: AppHandle, url: String) {\n  app.emit(\"download-started\", &url).unwrap();\n  for progress in [1, 15, 50, 80, 100] {\n    app.emit(\"download-progress\", progress).unwrap();\n  }\n  app.emit(\"download-finished\", &url).unwrap();\n}",
          "context": "general",
          "file_path": "src-tauri/src/lib.rs",
          "description": "Events are either global (delivered to all listeners) or webview-specific (only delivered to the webview matching a given label)",
          "dependencies": null
        }
      },
      {
        "name": "window_manipulation",
        "frequency": 28,
        "example": null
      },
      {
        "name": "command_invocation",
        "frequency": 28,
        "example": {
          "language": "ts",
          "code": "import { invoke, Channel } from '@tauri-apps/api/core';\n\ntype DownloadEvent =\n  | {\n      event: 'started';\n      data: {\n        url: string;\n        downloadId: number;\n        contentLength: number;\n      };\n    }\n  | {\n      event: 'progress';\n      data: {\n        downloadId: number;\n        chunkLength: number;\n      };\n    }\n  | {\n      event: 'finished';\n      data: {\n        downloadId: number;\n      };\n    };\n\nconst onEvent = new Channel<DownloadEvent>();\nonEvent.onmessage = (message) => {\n  console.log(`got download event ${message.event}`);\n};\n\nawait invoke('download', {\n  url: 'https://raw.githubusercontent.com/tauri-apps/tauri/dev/crates/tauri-schema-generator/schemas/config.schema.json',\n  onEvent,\n});",
          "context": "command",
          "file_path": null,
          "description": "send(DownloadEvent::Finished { download_id })",
          "dependencies": null
        }
      },
      {
        "name": "state_initialization",
        "frequency": 14,
        "example": null
      },
      {
        "name": "v2_permissions",
        "frequency": 13,
        "example": null
      },
      {
        "name": "sidecar_execution",
        "frequency": 11,
        "example": null
      },
      {
        "name": "state_management",
        "frequency": 10,
        "example": null
      },
      {
        "name": "v2_window_api",
        "frequency": 8,
        "example": null
      }
    ],
    "platform_specific": {
      "windows": [
        "Capabilities for Different Windows and Platforms",
        "Configuration Files",
        "Core Permissions",
        "Create a Project",
        "Debug in VS Code",
        "Develop",
        "Environment Variables",
        "App Icons",
        "App Icons",
        "Upgrade from Tauri 1.0",
        "Prerequisites",
        "Embedding Additional Files",
        "Node.js as a sidecar",
        "Embedding External Binaries",
        "Splashscreen",
        "Using Plugin Permissions",
        "Vite",
        "Window Customization",
        "Window Menu"
      ],
      "macos": [
        "Capabilities for Different Windows and Platforms",
        "Configuration Files",
        "Create a Project",
        "Develop",
        "Environment Variables",
        "App Icons",
        "App Icons",
        "Upgrade from Tauri 1.0",
        "Upgrade from Tauri 2.0 Beta",
        "Prerequisites",
        "Node.js as a sidecar",
        "Vite",
        "Window Customization",
        "Window Menu"
      ],
      "linux": [
        "Capabilities for Different Windows and Platforms",
        "Configuration Files",
        "Create a Project",
        "Develop",
        "Environment Variables",
        "App Icons",
        "App Icons",
        "Upgrade from Tauri 1.0",
        "Prerequisites",
        "Node.js as a sidecar",
        "Embedding External Binaries",
        "Vite",
        "Window Menu"
      ],
      "android": [
        "Capabilities for Different Windows and Platforms",
        "Configuration Files",
        "Develop",
        "Environment Variables",
        "App Icons",
        "App Icons",
        "Upgrade from Tauri 1.0",
        "Upgrade from Tauri 2.0 Beta",
        "Prerequisites"
      ],
      "ios": [
        "Calling Rust from the Frontend",
        "Capabilities for Different Windows and Platforms",
        "Configuration Files",
        "Develop",
        "Environment Variables",
        "App Icons",
        "App Icons",
        "Upgrade from Tauri 1.0",
        "Upgrade from Tauri 2.0 Beta",
        "Prerequisites",
        "Vite"
      ],
      "cross_platform": [
        "Calling the Frontend from Rust",
        "Calling the Frontend from Rust",
        "Project Structure",
        "State Management",
        "System Tray",
        "Updating Dependencies",
        "Writing Plugin Permissions"
      ]
    },
    "difficulty_progression": {
      "beginner": [
        "Configuration Files",
        "Create a Project",
        "Debug in VS Code",
        "Calling the Frontend from Rust",
        "Updating Dependencies",
        "Vite"
      ],
      "intermediate": [
        "Calling the Frontend from Rust",
        "Calling Rust from the Frontend",
        "Capabilities for Different Windows and Platforms",
        "Core Permissions",
        "Develop",
        "Environment Variables",
        "App Icons",
        "App Icons",
        "Upgrade from Tauri 2.0 Beta",
        "Prerequisites",
        "Project Structure",
        "Embedding Additional Files",
        "Node.js as a sidecar",
        "Embedding External Binaries",
        "System Tray",
        "Window Customization",
        "Window Menu",
        "Writing Plugin Permissions"
      ],
      "advanced": [
        "Upgrade from Tauri 1.0",
        "Splashscreen",
        "State Management",
        "Using Plugin Permissions"
      ]
    }
  },
  "concepts": [
    {
      "name": "Calling the Frontend from Rust",
      "category": "communication",
      "description": "import { Content as FrontendListen } from './_sections/frontend-listen.mdx';",
      "key_points": [
        "Webview-specific events are **not** triggered to regular global event listeners"
      ],
      "code_examples": [
        {
          "language": "rust",
          "code": "use tauri::{AppHandle, Emitter};\n\n#[tauri::command]\nfn download(app: AppHandle, url: String) {\n  app.emit(\"download-started\", &url).unwrap();\n  for progress in [1, 15, 50, 80, 100] {\n    app.emit(\"download-progress\", progress).unwrap();\n  }\n  app.emit(\"download-finished\", &url).unwrap();\n}",
          "context": "general",
          "file_path": "src-tauri/src/lib.rs",
          "description": "Events are either global (delivered to all listeners) or webview-specific (only delivered to the webview matching a given label)",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "use tauri::{AppHandle, Emitter};\n\n#[tauri::command]\nfn login(app: AppHandle, user: String, password: String) {\n  let authenticated = user == \"tauri-apps\" && password == \"tauri\";\n  let result = if authenticated { \"loggedIn\" } else { \"invalidCredentials\" };\n  app.emit_to(\"login\", \"login-result\", result).unwrap();\n}",
          "context": "general",
          "file_path": "src-tauri/src/lib.rs",
          "description": "emit(\"download-finished\", &url)",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "use tauri::{AppHandle, Emitter, EventTarget};\n\n#[tauri::command]\nfn open_file(app: AppHandle, path: std::path::PathBuf) {\n  app.emit_filter(\"open-file\", path, |target| match target {\n    EventTarget::WebviewWindow { label } => label == \"main\" || label == \"file-viewer\",\n    _ => false,\n  }).unwrap();\n}",
          "context": "general",
          "file_path": "src-tauri/src/lib.rs",
          "description": "unwrap();\n}\n```\n\nIt is also possible to trigger an event to a list of webviews by calling [Emitter#emit_filter]",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "use tauri::{AppHandle, Emitter};\nuse serde::Serialize;\n\n#[derive(Clone, Serialize)]\n#[serde(rename_all = \"camelCase\")]\nstruct DownloadStarted<'a> {\n  url: &'a str,\n  download_id: usize,\n  content_length: usize,\n}\n\n#[derive(Clone, Serialize)]\n#[serde(rename_all = \"camelCase\")]\nstruct DownloadProgress {\n  download_id: usize,\n  chunk_length: usize,\n}\n\n#[derive(Clone, Serialize)]\n#[serde(rename_all = \"camelCase\")]\nstruct DownloadFinished {\n  download_id: usize,\n}\n\n#[tauri::command]\nfn download(app: AppHandle, url: String) {\n  let content_length = 1000;\n  let download_id = 1;\n\n  app.emit(\"download-started\", DownloadStarted {\n    url: &url,\n    download_id,\n    content_length\n  }).unwrap();\n\n  for chunk_length in [15, 150, 35, 500, 300] {\n    app.emit(\"download-progress\", DownloadProgress {\n      download_id,\n      chunk_length,\n    }).unwrap();\n  }\n\n  app.emit(\"download-finished\", DownloadFinished { download_id }).unwrap();\n}",
          "context": "general",
          "file_path": "src-tauri/src/lib.rs",
          "description": ":::\n\n### Event Payload\n\nThe event payload can be any [serializable][Serialize] type that also implements [Clone]",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "use tauri::{AppHandle, ipc::Channel};\nuse serde::Serialize;\n\n#[derive(Clone, Serialize)]\n#[serde(rename_all = \"camelCase\", rename_all_fields = \"camelCase\", tag = \"event\", content = \"data\")]\nenum DownloadEvent<'a> {\n  Started {\n    url: &'a str,\n    download_id: usize,\n    content_length: usize,\n  },\n  Progress {\n    download_id: usize,\n    chunk_length: usize,\n  },\n  Finished {\n    download_id: usize,\n  },\n}\n\n#[tauri::command]\nfn download(app: AppHandle, url: String, on_event: Channel<DownloadEvent>) {\n  let content_length = 1000;\n  let download_id = 1;\n\n  on_event.send(DownloadEvent::Started {\n    url: &url,\n    download_id,\n    content_length,\n  }).unwrap();\n\n  for chunk_length in [15, 150, 35, 500, 300] {\n    on_event.send(DownloadEvent::Progress {\n      download_id,\n      chunk_length,\n    }).unwrap();\n  }\n\n  on_event.send(DownloadEvent::Finished { download_id }).unwrap();\n}",
          "context": "command",
          "file_path": "src-tauri/src/lib.rs",
          "description": "They are used internally for streaming operations\nsuch as download progress, child process output and WebSocket messages",
          "dependencies": null
        },
        {
          "language": "ts",
          "code": "import { invoke, Channel } from '@tauri-apps/api/core';\n\ntype DownloadEvent =\n  | {\n      event: 'started';\n      data: {\n        url: string;\n        downloadId: number;\n        contentLength: number;\n      };\n    }\n  | {\n      event: 'progress';\n      data: {\n        downloadId: number;\n        chunkLength: number;\n      };\n    }\n  | {\n      event: 'finished';\n      data: {\n        downloadId: number;\n      };\n    };\n\nconst onEvent = new Channel<DownloadEvent>();\nonEvent.onmessage = (message) => {\n  console.log(`got download event ${message.event}`);\n};\n\nawait invoke('download', {\n  url: 'https://raw.githubusercontent.com/tauri-apps/tauri/dev/crates/tauri-schema-generator/schemas/config.schema.json',\n  onEvent,\n});",
          "context": "command",
          "file_path": null,
          "description": "send(DownloadEvent::Finished { download_id })",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "use tauri::Manager;\n\ntauri::Builder::default()\n  .setup(|app| {\n    let webview = app.get_webview_window(\"main\").unwrap();\n    webview.eval(\"console.log('hello from Rust')\")?;\n    Ok(())\n  })",
          "context": "window_management",
          "file_path": "src-tauri/src/lib.rs",
          "description": "schema",
          "dependencies": null
        }
      ],
      "related_concepts": [
        "channels section"
      ],
      "difficulty": "intermediate",
      "tags": [
        "rust",
        "javascript",
        "calling",
        "frontend"
      ]
    },
    {
      "name": "Calling Rust from the Frontend",
      "category": "communication",
      "description": "import { Content as FrontendListen } from './_sections/frontend-listen.mdx';",
      "key_points": [
        "Command names must be unique",
        "Commands defined in the `lib",
        "When defining commands in a separate module they should be marked as `pub`",
        "The command name is not scoped to the module so they must be unique even between modules",
        "the `commands::` prefix in the command list, which denotes the full path to the command function",
        "Async commands are executed on a separate async task using [`async_runtime::spawn`]",
        "that the return value must be wrapped in `Ok()` now",
        "Webview-specific events are **not** triggered to regular global event listeners"
      ],
      "code_examples": [
        {
          "language": "rust",
          "code": "#[tauri::command]\nfn my_custom_command() {\n\tprintln!(\"I was invoked from JavaScript!\");\n}",
          "context": "command",
          "file_path": "src-tauri/src/lib.rs",
          "description": "rs` file",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "#[cfg_attr(mobile, tauri::mobile_entry_point)]\npub fn run() {\n\ttauri::Builder::default()\n\t\t.invoke_handler(tauri::generate_handler![my_custom_command])\n\t\t.run(tauri::generate_context!())\n\t\t.expect(\"error while running tauri application\");\n}",
          "context": "command",
          "file_path": "src-tauri/src/lib.rs",
          "description": "it as a public function:\n\n```\nerror[E0255]: the name `__cmd__command_name` is defined multiple times\n  --> src/lib",
          "dependencies": null
        },
        {
          "language": "javascript",
          "code": "// When using the Tauri API npm package:\nimport { invoke } from '@tauri-apps/api/core';\n\n// When using the Tauri global script (if not using the npm package)\n// Be sure to set `app.withGlobalTauri` in `tauri.conf.json` to true\nconst invoke = window.__TAURI__.core.invoke;\n\n// Invoke the command\ninvoke('my_custom_command');",
          "context": "command",
          "file_path": null,
          "description": "run(tauri::generate_context!())",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "#[tauri::command]\npub fn my_custom_command() {\n\tprintln!(\"I was invoked from JavaScript!\");\n}",
          "context": "command",
          "file_path": "src-tauri/src/commands.rs",
          "description": "As an example let's define a command in the `src-tauri/src/commands",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "mod commands;\n\n#[cfg_attr(mobile, tauri::mobile_entry_point)]\npub fn run() {\n\ttauri::Builder::default()\n\t\t.invoke_handler(tauri::generate_handler![commands::my_custom_command])\n\t\t.run(tauri::generate_context!())\n\t\t.expect(\"error while running tauri application\");\n}",
          "context": "command",
          "file_path": "src-tauri/src/lib.rs",
          "description": ":::\n\nIn the `lib",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "#[wasm_bindgen]\nextern \"C\" {\n    // invoke without arguments\n    #[wasm_bindgen(js_namespace = [\"window\", \"__TAURI__\", \"core\"], js_name = invoke)]\n    async fn invoke_without_args(cmd: &str) -> JsValue;\n\n    // invoke with arguments (default)\n    #[wasm_bindgen(js_namespace = [\"window\", \"__TAURI__\", \"core\"])]\n    async fn invoke(cmd: &str, args: JsValue) -> JsValue;\n\n    // They need to have different names!\n}",
          "context": "frontend_integration",
          "file_path": null,
          "description": "The reason is that Rust doesn't support optional arguments",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "#[tauri::command]\nfn my_custom_command(invoke_message: String) {\n\tprintln!(\"I was invoked from JavaScript, with this message: {}\", invoke_message);\n}",
          "context": "command",
          "file_path": null,
          "description": "rust ins={4-5}\n#[wasm_bindgen]\nextern \"C\" {\n    // invoke without arguments\n    #[wasm_bindgen(js_namespace = [\"window\", \"__TAURI__\", \"core\"], js_name = invoke)]\n    async fn invoke_without_args(cmd: &str) -> JsValue;\n\n    // invoke with arguments (default)\n    #[wasm_bindgen(js_namespace = [\"window\", \"__TAURI__\", \"core\"])]\n    async fn invoke(cmd: &str, args: JsValue) -> JsValue;\n\n    // They need to have different names!\n}\n```\n\n### Passing Arguments\n\nYour command handlers can take arguments:",
          "dependencies": null
        },
        {
          "language": "javascript",
          "code": "invoke('my_custom_command', { invokeMessage: 'Hello!' });",
          "context": "command",
          "file_path": null,
          "description": "oke with arguments (default)\n    #[wasm_bindgen(js_namespace = [\"window\", \"__TAURI__\", \"core\"])]\n    async fn invoke(cmd: &str, args: JsValue) -> JsValue;\n\n    // They need to have different names!\n}\n```\n\n### Passing Arguments\n\nYour command handlers can take arguments:\n\n```rust\n#[tauri::command]\nfn my_custom_command(invoke_message: String) {\n\tprintln!(\"I was invoked from JavaScript, with this message: {}\", invoke_message);\n}\n```\n\nArguments should be passed as a JSON object with camelCase keys:",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "#[tauri::command(rename_all = \"snake_case\")]\nfn my_custom_command(invoke_message: String) {}",
          "context": "command",
          "file_path": null,
          "description": "They need to have different names!\n}\n```\n\n### Passing Arguments\n\nYour command handlers can take arguments:\n\n```rust\n#[tauri::command]\nfn my_custom_command(invoke_message: String) {\n\tprintln!(\"I was invoked from JavaScript, with this message: {}\", invoke_message);\n}\n```\n\nArguments should be passed as a JSON object with camelCase keys:\n\n```javascript\ninvoke('my_custom_command', { invokeMessage: 'Hello!' });\n```\n\n:::note\nYou can use `snake_case` for the arguments with the `rename_all` attribute:",
          "dependencies": null
        },
        {
          "language": "javascript",
          "code": "invoke('my_custom_command', { invoke_message: 'Hello!' });",
          "context": "command",
          "file_path": null,
          "description": ":\n\n```rust\n#[tauri::command]\nfn my_custom_command(invoke_message: String) {\n\tprintln!(\"I was invoked from JavaScript, with this message: {}\", invoke_message);\n}\n```\n\nArguments should be passed as a JSON object with camelCase keys:\n\n```javascript\ninvoke('my_custom_command', { invokeMessage: 'Hello!' });\n```\n\n:::note\nYou can use `snake_case` for the arguments with the `rename_all` attribute:\n\n```rust\n#[tauri::command(rename_all = \"snake_case\")]\nfn my_custom_command(invoke_message: String) {}\n```",
          "dependencies": null
        },
        {
          "language": "javascript",
          "code": "invoke('my_custom_command', { invoke_message: 'Hello!' });",
          "context": "command",
          "file_path": null,
          "description": "a JSON object with camelCase keys:\n\n```javascript\ninvoke('my_custom_command', { invokeMessage: 'Hello!' });\n```\n\n:::note\nYou can use `snake_case` for the arguments with the `rename_all` attribute:\n\n```rust\n#[tauri::command(rename_all = \"snake_case\")]\nfn my_custom_command(invoke_message: String) {}\n```\n\n```javascript\ninvoke('my_custom_command', { invoke_message: 'Hello!' });\n```\n\n:::\n\nArguments can be of any type, as long as they implement [`serde::Deserialize`]",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "#[tauri::command]\nfn my_custom_command() -> String {\n\t\"Hello from Rust!\".into()\n}",
          "context": "command",
          "file_path": null,
          "description": "case` for the arguments with the `rename_all` attribute:\n\n```rust\n#[tauri::command(rename_all = \"snake_case\")]\nfn my_custom_command(invoke_message: String) {}\n```\n\n```javascript\ninvoke('my_custom_command', { invoke_message: 'Hello!' });\n```\n\n:::\n\nArguments can be of any type, as long as they implement [`serde::Deserialize`]",
          "dependencies": null
        },
        {
          "language": "javascript",
          "code": "invoke('my_custom_command').then((message) => console.log(message));",
          "context": "command",
          "file_path": null,
          "description": "The corresponding JavaScript:\n\n```javascript\ninvoke('my_custom_command', { invoke_message: 'Hello!' });\n```\n\n### Returning Data\n\nCommand handlers can return data as well:\n\n```rust\n#[tauri::command]\nfn my_custom_command() -> String {\n\t\"Hello from Rust!\"",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "use tauri::ipc::Response;\n#[tauri::command]\nfn read_file() -> Response {\n\tlet data = std::fs::read(\"/path/to/file\").unwrap();\n\ttauri::ipc::Response::new(data)\n}",
          "context": "frontend_integration",
          "file_path": null,
          "description": "This can slow down your application if you try to return a large data such as a file or a download HTTP response",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "#[tauri::command]\nfn login(user: String, password: String) -> Result<String, String> {\n\tif user == \"tauri\" && password == \"tauri\" {\n\t\t// resolve\n\t\tOk(\"logged_in\".to_string())\n\t} else {\n\t\t// reject\n\t\tErr(\"invalid credentials\".to_string())\n\t}\n}",
          "context": "general",
          "file_path": null,
          "description": "To return array buffers in an optimized way, use [`tauri::ipc::Response`]:\n\n```rust\nuse tauri::ipc::Response;\n#[tauri::command]\nfn read_file() -> Response {\n\tlet data = std::fs::read(\"/path/to/file\")",
          "dependencies": null
        },
        {
          "language": "javascript",
          "code": "invoke('login', { user: 'tauri', password: '0j4rijw8=' })\n  .then((message) => console.log(message))\n  .catch((error) => console.error(error));",
          "context": "command",
          "file_path": null,
          "description": "to_string())\n\t} else {\n\t\t// reject\n\t\tErr(\"invalid credentials\"",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "#[tauri::command]\nfn my_custom_command() -> Result<(), String> {\n\tstd::fs::File::open(\"path/to/file\").map_err(|err| err.to_string())?;\n\t// Return `null` on success\n\tOk(())\n}",
          "context": "rust_backend",
          "file_path": null,
          "description": "This can be problematic if you're working with error types from Rust's std library or external crates as most error types do not implement it",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "// create the error type that represents all errors possible in our program\n#[derive(Debug, thiserror::Error)]\nenum Error {\n\t#[error(transparent)]\n\tIo(#[from] std::io::Error)\n}\n\n// we must manually implement serde::Serialize\nimpl serde::Serialize for Error {\n\tfn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n\twhere\n\t\tS: serde::ser::Serializer,\n\t{\n\t\tserializer.serialize_str(self.to_string().as_ref())\n\t}\n}\n\n#[tauri::command]\nfn my_custom_command() -> Result<(), Error> {\n\t// This will return an error\n\tstd::fs::File::open(\"path/that/does/not/exist\")?;\n\t// Return `null` on success\n\tOk(())\n}",
          "context": "general",
          "file_path": null,
          "description": "You can consult its documentation for more details",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "#[derive(Debug, thiserror::Error)]\nenum Error {\n  #[error(transparent)]\n  Io(#[from] std::io::Error),\n  #[error(\"failed to parse as string: {0}\")]\n  Utf8(#[from] std::str::Utf8Error),\n}\n\n#[derive(serde::Serialize)]\n#[serde(tag = \"kind\", content = \"message\")]\n#[serde(rename_all = \"camelCase\")]\nenum ErrorKind {\n  Io(String),\n  Utf8(String),\n}\n\nimpl serde::Serialize for Error {\n  fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n  where\n    S: serde::ser::Serializer,\n  {\n    let error_message = self.to_string();\n    let error_kind = match self {\n      Self::Io(_) => ErrorKind::Io(error_message),\n      Self::Utf8(_) => ErrorKind::Utf8(error_message),\n    };\n    error_kind.serialize(serializer)\n  }\n}\n\n#[tauri::command]\nfn read() -> Result<Vec<u8>, Error> {\n  let data = std::fs::read(\"/path/to/file\")?;\n\tOk(data)\n}",
          "context": "general",
          "file_path": null,
          "description": "<br/>\nIt also gives you full control over the way your error type gets serialized",
          "dependencies": null
        },
        {
          "language": "ts",
          "code": "type ErrorKind = {\n  kind: 'io' | 'utf8';\n  message: string;\n};\n\ninvoke('read').catch((e: ErrorKind) => {});",
          "context": "command",
          "file_path": null,
          "description": "to_string();\n    let error_kind = match self {\n      Self::Io(_) => ErrorKind::Io(error_message),\n      Self::Utf8(_) => ErrorKind::Utf8(error_message),\n    };\n    error_kind",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "// Declare the async function using String instead of &str, as &str is borrowed and thus unsupported\n#[tauri::command]\nasync fn my_custom_command(value: String) -> String {\n\t// Call another async function and wait for it to finish\n\tsome_async_function().await;\n\tvalue\n}",
          "context": "state_management",
          "file_path": null,
          "description": "This may not work for all types, for example `State<'_, Data>`",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "// Return a Result<String, ()> to bypass the borrowing issue\n#[tauri::command]\nasync fn my_custom_command(value: &str) -> Result<String, ()> {\n\t// Call another async function and wait for it to finish\n\tsome_async_function().await;\n\t// Note that the return value must be wrapped in `Ok()` now.\n\tOk(format!(value))\n}",
          "context": "general",
          "file_path": null,
          "description": "- `Result<bool, Error>` to return a boolean or an error as shown in the [Error Handling](#error-handling) section above",
          "dependencies": null
        },
        {
          "language": "javascript",
          "code": "invoke('my_custom_command', { value: 'Hello, Async!' }).then(() =>\n  console.log('Completed!')\n);",
          "context": "command",
          "file_path": null,
          "description": "await;\n\t// Note that the return value must be wrapped in `Ok()` now",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "use tokio::io::AsyncReadExt;\n\n#[tauri::command]\nasync fn load_image(path: std::path::PathBuf, reader: tauri::ipc::Channel<&[u8]>) {\n  // for simplicity this example does not include error handling\n  let mut file = tokio::fs::File::open(path).await.unwrap();\n\n  let mut chunk = vec![0; 4096];\n\n  loop {\n    let len = file.read(&mut chunk).await.unwrap();\n    if len == 0 {\n      // Length of zero means end of file.\n      break;\n    }\n    reader.send(&chunk).unwrap();\n  }\n}",
          "context": "frontend_integration",
          "file_path": null,
          "description": "log('Completed!')\n);\n```\n\n### Channels\n\nThe Tauri channel is the recommended mechanism for streaming data such as streamed HTTP responses to the frontend",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "#[tauri::command]\nasync fn my_custom_command(webview_window: tauri::WebviewWindow) {\n\tprintln!(\"WebviewWindow: {}\", webview_window.label());\n}",
          "context": "command",
          "file_path": "src-tauri/src/lib.rs",
          "description": "unwrap();\n  }\n}\n```\n\nSee the [channels documentation] for more information",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "#[tauri::command]\nasync fn my_custom_command(app_handle: tauri::AppHandle) {\n\tlet app_dir = app_handle.path().app_dir();\n\tuse tauri::GlobalShortcutManager;\n\tapp_handle.global_shortcut_manager().register(\"CTRL + U\", move || {});\n}",
          "context": "command",
          "file_path": "src-tauri/src/lib.rs",
          "description": "rs\"\n#[tauri::command]\nasync fn my_custom_command(webview_window: tauri::WebviewWindow) {\n\tprintln!(\"WebviewWindow: {}\", webview_window",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "struct MyState(String);\n\n#[tauri::command]\nfn my_custom_command(state: tauri::State<MyState>) {\n\tassert_eq!(state.0 == \"some state value\", true);\n}\n\n#[cfg_attr(mobile, tauri::mobile_entry_point)]\npub fn run() {\n\ttauri::Builder::default()\n\t\t.manage(MyState(\"some state value\".into()))\n\t\t.invoke_handler(tauri::generate_handler![my_custom_command])\n\t\t.run(tauri::generate_context!())\n\t\t.expect(\"error while running tauri application\");\n}",
          "context": "command",
          "file_path": "src-tauri/src/lib.rs",
          "description": "label());\n}\n```\n\n:::\n\n### Accessing Managed State\n\nTauri can manage state using the `manage` function on `tauri::Builder`",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "#[derive(Debug, thiserror::Error)]\nenum Error {\n  #[error(\"unexpected request body\")]\n  RequestBodyMustBeRaw,\n  #[error(\"missing `{0}` header\")]\n  MissingHeader(&'static str),\n}\n\nimpl serde::Serialize for Error {\n  fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n  where\n    S: serde::ser::Serializer,\n  {\n    serializer.serialize_str(self.to_string().as_ref())\n  }\n}\n\n#[tauri::command]\nfn upload(request: tauri::ipc::Request) -> Result<(), Error> {\n  let tauri::ipc::InvokeBody::Raw(upload_data) = request.body() else {\n    return Err(Error::RequestBodyMustBeRaw);\n  };\n  let Some(authorization_header) = request.headers().get(\"Authorization\") else {\n    return Err(Error::MissingHeader(\"Authorization\"));\n  };\n\n  // upload...\n\n  Ok(())\n}",
          "context": "command",
          "file_path": null,
          "description": "expect(\"error while running tauri application\");\n}\n```\n\n### Accessing Raw Request\n\nTauri commands can also access the full [`tauri::ipc::Request`] object which includes the raw body payload and the request headers",
          "dependencies": null
        },
        {
          "language": "js",
          "code": "const data = new Uint8Array([1, 2, 3]);\nawait __TAURI__.core.invoke('upload', data, {\n  headers: {\n    Authorization: 'apikey',\n  },\n});",
          "context": "frontend_integration",
          "file_path": null,
          "description": "",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "#[tauri::command]\nfn cmd_a() -> String {\n\t\"Command a\"\n}\n#[tauri::command]\nfn cmd_b() -> String {\n\t\"Command b\"\n}\n\n#[cfg_attr(mobile, tauri::mobile_entry_point)]\npub fn run() {\n\ttauri::Builder::default()\n\t\t.invoke_handler(tauri::generate_handler![cmd_a, cmd_b])\n\t\t.run(tauri::generate_context!())\n\t\t.expect(\"error while running tauri application\");\n}",
          "context": "command",
          "file_path": "src-tauri/src/lib.rs",
          "description": "You must pass each command to a single call of\n`tauri::generate_handler!`",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "struct Database;\n\n#[derive(serde::Serialize)]\nstruct CustomResponse {\n\tmessage: String,\n\tother_val: usize,\n}\n\nasync fn some_other_function() -> Option<String> {\n\tSome(\"response\".into())\n}\n\n#[tauri::command]\nasync fn my_custom_command(\n\twindow: tauri::Window,\n\tnumber: usize,\n\tdatabase: tauri::State<'_, Database>,\n) -> Result<CustomResponse, String> {\n\tprintln!(\"Called from {}\", window.label());\n\tlet result: Option<String> = some_other_function().await;\n\tif let Some(message) = result {\n\t\tOk(CustomResponse {\n\t\t\tmessage,\n\t\t\tother_val: 42 + number,\n\t\t})\n\t} else {\n\t\tErr(\"No result\".into())\n\t}\n}\n\n#[cfg_attr(mobile, tauri::mobile_entry_point)]\npub fn run() {\n\ttauri::Builder::default()\n\t\t.manage(Database {})\n\t\t.invoke_handler(tauri::generate_handler![my_custom_command])\n\t\t.run(tauri::generate_context!())\n\t\t.expect(\"error while running tauri application\");\n}",
          "context": "general",
          "file_path": "src-tauri/src/lib.rs",
          "description": "run(tauri::generate_context!())",
          "dependencies": null
        },
        {
          "language": "javascript",
          "code": "import { invoke } from '@tauri-apps/api/core';\n\n// Invocation from JavaScript\ninvoke('my_custom_command', {\n  number: 42,\n})\n  .then((res) =>\n    console.log(`Message: ${res.message}, Other Val: ${res.other_val}`)\n  )\n  .catch((e) => console.error(e));",
          "context": "command",
          "file_path": null,
          "description": "run(tauri::generate_context!())",
          "dependencies": null
        },
        {
          "language": "js",
          "code": "import { emit } from '@tauri-apps/api/event';\nimport { getCurrentWebviewWindow } from '@tauri-apps/api/webviewWindow';\n\n// emit(eventName, payload)\nemit('file-selected', '/path/to/file');\n\nconst appWebview = getCurrentWebviewWindow();\nappWebview.emit('route-changed', { url: window.location.href });",
          "context": "window_management",
          "file_path": null,
          "description": "### Global Events\n\nTo trigger a global event you can use the [event",
          "dependencies": null
        },
        {
          "language": "js",
          "code": "import { emitTo } from '@tauri-apps/api/event';\nimport { getCurrentWebviewWindow } from '@tauri-apps/api/webviewWindow';\n\n// emitTo(webviewLabel, eventName, payload)\nemitTo('settings', 'settings-update-requested', {\n  key: 'notification',\n  value: 'all',\n});\n\nconst appWebview = getCurrentWebviewWindow();\nappWebview.emitTo('editor', 'file-changed', {\n  path: '/path/to/file',\n  contents: 'file contents',\n});",
          "context": "window_management",
          "file_path": null,
          "description": "href });\n```\n\n:::note\nGlobal events are delivered to **all** listeners\n:::\n\n### Webview Event\n\nTo trigger an event to a listener registered by a specific webview you can use the [event",
          "dependencies": null
        },
        {
          "language": "js",
          "code": "import { listen } from '@tauri-apps/api/event';\nlisten(\n  'state-changed',\n  (event) => {\n    console.log('got state changed event', event);\n  },\n  {\n    target: { kind: 'Any' },\n  }\n);",
          "context": "general",
          "file_path": null,
          "description": "To listen to **any** event you must provide the `{ target: { kind: 'Any' } }` option to the [event",
          "dependencies": null
        }
      ],
      "related_concepts": [
        "command",
        "event system",
        "Error Handling"
      ],
      "difficulty": "intermediate",
      "tags": [
        "calling",
        "rust",
        "typescript",
        "mobile",
        "javascript",
        "ios"
      ]
    },
    {
      "name": "Capabilities for Different Windows and Platforms",
      "category": "ui_customization",
      "description": "import { Steps } from '@astrojs/starlight/components'; import ShowSolution from '@components/ShowSolution.astro' import Cta from '@fragments/cta.mdx';",
      "key_points": [
        "Create multiple windows in a Tauri app",
        "Use different capabilities for different windows",
        "Use platform-specific capabilities"
      ],
      "code_examples": [
        {
          "language": "javascript",
          "code": "\"productName\": \"multiwindow\",\n      ...\n      \"app\": {\n        \"windows\": [\n          {\n            \"label\": \"first\",\n            \"title\": \"First\",\n            \"width\": 800,\n            \"height\": 600\n          },\n          {\n            \"label\": \"second\",\n            \"title\": \"Second\",\n            \"width\": 800,\n            \"height\": 600\n          }\n        ],\n      },\n      ...\n    }",
          "context": "window_management",
          "file_path": null,
          "description": "conf",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "tauri::Builder::default()\n        .invoke_handler(tauri::generate_handler![greet])\n        .setup(|app| {\n            let webview_url = tauri::WebviewUrl::App(\"index.html\".into());\n            // First window\n            tauri::WebviewWindowBuilder::new(app, \"first\", webview_url.clone())\n                .title(\"First\")\n                .build()?;\n            // Second window\n            tauri::WebviewWindowBuilder::new(app, \"second\", webview_url)\n                .title(\"Second\")\n                .build()?;\n            Ok(())\n        })\n        .run(context)\n        .expect(\"error while running tauri application\");",
          "context": "window_management",
          "file_path": null,
          "description": "",
          "dependencies": null
        },
        {
          "language": "json",
          "code": "{\n      \"identifier\": \"fs-read-home\",\n      \"description\": \"Allow access file access to home directory\",\n      \"local\": true,\n      \"windows\": [\"first\"],\n      \"permissions\": [\n        \"fs:allow-home-read\",\n      ]\n    }",
          "context": "window_management",
          "file_path": "filesystem.json",
          "description": "<ShowSolution>\n    Use the `windows` field in a capability file with one or multiple window labels",
          "dependencies": null
        },
        {
          "language": "json",
          "code": "{\n      \"identifier\": \"dialog\",\n      \"description\": \"Allow to open a dialog\",\n      \"local\": true,\n      \"windows\": [\"first\", \"second\"],\n      \"permissions\": [\"dialog:allow-ask\"]\n    }",
          "context": "window_management",
          "file_path": "dialog.json",
          "description": "er\": \"fs-read-home\",\n      \"description\": \"Allow access file access to home directory\",\n      \"local\": true,\n      \"windows\": [\"first\"],\n      \"permissions\": [\n        \"fs:allow-home-read\",\n      ]\n    }\n    ```\n    </ShowSolution>\n\n    #### Give dialog capabilities to the `first` and `second` window\n\n    We give to `first` and `second` windows the capability to create a \"Yes/No\" dialog\n\n    <ShowSolution>\n    Use the `windows` field in a capability file with one or multiple window labels",
          "dependencies": null
        },
        {
          "language": "json",
          "code": "{\n      \"identifier\": \"fs-read-home\",\n      \"description\": \"Allow access file access to home directory\",\n      \"local\": true,\n      \"windows\": [\"first\"],\n      \"permissions\": [\n        \"fs:allow-home-read\",\n      ],\n      \"platforms\": [\"linux\", \"windows\"]\n    }",
          "context": "window_management",
          "file_path": "filesystem.json",
          "description": "<ShowSolution>\n    Use the `platforms` field in a capability file to make it platform-specific",
          "dependencies": null
        }
      ],
      "related_concepts": [
        "`Using Plugin Permissions`",
        "Capability"
      ],
      "difficulty": "intermediate",
      "tags": [
        "rust",
        "windows",
        "capabilities",
        "platforms",
        "linux",
        "ios",
        "javascript",
        "android",
        "macos"
      ]
    },
    {
      "name": "Configuration Files",
      "category": "communication",
      "description": "import CommandTabs from '@components/CommandTabs.astro';",
      "key_points": [
        "`tauri.linux.conf.json` or `Tauri.linux.toml` for Linux",
        "`tauri.windows.conf.json` or `Tauri.windows.toml` for Windows",
        "`tauri.macos.conf.json` or `Tauri.macos.toml` for macOS",
        "that JSON5 and TOML supports comments, and TOML can use kebab-case for config names which are more idiomatic",
        "to know that it exists and what it does",
        "parts to take note of are the `tauri-build` and `tauri` dependencies",
        "of is the `features=[]` portion of the `tauri` dependency"
      ],
      "code_examples": [
        {
          "language": "toml",
          "code": "[build-dependencies]\ntauri-build = { version = \"2.0.0\", features = [ \"config-json5\" ] }\n\n[dependencies]\ntauri = { version = \"2.0.0\", features = [  \"config-json5\" ] }",
          "context": "general",
          "file_path": "Cargo.toml",
          "description": "toml`",
          "dependencies": null
        },
        {
          "language": "json5",
          "code": "{\n  build: {\n    devUrl: 'http://localhost:3000',\n    // start the dev server\n    beforeDevCommand: 'npm run dev',\n  },\n  bundle: {\n    active: true,\n    icon: ['icons/app.png'],\n  },\n  app: {\n    windows: [\n      {\n        title: 'MyApp',\n      },\n    ],\n  },\n  plugins: {\n    updater: {\n      pubkey: 'updater pub key',\n      endpoints: ['https://my.app.updater/{{target}}/{{current_version}}'],\n    },\n  },\n}",
          "context": "general",
          "file_path": "tauri.conf.json or tauri.conf.json5",
          "description": "0",
          "dependencies": null
        },
        {
          "language": "toml",
          "code": "[build]\ndev-url = \"http://localhost:3000\"\n# start the dev server\nbefore-dev-command = \"npm run dev\"\n\n[bundle]\nactive = true\nicon = [\"icons/app.png\"]\n\n[[app.windows]]\ntitle = \"MyApp\"\n\n[plugins.updater]\npubkey = \"updater pub key\"\nendpoints = [\"https://my.app.updater/{{target}}/{{current_version}}\"]",
          "context": "plugin",
          "file_path": "Tauri.toml",
          "description": "app",
          "dependencies": null
        },
        {
          "language": "json",
          "code": "{\n  \"productName\": \"MyApp\",\n  \"bundle\": {\n    \"resources\": [\"./resources\"]\n  },\n  \"plugins\": {\n    \"deep-link\": {}\n  }\n}",
          "context": "general",
          "file_path": "tauri.conf.json",
          "description": "conf",
          "dependencies": null
        },
        {
          "language": "json",
          "code": "{\n  \"productName\": \"my-app\",\n  \"bundle\": {\n    \"resources\": [\"./linux-assets\"]\n  },\n  \"plugins\": {\n    \"cli\": {\n      \"description\": \"My app\",\n      \"subcommands\": {\n        \"update\": {}\n      }\n    },\n    \"deep-link\": {}\n  }\n}",
          "context": "plugin",
          "file_path": "tauri.linux.conf.json",
          "description": "conf",
          "dependencies": null
        },
        {
          "language": "json",
          "code": "{\n  \"productName\": \"my-app\",\n  \"bundle\": {\n    \"resources\": [\"./linux-assets\"]\n  },\n  \"plugins\": {\n    \"cli\": {\n      \"description\": \"My app\",\n      \"subcommands\": {\n        \"update\": {}\n      }\n    },\n    \"deep-link\": {}\n  }\n}",
          "context": "command",
          "file_path": null,
          "description": "json\n{\n  \"productName\": \"my-app\",\n  \"bundle\": {\n    \"resources\": [\"",
          "dependencies": null
        },
        {
          "language": "json",
          "code": "{\n  \"productName\": \"My App Beta\",\n  \"identifier\": \"com.myorg.myappbeta\"\n}",
          "context": "general",
          "file_path": "src-tauri/tauri.beta.conf.json",
          "description": "This mechanism can be used to define multiple flavours of your application or have more flexibility when configuring your application bundles",
          "dependencies": null
        },
        {
          "language": "toml",
          "code": "[package]\nname = \"app\"\nversion = \"0.1.0\"\ndescription = \"A Tauri App\"\nauthors = [\"you\"]\nlicense = \"\"\nrepository = \"\"\ndefault-run = \"app\"\nedition = \"2021\"\nrust-version = \"1.57\"\n\n[build-dependencies]\ntauri-build = { version = \"2.0.0\" }\n\n[dependencies]\nserde_json = \"1.0\"\nserde = { version = \"1.0\", features = [\"derive\"] }\ntauri = { version = \"2.0.0\", features = [ ] }",
          "context": "rust_backend",
          "file_path": "Cargo.toml",
          "description": "Below is an example of a barebones `Cargo",
          "dependencies": null
        },
        {
          "language": "json",
          "code": "{\n  \"scripts\": {\n    \"dev\": \"command to start your app development mode\",\n    \"build\": \"command to build your app frontend\",\n    \"tauri\": \"tauri\"\n  },\n  \"dependencies\": {\n    \"@tauri-apps/api\": \"^2.0.0.0\",\n    \"@tauri-apps/cli\": \"^2.0.0.0\"\n  }\n}",
          "context": "frontend_integration",
          "file_path": "package.json",
          "description": "An example of a barebones `package",
          "dependencies": null
        },
        {
          "language": "json",
          "code": "{\n  \"build\": {\n    \"beforeDevCommand\": \"yarn dev\",\n    \"beforeBuildCommand\": \"yarn build\"\n  }\n}",
          "context": "command",
          "file_path": "tauri.conf.json",
          "description": "json` file specifies the `dev` command that you can run using `yarn dev` or `npm run dev` to start the frontend framework and the `build` command that you can run using `yarn build` or `npm run build` to build your frontend's Web assets to be added by Tauri in production",
          "dependencies": null
        }
      ],
      "related_concepts": [
        "name",
        "version of your app"
      ],
      "difficulty": "beginner",
      "tags": [
        "configuration",
        "files",
        "windows",
        "rust",
        "linux",
        "ios",
        "android",
        "macos"
      ]
    },
    {
      "name": "Core Permissions",
      "category": "security",
      "description": "A list of all permissions that can be used with the core of the Tauri framework.",
      "key_points": [
        "`core:resources:default`",
        "`core:webview:default`",
        "`core:window:default`",
        "`allow-tauri-version`"
      ],
      "code_examples": [],
      "related_concepts": [
        "Plugins section"
      ],
      "difficulty": "intermediate",
      "tags": [
        "core",
        "permissions",
        "windows"
      ]
    },
    {
      "name": "Create a Project",
      "category": "general",
      "description": "import { Steps } from '@astrojs/starlight/components';",
      "key_points": [
        "Choose which language to use for your frontend: `TypeScript / JavaScript`",
        "Choose your package manager: `pnpm`",
        "Choose your UI template: `Vanilla`",
        "Choose your UI flavor: `TypeScript`",
        "The following example assumes you are creating a new project"
      ],
      "code_examples": [],
      "related_concepts": [
        "Learn how to develop your Tauri app",
        "Add and Configure a Frontend Framework",
        "Tauri CLI",
        "Tauri Command Line Interface (CLI) Reference",
        "integrate a frontend framework",
        "Discover additional features to extend Tauri",
        "Learn about the project layout and what each file does",
        "add Tauri to an existing project"
      ],
      "difficulty": "beginner",
      "tags": [
        "vue",
        "create",
        "react",
        "rust",
        "windows",
        "linux",
        "svelte",
        "typescript",
        "javascript",
        "project",
        "macos"
      ]
    },
    {
      "name": "Debug in VS Code",
      "category": "debugging",
      "description": "This guide will walk you through setting up VS Code for debugging the [Core Process of your Tauri app](/concept/process-model/#the-core-process).",
      "key_points": [
        "that it does not use the Tauri CLI, so exclusive CLI features are not executed",
        "that it does not use the Tauri CLI, so exclusive CLI features are not executed"
      ],
      "code_examples": [
        {
          "language": "json",
          "code": "{\n  // Use IntelliSense to learn about possible attributes.\n  // Hover to view descriptions of existing attributes.\n  // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387\n  \"version\": \"0.2.0\",\n  \"configurations\": [\n    {\n      \"type\": \"lldb\",\n      \"request\": \"launch\",\n      \"name\": \"Tauri Development Debug\",\n      \"cargo\": {\n        \"args\": [\n          \"build\",\n          \"--manifest-path=./src-tauri/Cargo.toml\",\n          \"--no-default-features\"\n        ]\n      },\n      // task for the `beforeDevCommand` if used, must be configured in `.vscode/tasks.json`\n      \"preLaunchTask\": \"ui:dev\"\n    },\n    {\n      \"type\": \"lldb\",\n      \"request\": \"launch\",\n      \"name\": \"Tauri Production Debug\",\n      \"cargo\": {\n        \"args\": [\"build\", \"--release\", \"--manifest-path=./src-tauri/Cargo.toml\"]\n      },\n      // task for the `beforeBuildCommand` if used, must be configured in `.vscode/tasks.json`\n      \"preLaunchTask\": \"ui:build\"\n    }\n  ]\n}",
          "context": "general",
          "file_path": ".vscode/launch.json",
          "description": "vscode/launch",
          "dependencies": null
        },
        {
          "language": "json",
          "code": "{\n  // See https://go.microsoft.com/fwlink/?LinkId=733558\n  // for the documentation about the tasks.json format\n  \"version\": \"2.0.0\",\n  \"tasks\": [\n    {\n      \"label\": \"ui:dev\",\n      \"type\": \"shell\",\n      // `dev` keeps running in the background\n      // ideally you should also configure a `problemMatcher`\n      // see https://code.visualstudio.com/docs/editor/tasks#_can-a-background-task-be-used-as-a-prelaunchtask-in-launchjson\n      \"isBackground\": true,\n      // change this to your `beforeDevCommand`:\n      \"command\": \"yarn\",\n      \"args\": [\"dev\"]\n    },\n    {\n      \"label\": \"ui:build\",\n      \"type\": \"shell\",\n      // change this to your `beforeBuildCommand`:\n      \"command\": \"yarn\",\n      \"args\": [\"build\"]\n    }\n  ]\n}",
          "context": "command",
          "file_path": ".vscode/tasks.json",
          "description": "vscode/tasks",
          "dependencies": null
        },
        {
          "language": "json",
          "code": "{\n  // Use IntelliSense to learn about possible attributes.\n  // Hover to view descriptions of existing attributes.\n  // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387\n  \"version\": \"0.2.0\",\n  \"configurations\": [\n    {\n      \"name\": \"Launch App Debug\",\n      \"type\": \"cppvsdbg\",\n      \"request\": \"launch\",\n      // change the exe name to your actual exe name\n      // (to debug release builds, change `target/debug` to `release/debug`)\n      \"program\": \"${workspaceRoot}/src-tauri/target/debug/your-app-name-here.exe\",\n      \"cwd\": \"${workspaceRoot}\",\n      \"preLaunchTask\": \"ui:dev\"\n    }\n  ]\n}",
          "context": "window_management",
          "file_path": ".vscode/launch.json",
          "description": "json and tasks",
          "dependencies": null
        },
        {
          "language": "json",
          "code": "{\n  // See https://go.microsoft.com/fwlink/?LinkId=733558\n  // for the documentation about the tasks.json format\n  \"version\": \"2.0.0\",\n  \"tasks\": [\n    {\n      \"label\": \"build:debug\",\n      \"type\": \"cargo\",\n      \"command\": \"build\",\n      \"options\": {\n        \"cwd\": \"${workspaceRoot}/src-tauri\"\n      }\n    },\n    {\n      \"label\": \"ui:dev\",\n      \"type\": \"shell\",\n      // `dev` keeps running in the background\n      // ideally you should also configure a `problemMatcher`\n      // see https://code.visualstudio.com/docs/editor/tasks#_can-a-background-task-be-used-as-a-prelaunchtask-in-launchjson\n      \"isBackground\": true,\n      // change this to your `beforeDevCommand`:\n      \"command\": \"yarn\",\n      \"args\": [\"dev\"]\n    },\n    {\n      \"label\": \"dev\",\n      \"dependsOn\": [\"build:debug\", \"ui:dev\"],\n      \"group\": {\n        \"kind\": \"build\"\n      }\n    }\n  ]\n}",
          "context": "command",
          "file_path": ".vscode/tasks.json",
          "description": "json` to `dev` (or anything you named your group)",
          "dependencies": null
        }
      ],
      "related_concepts": [
        "Core Process of your Tauri app"
      ],
      "difficulty": "beginner",
      "tags": [
        "windows",
        "rust",
        "debug",
        "vscode"
      ]
    },
    {
      "name": "Develop",
      "category": "communication",
      "description": "import CommandTabs from '@components/CommandTabs.astro';",
      "key_points": [
        "Every framework has its own development tooling",
        "that in this example the `src` folder must include a `index",
        "Projects created with [create-tauri-app](https://github",
        "Each Android distribution has its own way to enable the Developer Mode, please check your manufacturer's documentation for more information"
      ],
      "code_examples": [
        {
          "language": "json",
          "code": "{\n  \"build\": {\n    \"devUrl\": \"http://localhost:3000\",\n    \"beforeDevCommand\": \"npm run dev\"\n  }\n}",
          "context": "command",
          "file_path": "tauri.conf.json",
          "description": "astro';\n\nNow that you have [everything set up](/start/), you are ready to run your application using Tauri",
          "dependencies": null
        },
        {
          "language": "json",
          "code": "{\n  \"build\": {\n    \"frontendDist\": \"./src\"\n  }\n}",
          "context": "frontend_integration",
          "file_path": "tauri.conf.json",
          "description": "Please refer to your framework's documentation to learn more and determine the correct values to be configured",
          "dependencies": null
        },
        {
          "language": "js",
          "code": "import { defineConfig } from 'vite';\n\nconst host = process.env.TAURI_DEV_HOST;\n\n// https://vitejs.dev/config/\nexport default defineConfig({\n  clearScreen: false,\n  server: {\n    host: host || false,\n    port: 1420,\n    strictPort: true,\n    hmr: host\n      ? {\n          protocol: 'ws',\n          host,\n          port: 1421,\n        }\n      : undefined,\n  },\n});",
          "context": "general",
          "file_path": null,
          "description": "To make your development server listen on the correct host to be accessible by the iOS device you must tweak its configuration\nto use the `TAURI_DEV_HOST` value if it has been provided",
          "dependencies": null
        }
      ],
      "related_concepts": [
        "devUrl",
        "everything set up",
        "development server security considerations",
        "beforeDevCommand"
      ],
      "difficulty": "intermediate",
      "tags": [
        "desktop",
        "develop",
        "react",
        "windows",
        "rust",
        "linux",
        "ios",
        "mobile",
        "javascript",
        "android",
        "macos"
      ]
    },
    {
      "name": "Environment Variables",
      "category": "communication",
      "description": "This is a documentation of all environment variables used by tauri core crates and tauri CLI.",
      "key_points": [
        "`CI` — If set, the CLI will run in CI mode and won't require any user interaction.",
        "`TAURI_CLI_CONFIG_DEPTH` — Number of levels to traverse and find tauri configuration file.",
        "`TAURI_CLI_PORT` — Port to use for the CLI built-in dev server.",
        "`TAURI_CLI_WATCHER_IGNORE_FILENAME` — Name of a `.gitignore`-style file to control which files should be watched by the CLI in `dev` command. The CLI will look for this file name in each directory.",
        "`TAURI_CLI_NO_DEV_SERVER_WAIT` — Skip waiting for the frontend dev server to start before building the tauri application.",
        "`TAURI_LINUX_AYATANA_APPINDICATOR` — Set this var to `true` or `1` to force usage of `libayatana-appindicator` for system tray on Linux.",
        "`TAURI_BUNDLER_WIX_FIPS_COMPLIANT` — Specify the bundler's WiX `FipsCompliant` option.",
        "`TAURI_BUNDLER_TOOLS_GITHUB_MIRROR` - Specify a GitHub mirror to download files and tools used by tauri bundler.",
        "`TAURI_SKIP_SIDECAR_SIGNATURE_CHECK` - Skip signing sidecars.",
        "`TAURI_SIGNING_PRIVATE_KEY` — Private key used to sign your app bundles, can be either a string or a path to the file."
      ],
      "code_examples": [],
      "related_concepts": [],
      "difficulty": "intermediate",
      "tags": [
        "variables",
        "environment",
        "windows",
        "linux",
        "ios",
        "android",
        "macos"
      ]
    },
    {
      "name": "Calling the Frontend from Rust",
      "category": "general",
      "description": "The `@tauri-apps/api` NPM package offers APIs to listen to both global and webview-specific events.",
      "key_points": [
        "Listening to global events",
        "Listening to webview-specific events",
        "Listening to global events",
        "Listening to webview-specific events",
        "Events emitted in the frontend also triggers listeners registed by these APIs"
      ],
      "code_examples": [
        {
          "language": "ts",
          "code": "import { listen } from '@tauri-apps/api/event';\n\n  type DownloadStarted = {\n    url: string;\n    downloadId: number;\n    contentLength: number;\n  };\n\n  listen<DownloadStarted>('download-started', (event) => {\n    console.log(\n      `downloading ${event.payload.contentLength} bytes from ${event.payload.url}`\n    );\n  });",
          "context": "frontend_integration",
          "file_path": null,
          "description": "---\ntitle: Calling the Frontend from Rust\n---\n\nThe `@tauri-apps/api` NPM package offers APIs to listen to both global and webview-specific events",
          "dependencies": null
        },
        {
          "language": "ts",
          "code": "import { getCurrentWebviewWindow } from '@tauri-apps/api/webviewWindow';\n\n  const appWebview = getCurrentWebviewWindow();\n  appWebview.listen<string>('logged-in', (event) => {\n    localStorage.setItem('session-token', event.payload);\n  });",
          "context": "general",
          "file_path": null,
          "description": "payload",
          "dependencies": null
        },
        {
          "language": "js",
          "code": "import { listen } from '@tauri-apps/api/event';\n\nconst unlisten = await listen('download-started', (event) => {});\nunlisten();",
          "context": "general",
          "file_path": null,
          "description": "payload);\n  });\n  ```\n\nThe `listen` function keeps the event listener registered for the entire lifetime of the application",
          "dependencies": null
        },
        {
          "language": "js",
          "code": "import { once } from '@tauri-apps/api/event';\nimport { getCurrentWebviewWindow } from '@tauri-apps/api/webviewWindow';\n\nonce('ready', (event) => {});\n\nconst appWebview = getCurrentWebviewWindow();\nappWebview.once('ready', () => {});",
          "context": "general",
          "file_path": null,
          "description": "This does not apply to a Single Page Application (SPA) router though",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "use tauri::Listener;\n\n  #[cfg_attr(mobile, tauri::mobile_entry_point)]\n  pub fn run() {\n    tauri::Builder::default()\n      .setup(|app| {\n        app.listen(\"download-started\", |event| {\n          if let Ok(payload) = serde_json::from_str::<DownloadStarted>(&event.payload()) {\n            println!(\"downloading {}\", payload.url);\n          }\n        });\n        Ok(())\n      })\n      .run(tauri::generate_context!())\n      .expect(\"error while running tauri application\");\n  }",
          "context": "frontend_integration",
          "file_path": "src-tauri/src/lib.rs",
          "description": ":::\n\n#### Listening to Events on Rust\n\nGlobal and webview-specific events are also delivered to listeners registered in Rust",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "use tauri::{Listener, Manager};\n\n  #[cfg_attr(mobile, tauri::mobile_entry_point)]\n  pub fn run() {\n    tauri::Builder::default()\n      .setup(|app| {\n        let webview = app.get_webview_window(\"main\").unwrap();\n        webview.listen(\"logged-in\", |event| {\n          let session_token = event.data;\n          // save token..\n        });\n        Ok(())\n      })\n      .run(tauri::generate_context!())\n      .expect(\"error while running tauri application\");\n  }",
          "context": "general",
          "file_path": "src-tauri/src/lib.rs",
          "description": "run(tauri::generate_context!())",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "// unlisten outside of the event handler scope:\nlet event_id = app.listen(\"download-started\", |event| {});\napp.unlisten(event_id);\n\n// unlisten when some event criteria is matched\nlet handle = app.handle().clone();\napp.listen(\"status-changed\", |event| {\n  if event.data == \"ready\" {\n    handle.unlisten(event.id);\n  }\n});",
          "context": "general",
          "file_path": null,
          "description": "expect(\"error while running tauri application\");\n  }\n  ```\n\nThe `listen` function keeps the event listener registered for the entire lifetime of the application",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "app.once(\"ready\", |event| {\n  println!(\"app is ready\");\n});",
          "context": "general",
          "file_path": null,
          "description": "unlisten(event",
          "dependencies": null
        }
      ],
      "related_concepts": [],
      "difficulty": "beginner",
      "tags": [
        "rust",
        "listen",
        "mobile",
        "frontend"
      ]
    },
    {
      "name": "App Icons",
      "category": "communication",
      "description": "{/* TODO: More platform specific explanations like macOS requiring padding in the icon (waiting for https://github.com/tauri-apps/tauri/pull/11037) */}",
      "key_points": [
        "`Square*Logo.png` & `StoreLogo.png` = Currently unused but intended for AppX/MS Store targets.",
        "`icon.icns`: The required layer sizes and names for the [`icns`] file are described [in the Tauri repo]",
        "`icon.ico`: The [`ico`] file must include layers for 16, 24, 32, 48, 64 and 256 pixels. For an optimal display of the ICO image _in development_, the 32px layer should be th"
      ],
      "code_examples": [
        {
          "language": "console",
          "code": "> pnpm tauri icon --help\n\nGenerate various icons for all major platforms\n\nUsage: pnpm run tauri icon [OPTIONS] [INPUT]\n\nArguments:\n  [INPUT]  Path to the source icon (squared PNG or SVG file with transparency) [default: ./app-icon.png]\n\nOptions:\n  -o, --output <OUTPUT>        Output directory. Default: 'icons' directory next to the tauri.conf.json file\n  -v, --verbose...             Enables verbose logging\n  -p, --png <PNG>              Custom PNG icon sizes to generate. When set, the default icons are not generated\n      --ios-color <IOS_COLOR>  The background color of the iOS icon - string as defined in the W3C's CSS Color Module Level 4 <https://www.w3.org/TR/css-color-4/> [default: #fff]\n  -h, --help                   Print help\n  -V, --version                Print version",
          "context": "command",
          "file_path": null,
          "description": "Therefore we recommend including all icons even if you intend to only build for a subset of platforms",
          "dependencies": null
        },
        {
          "language": "json",
          "code": "{\n  \"bundle\": {\n    \"icon\": [\n      \"icons/32x32.png\",\n      \"icons/128x128.png\",\n      \"icons/128x128@2x.png\",\n      \"icons/icon.icns\",\n      \"icons/icon.ico\"\n    ]\n  }\n}",
          "context": "general",
          "file_path": null,
          "description": "conf",
          "dependencies": null
        }
      ],
      "related_concepts": [],
      "difficulty": "intermediate",
      "tags": [
        "android",
        "desktop",
        "icons ",
        "windows",
        "linux",
        "ios",
        "mobile",
        " copy",
        "macos"
      ]
    },
    {
      "name": "App Icons",
      "category": "communication",
      "description": "{/* TODO: More platform specific explanations like macOS requiring padding in the icon (waiting for https://github.com/tauri-apps/tauri/pull/11037) */}",
      "key_points": [
        "`Square*Logo.png` & `StoreLogo.png` = Currently unused but intended for AppX/MS Store targets.",
        "`icon.icns`: The required layer sizes and names for the [`icns`] file are described [in the Tauri repo]",
        "`icon.ico`: The [`ico`] file must include layers for 16, 24, 32, 48, 64 and 256 pixels. For an optimal display of the ICO image _in development_, the 32px layer should be th"
      ],
      "code_examples": [
        {
          "language": "console",
          "code": "> pnpm tauri icon --help\n\nGenerate various icons for all major platforms\n\nUsage: pnpm run tauri icon [OPTIONS] [INPUT]\n\nArguments:\n  [INPUT]  Path to the source icon (squared PNG or SVG file with transparency) [default: ./app-icon.png]\n\nOptions:\n  -o, --output <OUTPUT>        Output directory. Default: 'icons' directory next to the tauri.conf.json file\n  -v, --verbose...             Enables verbose logging\n  -p, --png <PNG>              Custom PNG icon sizes to generate. When set, the default icons are not generated\n      --ios-color <IOS_COLOR>  The background color of the iOS icon - string as defined in the W3C's CSS Color Module Level 4 <https://www.w3.org/TR/css-color-4/> [default: #fff]\n  -h, --help                   Print help\n  -V, --version                Print version",
          "context": "command",
          "file_path": null,
          "description": "Therefore we recommend including all icons even if you intend to only build for a subset of platforms",
          "dependencies": null
        },
        {
          "language": "json",
          "code": "{\n  \"bundle\": {\n    \"icon\": [\n      \"icons/32x32.png\",\n      \"icons/128x128.png\",\n      \"icons/128x128@2x.png\",\n      \"icons/icon.icns\",\n      \"icons/icon.ico\"\n    ]\n  }\n}",
          "context": "general",
          "file_path": null,
          "description": "conf",
          "dependencies": null
        }
      ],
      "related_concepts": [],
      "difficulty": "intermediate",
      "tags": [
        "desktop",
        "windows",
        "icons",
        "linux",
        "ios",
        "mobile",
        "android",
        "macos"
      ]
    },
    {
      "name": "Upgrade from Tauri 1.0",
      "category": "migration",
      "description": "import { Tabs, TabItem } from '@astrojs/starlight/components'; import CommandTabs from '@components/CommandTabs.astro';",
      "key_points": [
        "`package > productName` and `package > version` moved to top-level object.",
        "the binary name is no longer renamed to match `productName` automatically, so you must add a `mainBinaryName` string to the top-level object matching `productName`.",
        "`tauri` key renamed to `app`.",
        "`tauri > allowlist` removed. Refer to [Migrate Permissions](#migrate-permissions).",
        "`tauri > allowlist > protocol > assetScope` moved to `app > security > assetProtocol > scope`.",
        "`tauri > cli` moved to `plugins > cli`.",
        "`tauri > windows > fileDropEnabled` renamed to `app > windows > dragDropEnabled`.",
        "`tauri > updater > active` removed.",
        "`tauri > updater > dialog` removed.",
        "`tauri > updater` moved to `plugins > updater`."
      ],
      "code_examples": [
        {
          "language": "toml",
          "code": "// src-tauri/Cargo.toml\n[lib]\nname = \"app_lib\"\ncrate-type = [\"staticlib\", \"cdylib\", \"rlib\"]",
          "context": "general",
          "file_path": null,
          "description": "Change the Cargo manifest to produce the library",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "// src-tauri/src/lib.rs\n#[cfg_attr(mobile, tauri::mobile_entry_point)]\npub fn run() {\n    // your code here\n}",
          "context": "general",
          "file_path": null,
          "description": "Rename the `main` function header in `lib",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "// src-tauri/src/main.rs\n#![cfg_attr(not(debug_assertions), windows_subsystem = \"windows\")]\n\nfn main() {\n  app_lib::run();\n}",
          "context": "general",
          "file_path": null,
          "description": "Recreate the `main",
          "dependencies": null
        },
        {
          "language": "diff",
          "code": "- import { invoke } from \"@tauri-apps/api/tauri\"\n+ import { invoke } from \"@tauri-apps/api/core\"",
          "context": "general",
          "file_path": null,
          "description": "### Migrate to Core Module\n\nThe `@tauri-apps/api/tauri` module was renamed to `@tauri-apps/api/core`",
          "dependencies": null
        },
        {
          "language": "toml",
          "code": "# Cargo.toml\n[dependencies]\ntauri-plugin-cli = \"2\"",
          "context": "plugin",
          "file_path": null,
          "description": "Use the `@tauri-apps/plugin-cli` plugin instead:\n\n1",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "fn main() {\n    tauri::Builder::default()\n        .plugin(tauri_plugin_cli::init())\n}",
          "context": "plugin",
          "file_path": null,
          "description": "toml\n[dependencies]\ntauri-plugin-cli = \"2\"\n```\n\n2",
          "dependencies": null
        },
        {
          "language": "json",
          "code": "// package.json\n{\n  \"dependencies\": {\n    \"@tauri-apps/plugin-cli\": \"^2.0.0\"\n  }\n}",
          "context": "plugin",
          "file_path": null,
          "description": "Use in JavaScript or Rust project:\n\n<Tabs syncKey=\"lang\">\n<TabItem label=\"JavaScript\">\n\n```rust\nfn main() {\n    tauri::Builder::default()",
          "dependencies": null
        },
        {
          "language": "javascript",
          "code": "import { getMatches } from '@tauri-apps/plugin-cli';\nconst matches = await getMatches();",
          "context": "plugin",
          "file_path": null,
          "description": "0",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "fn main() {\n    use tauri_plugin_cli::CliExt;\n    tauri::Builder::default()\n        .plugin(tauri_plugin_cli::init())\n        .setup(|app| {\n            let cli_matches = app.cli().matches()?;\n            Ok(())\n        })\n}",
          "context": "plugin",
          "file_path": null,
          "description": "0",
          "dependencies": null
        },
        {
          "language": "toml",
          "code": "[dependencies]\ntauri-plugin-clipboard-manager = \"2\"",
          "context": "plugin",
          "file_path": null,
          "description": "matches()?;\n            Ok(())\n        })\n}\n```\n\n</TabItem>\n</Tabs>\n\n### Migrate to Clipboard Plugin\n\nThe Rust `App::clipboard_manager` and `AppHandle::clipboard_manager` and JavaScript `@tauri-apps/api/clipboard` APIs have been removed",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "fn main() {\n    tauri::Builder::default()\n        .plugin(tauri_plugin_clipboard_manager::init())\n}",
          "context": "plugin",
          "file_path": null,
          "description": "matches()?;\n            Ok(())\n        })\n}\n```\n\n</TabItem>\n</Tabs>\n\n### Migrate to Clipboard Plugin\n\nThe Rust `App::clipboard_manager` and `AppHandle::clipboard_manager` and JavaScript `@tauri-apps/api/clipboard` APIs have been removed",
          "dependencies": null
        },
        {
          "language": "json",
          "code": "// package.json\n{\n  \"dependencies\": {\n    \"@tauri-apps/plugin-clipboard-manager\": \"^2.0.0\"\n  }\n}",
          "context": "plugin",
          "file_path": null,
          "description": "Use the `@tauri-apps/plugin-clipboard-manager` plugin instead:\n\n```toml\n[dependencies]\ntauri-plugin-clipboard-manager = \"2\"\n```\n\n<Tabs syncKey=\"lang\">\n<TabItem label=\"JavaScript\">\n\n```rust\nfn main() {\n    tauri::Builder::default()",
          "dependencies": null
        },
        {
          "language": "javascript",
          "code": "import { writeText, readText } from '@tauri-apps/plugin-clipboard-manager';\nawait writeText('Tauri is awesome!');\nassert(await readText(), 'Tauri is awesome!');",
          "context": "plugin",
          "file_path": null,
          "description": "0",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "use tauri_plugin_clipboard::{ClipboardExt, ClipKind};\ntauri::Builder::default()\n    .plugin(tauri_plugin_clipboard::init())\n    .setup(|app| {\n        app.clipboard().write(ClipKind::PlainText {\n            label: None,\n            text: \"Tauri is awesome!\".into(),\n        })?;\n        Ok(())\n    })",
          "context": "plugin",
          "file_path": null,
          "description": "0",
          "dependencies": null
        },
        {
          "language": "toml",
          "code": "# Cargo.toml\n[dependencies]\ntauri-plugin-dialog = \"2\"",
          "context": "plugin",
          "file_path": null,
          "description": "Use the `@tauri-apps/plugin-dialog` plugin instead:\n\n1",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "fn main() {\n    tauri::Builder::default()\n        .plugin(tauri_plugin_dialog::init())\n}",
          "context": "plugin",
          "file_path": null,
          "description": "toml\n[dependencies]\ntauri-plugin-dialog = \"2\"\n```\n\n2",
          "dependencies": null
        },
        {
          "language": "json",
          "code": "// package.json\n{\n  \"dependencies\": {\n    \"@tauri-apps/plugin-dialog\": \"^2.0.0\"\n  }\n}",
          "context": "plugin",
          "file_path": null,
          "description": "Use in JavaScript or Rust project:\n\n<Tabs syncKey=\"lang\">\n<TabItem label=\"JavaScript\">\n\n```rust\nfn main() {\n    tauri::Builder::default()",
          "dependencies": null
        },
        {
          "language": "javascript",
          "code": "import { save } from '@tauri-apps/plugin-dialog';\nconst filePath = await save({\n  filters: [\n    {\n      name: 'Image',\n      extensions: ['png', 'jpeg'],\n    },\n  ],\n});",
          "context": "plugin",
          "file_path": null,
          "description": "0",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "use tauri_plugin_dialog::DialogExt;\ntauri::Builder::default()\n    .plugin(tauri_plugin_dialog::init())\n    .setup(|app| {\n        app.dialog().file().pick_file(|file_path| {\n            // do something with the optional file path here\n            // the file path is `None` if the user closed the dialog\n        });\n\n        app.dialog().message(\"Tauri is Awesome!\").show();\n        Ok(())\n     })",
          "context": "plugin",
          "file_path": null,
          "description": "0",
          "dependencies": null
        },
        {
          "language": "toml",
          "code": "# Cargo.toml\n[dependencies]\ntauri-plugin-fs = \"2\"",
          "context": "plugin",
          "file_path": null,
          "description": "org/std/fs/) for Rust and `@tauri-apps/plugin-fs` plugin for JavaScript instead:\n\n1",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "fn main() {\n    tauri::Builder::default()\n        .plugin(tauri_plugin_fs::init())\n}",
          "context": "plugin",
          "file_path": null,
          "description": "toml\n[dependencies]\ntauri-plugin-fs = \"2\"\n```\n\n2",
          "dependencies": null
        },
        {
          "language": "json",
          "code": "// package.json\n{\n  \"dependencies\": {\n    \"@tauri-apps/plugin-fs\": \"^2.0.0\"\n  }\n}",
          "context": "plugin",
          "file_path": null,
          "description": "Use in JavaScript or Rust project:\n\n<Tabs syncKey=\"lang\">\n<TabItem label=\"JavaScript\">\n\n```rust\nfn main() {\n    tauri::Builder::default()",
          "dependencies": null
        },
        {
          "language": "javascript",
          "code": "import { mkdir, BaseDirectory } from '@tauri-apps/plugin-fs';\nawait mkdir('db', { baseDir: BaseDirectory.AppLocalData });",
          "context": "plugin",
          "file_path": null,
          "description": "0",
          "dependencies": null
        },
        {
          "language": "toml",
          "code": "# Cargo.toml\n[dependencies]\n[target.\"cfg(not(any(target_os = \\\"android\\\", target_os = \\\"ios\\\")))\".dependencies]\ntauri-plugin-global-shortcut = \"2\"",
          "context": "plugin",
          "file_path": null,
          "description": "Use the `@tauri-apps/plugin-global-shortcut` plugin instead:\n\n1",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "fn main() {\n    tauri::Builder::default()\n        .plugin(tauri_plugin_global_shortcut::Builder::default().build())\n}",
          "context": "plugin",
          "file_path": null,
          "description": "dependencies]\ntauri-plugin-global-shortcut = \"2\"\n```\n\n2",
          "dependencies": null
        },
        {
          "language": "json",
          "code": "// package.json\n{\n  \"dependencies\": {\n    \"@tauri-apps/plugin-global-shortcut\": \"^2.0.0\"\n  }\n}",
          "context": "plugin",
          "file_path": null,
          "description": "plugin(tauri_plugin_global_shortcut::Builder::default()",
          "dependencies": null
        },
        {
          "language": "javascript",
          "code": "import { register } from '@tauri-apps/plugin-global-shortcut';\nawait register('CommandOrControl+Shift+C', () => {\n  console.log('Shortcut triggered');\n});",
          "context": "plugin",
          "file_path": null,
          "description": "0",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "use tauri_plugin_global_shortcut::GlobalShortcutExt;\n\ntauri::Builder::default()\n    .plugin(\n        tauri_plugin_global_shortcut::Builder::new().with_handler(|app, shortcut| {\n            println!(\"Shortcut triggered: {:?}\", shortcut);\n        })\n        .build(),\n    )\n    .setup(|app| {\n        // register a global shortcut\n        // on macOS, the Cmd key is used\n        // on Windows and Linux, the Ctrl key is used\n        app.global_shortcut().register(\"CmdOrCtrl+Y\")?;\n        Ok(())\n    })",
          "context": "command",
          "file_path": null,
          "description": "0\"\n  }\n}\n```\n\n```javascript\nimport { register } from '@tauri-apps/plugin-global-shortcut';\nawait register('CommandOrControl+Shift+C', () => {\n  console",
          "dependencies": null
        },
        {
          "language": "toml",
          "code": "# Cargo.toml\n[dependencies]\ntauri-plugin-http = \"2\"",
          "context": "plugin",
          "file_path": null,
          "description": "Use the `@tauri-apps/plugin-http` plugin instead:\n\n1",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "fn main() {\n    tauri::Builder::default()\n        .plugin(tauri_plugin_http::init())\n}",
          "context": "plugin",
          "file_path": null,
          "description": "toml\n[dependencies]\ntauri-plugin-http = \"2\"\n```\n\n2",
          "dependencies": null
        },
        {
          "language": "json",
          "code": "// package.json\n{\n  \"dependencies\": {\n    \"@tauri-apps/plugin-http\": \"^2.0.0\"\n  }\n}",
          "context": "plugin",
          "file_path": null,
          "description": "Use in JavaScript or Rust project:\n\n<Tabs syncKey=\"lang\">\n<TabItem label=\"JavaScript\">\n\n```rust\nfn main() {\n    tauri::Builder::default()",
          "dependencies": null
        },
        {
          "language": "javascript",
          "code": "import { fetch } from '@tauri-apps/plugin-http';\nconst response = await fetch(\n  'https://raw.githubusercontent.com/tauri-apps/tauri/dev/package.json'\n);",
          "context": "plugin",
          "file_path": null,
          "description": "0",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "use tauri_plugin_http::reqwest;\n\ntauri::Builder::default()\n    .plugin(tauri_plugin_http::init())\n    .setup(|app| {\n        let response_data = tauri::async_runtime::block_on(async {\n            let response = reqwest::get(\n                \"https://raw.githubusercontent.com/tauri-apps/tauri/dev/package.json\",\n            )\n            .await\n            .unwrap();\n            response.text().await\n        })?;\n        Ok(())\n    })",
          "context": "plugin",
          "file_path": null,
          "description": "com/tauri-apps/tauri/dev/package",
          "dependencies": null
        },
        {
          "language": "toml",
          "code": "# Cargo.toml\n[dependencies]\ntauri-plugin-notification = \"2\"",
          "context": "plugin",
          "file_path": null,
          "description": "Use the `@tauri-apps/plugin-notification` plugin instead:\n\n1",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "fn main() {\n    tauri::Builder::default()\n        .plugin(tauri_plugin_notification::init())\n}",
          "context": "plugin",
          "file_path": null,
          "description": "toml\n[dependencies]\ntauri-plugin-notification = \"2\"\n```\n\n2",
          "dependencies": null
        },
        {
          "language": "json",
          "code": "// package.json\n{\n  \"dependencies\": {\n    \"@tauri-apps/plugin-notification\": \"^2.0.0\"\n  }\n}",
          "context": "plugin",
          "file_path": null,
          "description": "Use in JavaScript or Rust project:\n\n<Tabs syncKey=\"lang\">\n<TabItem label=\"JavaScript\">\n\n```rust\nfn main() {\n    tauri::Builder::default()",
          "dependencies": null
        },
        {
          "language": "javascript",
          "code": "import { sendNotification } from '@tauri-apps/plugin-notification';\nsendNotification('Tauri is awesome!');",
          "context": "plugin",
          "file_path": null,
          "description": "0",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "use tauri_plugin_notification::NotificationExt;\nuse tauri::plugin::PermissionState;\n\nfn main() {\n    tauri::Builder::default()\n        .plugin(tauri_plugin_notification::init())\n        .setup(|app| {\n            if app.notification().permission_state()? == PermissionState::Unknown {\n                app.notification().request_permission()?;\n            }\n            if app.notification().permission_state()? == PermissionState::Granted {\n                app.notification()\n                    .builder()\n                    .body(\"Tauri is awesome!\")\n                    .show()?;\n            }\n            Ok(())\n        })\n}",
          "context": "plugin",
          "file_path": null,
          "description": "0",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "use tauri::menu::MenuBuilder;\n\ntauri::Builder::default()\n    .setup(|app| {\n        let menu = MenuBuilder::new(app)\n            .copy()\n            .paste()\n            .separator()\n            .undo()\n            .redo()\n            .text(\"open-url\", \"Open URL\")\n            .check(\"toggle\", \"Toggle\")\n            .icon(\"show-app\", \"Show App\", app.default_window_icon().cloned().unwrap())\n            .build()?;\n        Ok(())\n    })",
          "context": "window_management",
          "file_path": null,
          "description": "#### Use `tauri::menu::MenuBuilder`\n\nUse `tauri::menu::MenuBuilder` instead of `tauri::Menu`",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "use tauri::menu::{MenuBuilder, PredefinedMenuItem};\n\ntauri::Builder::default()\n    .setup(|app| {\n        let menu = MenuBuilder::new(app).item(&PredefinedMenuItem::copy(app)?).build()?;\n        Ok(())\n    })",
          "context": "window_management",
          "file_path": null,
          "description": "unwrap())",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "use tauri::menu::MenuItemBuilder;\n\ntauri::Builder::default()\n    .setup(|app| {\n        let toggle = MenuItemBuilder::new(\"Toggle\").accelerator(\"Ctrl+Shift+T\").build(app)?;\n        Ok(())\n    })",
          "context": "general",
          "file_path": null,
          "description": "item(&PredefinedMenuItem::copy(app, None)?)`",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "use tauri::menu::{MenuBuilder, SubmenuBuilder};\n\ntauri::Builder::default()\n    .setup(|app| {\n        let submenu = SubmenuBuilder::new(app, \"Sub\")\n            .text(\"Tauri\")\n            .separator()\n            .check(\"Is Awesome\")\n            .build()?;\n        let menu = MenuBuilder::new(app).item(&submenu).build()?;\n        Ok(())\n    })",
          "context": "general",
          "file_path": null,
          "description": "accelerator(\"Ctrl+Shift+T\")",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "use tauri::menu::{CheckMenuItemBuilder, MenuBuilder, MenuItemBuilder};\n\ntauri::Builder::default()\n    .setup(|app| {\n        let toggle = MenuItemBuilder::with_id(\"toggle\", \"Toggle\").build(app)?;\n        let check = CheckMenuItemBuilder::new(\"Mark\").build(app)?;\n        let menu = MenuBuilder::new(app).items(&[&toggle, &check]).build()?;\n\n        app.set_menu(menu)?;\n\n        app.on_menu_event(move |app, event| {\n            if event.id() == check.id() {\n                println!(\"`check` triggered, do something! is checked? {}\", check.is_checked().unwrap());\n            } else if event.id() == \"toggle\" {\n                println!(\"toggle triggered!\");\n            }\n        });\n        Ok(())\n    })",
          "context": "rust_backend",
          "file_path": null,
          "description": "#### Menu Events\n\nThe Rust `tauri::Builder::on_menu_event` API was removed",
          "dependencies": null
        },
        {
          "language": "toml",
          "code": "# Cargo.toml\n[dependencies]\ntauri-plugin-os = \"2\"",
          "context": "plugin",
          "file_path": null,
          "description": "Use the `@tauri-apps/plugin-os` plugin instead:\n\n1",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "fn main() {\n    tauri::Builder::default()\n        .plugin(tauri_plugin_os::init())\n}",
          "context": "plugin",
          "file_path": null,
          "description": "toml\n[dependencies]\ntauri-plugin-os = \"2\"\n```\n\n2",
          "dependencies": null
        },
        {
          "language": "json",
          "code": "// package.json\n{\n  \"dependencies\": {\n    \"@tauri-apps/plugin-os\": \"^2.0.0\"\n  }\n}",
          "context": "plugin",
          "file_path": null,
          "description": "Use in JavaScript or Rust project:\n\n<Tabs syncKey=\"lang\">\n<TabItem label=\"JavaScript\">\n\n```rust\nfn main() {\n    tauri::Builder::default()",
          "dependencies": null
        },
        {
          "language": "javascript",
          "code": "import { arch } from '@tauri-apps/plugin-os';\nconst architecture = await arch();",
          "context": "plugin",
          "file_path": null,
          "description": "0",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "fn main() {\n    tauri::Builder::default()\n        .plugin(tauri_plugin_os::init())\n        .setup(|app| {\n            let os_arch = tauri_plugin_os::arch();\n            Ok(())\n        })\n}",
          "context": "plugin",
          "file_path": null,
          "description": "0",
          "dependencies": null
        },
        {
          "language": "toml",
          "code": "# Cargo.toml\n[dependencies]\ntauri-plugin-process = \"2\"",
          "context": "plugin",
          "file_path": null,
          "description": "Use the `@tauri-apps/plugin-process` plugin instead:\n\n1",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "fn main() {\n    tauri::Builder::default()\n        .plugin(tauri_plugin_process::init())\n}",
          "context": "plugin",
          "file_path": null,
          "description": "toml\n[dependencies]\ntauri-plugin-process = \"2\"\n```\n\n2",
          "dependencies": null
        },
        {
          "language": "json",
          "code": "// package.json\n{\n  \"dependencies\": {\n    \"@tauri-apps/plugin-process\": \"^2.0.0\"\n  }\n}",
          "context": "plugin",
          "file_path": null,
          "description": "Use in JavaScript or Rust project:\n\n<Tabs syncKey=\"lang\">\n<TabItem label=\"JavaScript\">\n\n```rust\nfn main() {\n    tauri::Builder::default()",
          "dependencies": null
        },
        {
          "language": "javascript",
          "code": "import { exit, relaunch } from '@tauri-apps/plugin-process';\nawait exit(0);\nawait relaunch();",
          "context": "plugin",
          "file_path": null,
          "description": "0",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "fn main() {\n    tauri::Builder::default()\n        .plugin(tauri_plugin_process::init())\n        .setup(|app| {\n            // exit the app with a status code\n            app.handle().exit(1);\n            // restart the app\n            app.handle().restart();\n            Ok(())\n        })\n}",
          "context": "plugin",
          "file_path": null,
          "description": "0",
          "dependencies": null
        },
        {
          "language": "toml",
          "code": "# Cargo.toml\n[dependencies]\ntauri-plugin-shell = \"2\"",
          "context": "plugin",
          "file_path": null,
          "description": "Use the `@tauri-apps/plugin-shell` plugin instead:\n\n1",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "fn main() {\n    tauri::Builder::default()\n        .plugin(tauri_plugin_shell::init())\n}",
          "context": "plugin",
          "file_path": null,
          "description": "toml\n[dependencies]\ntauri-plugin-shell = \"2\"\n```\n\n2",
          "dependencies": null
        },
        {
          "language": "json",
          "code": "// package.json\n{\n  \"dependencies\": {\n    \"@tauri-apps/plugin-shell\": \"^2.0.0\"\n  }\n}",
          "context": "plugin",
          "file_path": null,
          "description": "Use in JavaScript or Rust project:\n\n<Tabs syncKey=\"lang\">\n<TabItem label=\"JavaScript\">\n\n```rust\nfn main() {\n    tauri::Builder::default()",
          "dependencies": null
        },
        {
          "language": "javascript",
          "code": "import { Command, open } from '@tauri-apps/plugin-shell';\nconst output = await Command.create('echo', 'message').execute();\n\nawait open('https://github.com/tauri-apps/tauri');",
          "context": "plugin",
          "file_path": null,
          "description": "0",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "use tauri_plugin_shell::ShellExt;\n\nfn main() {\n    tauri::Builder::default()\n        .plugin(tauri_plugin_shell::init())\n        .setup(|app| {\n            app.shell().open(\"https://github.com/tauri-apps/tauri\", None)?;\n            Ok(())\n        })\n}",
          "context": "command",
          "file_path": null,
          "description": "execute();\n\nawait open('https://github",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "use tauri_plugin_shell::ShellExt;\n\nfn main() {\n    tauri::Builder::default()\n        .plugin(tauri_plugin_shell::init())\n        .setup(|app| {\n            let status = tauri::async_runtime::block_on(async move { app.shell().command(\"which\").args([\"ls\"]).status().await.unwrap() });\n            println!(\"`which` finished with status: {:?}\", status.code());\n            Ok(())\n        })\n}",
          "context": "general",
          "file_path": null,
          "description": "open(\"https://github",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "use tauri_plugin_shell::ShellExt;\n\nfn main() {\n    tauri::Builder::default()\n        .plugin(tauri_plugin_shell::init())\n        .setup(|app| {\n            let output = tauri::async_runtime::block_on(async move { app.shell().command(\"echo\").args([\"TAURI\"]).output().await.unwrap() });\n            assert!(output.status.success());\n            assert_eq!(String::from_utf8(output.stdout).unwrap(), \"TAURI\");\n            Ok(())\n        })\n}",
          "context": "general",
          "file_path": null,
          "description": "unwrap() });\n            println!(\"`which` finished with status: {:?}\", status",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "use tauri_plugin_shell::{ShellExt, process::CommandEvent};\n\nfn main() {\n    tauri::Builder::default()\n        .plugin(tauri_plugin_shell::init())\n        .setup(|app| {\n            let handle = app.handle().clone();\n            tauri::async_runtime::spawn(async move {\n                let (mut rx, mut child) = handle.shell().command(\"cargo\")\n                    .args([\"tauri\", \"dev\"])\n                    .spawn()\n                    .expect(\"Failed to spawn cargo\");\n\n                let mut i = 0;\n                while let Some(event) = rx.recv().await {\n                    if let CommandEvent::Stdout(line) = event {\n                        println!(\"got: {}\", String::from_utf8(line).unwrap());\n                       i += 1;\n                       if i == 4 {\n                           child.write(\"message from Rust\\n\".as_bytes()).unwrap();\n                           i = 0;\n                       }\n                   }\n                }\n            });\n            Ok(())\n        })\n}",
          "context": "general",
          "file_path": null,
          "description": "stdout)",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "let tray = tauri::tray::TrayIconBuilder::with_id(\"my-tray\").build(app)?;",
          "context": "rust_backend",
          "file_path": null,
          "description": "The new APIs can be found in the Rust `tray` module",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "use tauri::{\n    menu::{MenuBuilder, MenuItemBuilder},\n    tray::{MouseButton, MouseButtonState, TrayIconBuilder, TrayIconEvent},\n};\n\ntauri::Builder::default()\n    .setup(|app| {\n        let toggle = MenuItemBuilder::with_id(\"toggle\", \"Toggle\").build(app)?;\n        let menu = MenuBuilder::new(app).items(&[&toggle]).build()?;\n        let tray = TrayIconBuilder::new()\n            .menu(&menu)\n            .on_menu_event(move |app, event| match event.id().as_ref() {\n                \"toggle\" => {\n                    println!(\"toggle clicked\");\n                }\n                _ => (),\n            })\n            .on_tray_icon_event(|tray, event| {\n                if let TrayIconEvent::Click {\n                        button: MouseButton::Left,\n                        button_state: MouseButtonState::Up,\n                        ..\n                } = event\n                {\n                    let app = tray.app_handle();\n                    if let Some(webview_window) = app.get_webview_window(\"main\") {\n                       let _ = webview_window.unminimize();\n                       let _ = webview_window.show();\n                       let _ = webview_window.set_focus();\n                    }\n                }\n            })\n            .build(app)?;\n\n        Ok(())\n    })",
          "context": "general",
          "file_path": null,
          "description": "#### Migrate to Menu\n\nUse `tauri::menu::Menu` instead of `tauri::SystemTrayMenu`, `tauri::menu::Submenu` instead of `tauri::SystemTraySubmenu` and `tauri::menu::PredefinedMenuItem` instead of `tauri::SystemTrayMenuItem`",
          "dependencies": null
        },
        {
          "language": "toml",
          "code": "[dependencies]\ntauri-plugin-updater = \"2\"",
          "context": "plugin",
          "file_path": null,
          "description": "To set a custom updater target with the `@tauri-apps/plugin-updater`:\n\n1",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "fn main() {\n    tauri::Builder::default()\n        .plugin(tauri_plugin_updater::Builder::new().build())\n}",
          "context": "plugin",
          "file_path": null,
          "description": "Add to cargo dependencies:\n\n```toml\n[dependencies]\ntauri-plugin-updater = \"2\"\n```\n\n2",
          "dependencies": null
        },
        {
          "language": "json",
          "code": "// package.json\n{\n  \"dependencies\": {\n    \"@tauri-apps/plugin-updater\": \"^2.0.0\"\n  }\n}",
          "context": "plugin",
          "file_path": null,
          "description": "plugin(tauri_plugin_updater::Builder::new()",
          "dependencies": null
        },
        {
          "language": "javascript",
          "code": "import { check } from '@tauri-apps/plugin-updater';\nimport { relaunch } from '@tauri-apps/plugin-process';\n\nconst update = await check();\nif (update?.available) {\n  console.log(`Update to ${update.version} available! Date: ${update.date}`);\n  console.log(`Release notes: ${update.body}`);\n  await update.downloadAndInstall();\n  // requires the `process` plugin\n  await relaunch();\n}",
          "context": "plugin",
          "file_path": null,
          "description": "0",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "use tauri_plugin_updater::UpdaterExt;\n\nfn main() {\n    tauri::Builder::default()\n        .plugin(tauri_plugin_updater::Builder::new().build())\n        .setup(|app| {\n            let handle = app.handle();\n            tauri::async_runtime::spawn(async move {\n                let response = handle.updater().check().await;\n            });\n            Ok(())\n        })\n}",
          "context": "plugin",
          "file_path": null,
          "description": "body}`);\n  await update",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "fn main() {\n    let mut updater = tauri_plugin_updater::Builder::new();\n    #[cfg(target_os = \"macos\")]\n    {\n        updater = updater.target(\"darwin-universal\");\n    }\n    tauri::Builder::default()\n        .plugin(updater.build())\n}",
          "context": "general",
          "file_path": null,
          "description": "check()",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "use tauri::{path::BaseDirectory, Manager};\n\ntauri::Builder::default()\n    .setup(|app| {\n        let home_dir_path = app.path().home_dir().expect(\"failed to get home dir\");\n\n        let path = app.path().resolve(\"path/to/something\", BaseDirectory::Config)?;\n\n        Ok(())\n  })",
          "context": "rust_backend",
          "file_path": null,
          "description": "plugin(updater",
          "dependencies": null
        }
      ],
      "related_concepts": [
        "Migration",
        "Command Line Interface reference",
        "Migrate to Shell Plugin",
        "Migrate Path to Tauri Manager",
        "Migrate Permissions",
        "the security documentation",
        "updater guide",
        "Migrate to File System Plugin",
        "Embedding External Binaries",
        "Tauri 2.0 Configuration API reference"
      ],
      "difficulty": "advanced",
      "tags": [
        "desktop",
        "rust",
        "windows",
        "ios",
        "migrate",
        "from",
        "linux",
        "tauri",
        "mobile",
        "javascript",
        "android",
        "macos"
      ]
    },
    {
      "name": "Upgrade from Tauri 2.0 Beta",
      "category": "migration",
      "description": "import { Tabs, TabItem } from '@astrojs/starlight/components'; import CommandTabs from '@components/CommandTabs.astro';",
      "key_points": [
        "The `internal-ip` NPM package is no longer required, you can directly use the TAURI_DEV_HOST value instead"
      ],
      "code_examples": [
        {
          "language": "json",
          "code": "...\n\"permissions\": [\n    \"path:default\",\n    \"event:default\",\n    \"window:default\",\n    \"app:default\",\n    \"image:default\",\n    \"resources:default\",\n    \"menu:default\",\n    \"tray:default\",\n]\n...",
          "context": "permissions",
          "file_path": null,
          "description": "To migrate from the latest beta version you need to prepend all core permission identifiers in your capabilities with `core:` or switch to the `core:default` permission and remove old core plugin identifiers",
          "dependencies": null
        },
        {
          "language": "json",
          "code": "...\n\"permissions\": [\n    \"core:path:default\",\n    \"core:event:default\",\n    \"core:window:default\",\n    \"core:app:default\",\n    \"core:image:default\",\n    \"core:resources:default\",\n    \"core:menu:default\",\n    \"core:tray:default\",\n]\n...",
          "context": "window_management",
          "file_path": null,
          "description": "",
          "dependencies": null
        },
        {
          "language": "json",
          "code": "...\n\"permissions\": [\n    \"core:default\"\n]\n...",
          "context": "permissions",
          "file_path": null,
          "description": "```\n\nWe also added a new special `core:default` permission set which will contain all default permissions of all core plugins, so you can simplify the permissions boilerplate in your capabilities config",
          "dependencies": null
        },
        {
          "language": "js",
          "code": "import { defineConfig } from 'vite';\nimport { svelte } from '@sveltejs/vite-plugin-svelte';\nimport { internalIpV4Sync } from 'internal-ip';\n\nconst mobile = !!/android|ios/.exec(process.env.TAURI_ENV_PLATFORM);\n\nexport default defineConfig({\n  plugins: [svelte()],\n  clearScreen: false,\n  server: {\n    host: mobile ? '0.0.0.0' : false,\n    port: 1420,\n    strictPort: true,\n    hmr: mobile\n      ? {\n          protocol: 'ws',\n          host: internalIpV4Sync(),\n          port: 1421,\n        }\n      : undefined,\n  },\n});",
          "context": "general",
          "file_path": null,
          "description": "0",
          "dependencies": null
        },
        {
          "language": "js",
          "code": "import { defineConfig } from 'vite';\nimport Unocss from 'unocss/vite';\nimport { svelte } from '@sveltejs/vite-plugin-svelte';\n\nconst host = process.env.TAURI_DEV_HOST;\n\nexport default defineConfig({\n  plugins: [svelte()],\n  clearScreen: false,\n  server: {\n    host: host || false,\n    port: 1420,\n    strictPort: true,\n    hmr: host\n      ? {\n          protocol: 'ws',\n          host: host,\n          port: 1430,\n        }\n      : undefined,\n  },\n});",
          "context": "general",
          "file_path": null,
          "description": "0",
          "dependencies": null
        }
      ],
      "related_concepts": [
        "Command Line Interface reference"
      ],
      "difficulty": "intermediate",
      "tags": [
        "beta",
        "migrate",
        "from",
        "svelte",
        "ios",
        "mobile",
        "tauri",
        "android",
        "macos"
      ]
    },
    {
      "name": "Prerequisites",
      "category": "general",
      "description": "import { Tabs, TabItem, Card } from '@astrojs/starlight/components';",
      "key_points": [
        "[Linux](#linux) (see below for specific distributions)",
        "[macOS Catalina (10.15) and later](#macos)",
        "[Windows 7 and later](#windows)",
        "[Mac App Store](https://apps.apple.com/gb/app/xcode/id497799835?mt=12)",
        "[Apple Developer website](https://developer.apple.com/xcode/resources/).",
        "Instructions for Nix/NixOS can be found in the [NixOS Wiki](https://wiki",
        "** VBSCRIPT is currently enabled by default on most Windows installations, but is [being deprecated](https://techcommunity",
        "to restart your Terminal to ensure it recognizes the new installation"
      ],
      "code_examples": [
        {
          "language": "sh",
          "code": "sudo apt update\nsudo apt install libwebkit2gtk-4.1-dev \\\n  build-essential \\\n  curl \\\n  wget \\\n  file \\\n  libxdo-dev \\\n  libssl-dev \\\n  libayatana-appindicator3-dev \\\n  librsvg2-dev",
          "context": "general",
          "file_path": null,
          "description": "These may be different depending on your distribution but we've included some popular distributions below to help you get setup",
          "dependencies": null
        },
        {
          "language": "sh",
          "code": "sudo pacman -Syu\nsudo pacman -S --needed \\\n  webkit2gtk-4.1 \\\n  base-devel \\\n  curl \\\n  wget \\\n  file \\\n  openssl \\\n  appmenu-gtk-module \\\n  libappindicator-gtk3 \\\n  librsvg \\\n  xdotool",
          "context": "general",
          "file_path": null,
          "description": "<Tabs syncKey=\"distro\">\n  <TabItem label=\"Debian\">\n\n```sh\nsudo apt update\nsudo apt install libwebkit2gtk-4",
          "dependencies": null
        },
        {
          "language": "sh",
          "code": "sudo dnf check-update\nsudo dnf install webkit2gtk4.1-devel \\\n  openssl-devel \\\n  curl \\\n  wget \\\n  file \\\n  libappindicator-gtk3-devel \\\n  librsvg2-devel \\\n  libxdo-devel\nsudo dnf group install \"c-development\"",
          "context": "general",
          "file_path": null,
          "description": "1-dev \\\n  build-essential \\\n  curl \\\n  wget \\\n  file \\\n  libxdo-dev \\\n  libssl-dev \\\n  libayatana-appindicator3-dev \\\n  librsvg2-dev\n```\n\n  </TabItem>\n  <TabItem label=\"Arch\">\n\n```sh\nsudo pacman -Syu\nsudo pacman -S --needed \\\n  webkit2gtk-4",
          "dependencies": null
        },
        {
          "language": "sh",
          "code": "sudo emerge --ask \\\n  net-libs/webkit-gtk:4.1 \\\n  dev-libs/libappindicator \\\n  net-misc/curl \\\n  net-misc/wget \\\n  sys-apps/file",
          "context": "general",
          "file_path": null,
          "description": "1 \\\n  base-devel \\\n  curl \\\n  wget \\\n  file \\\n  openssl \\\n  appmenu-gtk-module \\\n  libappindicator-gtk3 \\\n  librsvg \\\n  xdotool\n```\n\n  </TabItem>\n  <TabItem label=\"Fedora\">\n\n```sh\nsudo dnf check-update\nsudo dnf install webkit2gtk4",
          "dependencies": null
        },
        {
          "language": "sh",
          "code": "sudo zypper up\nsudo zypper in webkit2gtk3-devel \\\n  libopenssl-devel \\\n  curl \\\n  wget \\\n  file \\\n  libappindicator3-1 \\\n  librsvg-devel\nsudo zypper in -t pattern devel_basis",
          "context": "general",
          "file_path": null,
          "description": "1-devel \\\n  openssl-devel \\\n  curl \\\n  wget \\\n  file \\\n  libappindicator-gtk3-devel \\\n  librsvg2-devel \\\n  libxdo-devel\nsudo dnf group install \"c-development\"\n```\n\n  </TabItem>\n  <TabItem label=\"Gentoo\">\n\n```sh\nsudo emerge --ask \\\n  net-libs/webkit-gtk:4",
          "dependencies": null
        },
        {
          "language": "sh",
          "code": "sudo apk add \\\n  build-base \\\n  webkit2gtk \\\n  curl \\\n  wget \\\n  file \\\n  openssl \\\n  libayatana-appindicator-dev \\\n  librsvg",
          "context": "general",
          "file_path": null,
          "description": "devel\nsudo dnf group install \"c-development\"\n```\n\n  </TabItem>\n  <TabItem label=\"Gentoo\">\n\n```sh\nsudo emerge --ask \\\n  net-libs/webkit-gtk:4",
          "dependencies": null
        },
        {
          "language": "sh",
          "code": "xcode-select --install",
          "context": "command",
          "file_path": null,
          "description": "Be sure to launch Xcode after installing so that it can finish setting up",
          "dependencies": null
        },
        {
          "language": "sh",
          "code": "curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh",
          "context": "command",
          "file_path": null,
          "description": "<Tabs syncKey=\"OS\">\n  <TabItem label=\"Linux and macOS\" class=\"content\">\n\nInstall via [`rustup`](https://github",
          "dependencies": null
        },
        {
          "language": "powershell",
          "code": "winget install --id Rustlang.Rustup",
          "context": "command",
          "file_path": null,
          "description": "org/tools/install to install `rustup`",
          "dependencies": null
        },
        {
          "language": "powershell",
          "code": "rustup default stable-msvc",
          "context": "command",
          "file_path": null,
          "description": "Depending on your system it should be either `x86_64-pc-windows-msvc`, `i686-pc-windows-msvc`, or `aarch64-pc-windows-msvc`",
          "dependencies": null
        },
        {
          "language": "sh",
          "code": "node -v\n# v20.10.0\nnpm -v\n# 10.2.3",
          "context": "frontend_integration",
          "file_path": null,
          "description": "2",
          "dependencies": null
        },
        {
          "language": "sh",
          "code": "export JAVA_HOME=/opt/android-studio/jbr",
          "context": "general",
          "file_path": null,
          "description": "com/studio)\n2",
          "dependencies": null
        },
        {
          "language": "sh",
          "code": "export JAVA_HOME=\"/Applications/Android Studio.app/Contents/jbr/Contents/Home\"",
          "context": "general",
          "file_path": null,
          "description": "com/studio)\n2",
          "dependencies": null
        },
        {
          "language": "ps",
          "code": "[System.Environment]::SetEnvironmentVariable(\"JAVA_HOME\", \"C:\\Program Files\\Android\\Android Studio\\jbr\", \"User\")",
          "context": "window_management",
          "file_path": null,
          "description": "Set the `JAVA_HOME` environment variable:\n\n{/* TODO: Can this be done in the 4th step? */}\n\n<Tabs syncKey=\"prereqs\">\n<TabItem label=\"Linux\">\n\n```sh\nexport JAVA_HOME=/opt/android-studio/jbr\n```\n\n</TabItem>\n<TabItem label=\"macOS\">\n\n```sh\nexport JAVA_HOME=\"/Applications/Android Studio",
          "dependencies": null
        },
        {
          "language": "sh",
          "code": "export ANDROID_HOME=\"$HOME/Android/Sdk\"\nexport NDK_HOME=\"$ANDROID_HOME/ndk/$(ls -1 $ANDROID_HOME/ndk)\"",
          "context": "general",
          "file_path": null,
          "description": "Set `ANDROID_HOME` and `NDK_HOME` environment variables",
          "dependencies": null
        },
        {
          "language": "sh",
          "code": "export ANDROID_HOME=\"$HOME/Library/Android/sdk\"\nexport NDK_HOME=\"$ANDROID_HOME/ndk/$(ls -1 $ANDROID_HOME/ndk)\"",
          "context": "general",
          "file_path": null,
          "description": "Set `ANDROID_HOME` and `NDK_HOME` environment variables",
          "dependencies": null
        },
        {
          "language": "ps",
          "code": "[System.Environment]::SetEnvironmentVariable(\"ANDROID_HOME\", \"$env:LocalAppData\\Android\\Sdk\", \"User\")\n$VERSION = Get-ChildItem -Name \"$env:LocalAppData\\Android\\Sdk\\ndk\" | Select-Object -Last 1\n[System.Environment]::SetEnvironmentVariable(\"NDK_HOME\", \"$env:LocalAppData\\Android\\Sdk\\ndk\\$VERSION\", \"User\")",
          "context": "window_management",
          "file_path": null,
          "description": "Set `ANDROID_HOME` and `NDK_HOME` environment variables",
          "dependencies": null
        },
        {
          "language": "ps",
          "code": "[System.Environment]::GetEnvironmentVariables(\"User\").GetEnumerator() | % { Set-Item -Path \"Env:\\$($_.key)\" -Value $_.value }",
          "context": "general",
          "file_path": null,
          "description": "ironmentVariable(\"ANDROID_HOME\", \"$env:LocalAppData\\Android\\Sdk\", \"User\")\n$VERSION = Get-ChildItem -Name \"$env:LocalAppData\\Android\\Sdk\\ndk\" | Select-Object -Last 1\n[System",
          "dependencies": null
        },
        {
          "language": "sh",
          "code": "rustup target add aarch64-linux-android armv7-linux-androideabi i686-linux-android x86_64-linux-android",
          "context": "rust_backend",
          "file_path": null,
          "description": "value }\n```\n\n:::\n\n</TabItem>\n\n</Tabs>\n\n5",
          "dependencies": null
        },
        {
          "language": "sh",
          "code": "rustup target add aarch64-apple-ios x86_64-apple-ios aarch64-apple-ios-sim",
          "context": "command",
          "file_path": null,
          "description": ":::\n\n1",
          "dependencies": null
        },
        {
          "language": "sh",
          "code": "/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"",
          "context": "rust_backend",
          "file_path": null,
          "description": "Install [Homebrew](https://brew",
          "dependencies": null
        },
        {
          "language": "sh",
          "code": "brew install cocoapods",
          "context": "general",
          "file_path": null,
          "description": "Install [Cocoapods](https://cocoapods",
          "dependencies": null
        }
      ],
      "related_concepts": [
        "macOS system dependencies section",
        "macOS Catalina (10.15) and later",
        "Configure for Mobile Targets",
        "Windows 7 and later",
        "Android",
        "Rust",
        "Setup for iOS",
        "create your first Tauri project",
        "installing Rust",
        "Troubleshooting Guide",
        "Install WebView2",
        "Create a project",
        "iOS",
        "System Dependencies",
        "Check VBSCRIPT"
      ],
      "difficulty": "intermediate",
      "tags": [
        "prerequisites",
        "desktop",
        "windows",
        "rust",
        "linux",
        "ios",
        "mobile",
        "javascript",
        "android",
        "macos"
      ]
    },
    {
      "name": "Project Structure",
      "category": "general",
      "description": "A Tauri project is usually made of 2 parts, a Rust project and a JavaScript project (optional), and typically the setup looks something like this:",
      "key_points": [
        "`icons/` directory is the default output directory of the [`tauri icon`](/reference/cli/#icon) command, it's usually referenced in `tauri.conf.json > bundle > icon` and used for the app's icons",
        "`build.rs` contains `tauri_build::build()` which is used for tauri's build system",
        "[Add and Configure a Frontend Framework](/start/frontend/)",
        "[Tauri Command Line Interface (CLI) Reference](/reference/cli/)",
        "[Learn how to develop your Tauri app](/develop/)"
      ],
      "code_examples": [],
      "related_concepts": [
        "`tauri icon`",
        "Learn how to develop your Tauri app",
        "Tauri CLI",
        "capability files",
        "Frontend Configuration",
        "Tauri Command Line Interface (CLI) Reference",
        "cfg_attr(mobile, tauri::mobile_entry_point)",
        "Security",
        "Discover additional features to extend Tauri",
        "Tauri Config",
        "Add and Configure a Frontend Framework"
      ],
      "difficulty": "intermediate",
      "tags": [
        "desktop",
        "rust",
        "structure",
        "mobile",
        "javascript",
        "project"
      ]
    },
    {
      "name": "Embedding Additional Files",
      "category": "resources",
      "description": "You may need to include additional files in your application bundle that aren't part of your frontend (your `frontendDist`) directly or which are too big to be inlined into the binary. We call these files `resources`.",
      "key_points": [
        "`\"dir/file.txt\"`: copies the `file.txt` file into the target resource directory.",
        "`\"dir/\"`: copies all files **and directories** _recursively_ into the target resource directory. Use this if you also want to preserve the file system structure of your files and directories.",
        "`\"dir/*\"`: copies all files in the `dir` directory _non-recursively_ (sub-directories will be ignored) into the target resource directory.",
        "`\"dir/**`: throws an error because `**` only matches directories and therefore no files can be found.",
        "`\"dir/**/*\"`: copies all files in the `dir` directory _recursively_ (all files in `dir/` and all files in all sub-directories) into the target resource directory.",
        "`\"dir/**/**`: throws an error because `**` only matches directories and therefore no files can be found.",
        "In Tauri's [permission system](/reference/acl/capability/), absolute paths and paths containing parent components (`",
        "Here we use `fs:allow-resource-read-recursive` to allow for full recursive read access to the complete `$RESOURCE` folder, files, and subdirectories"
      ],
      "code_examples": [
        {
          "language": "json",
          "code": "{\n  \"bundle\": {\n    \"resources\": [\n      \"/absolute/path/to/textfile.txt\",\n      \"relative/path/to/jsonfile.json\",\n      \"resources/**/*\"\n    ]\n  }\n}",
          "context": "general",
          "file_path": "tauri.conf.json",
          "description": "conf",
          "dependencies": null
        },
        {
          "language": "json",
          "code": "{\n  \"bundle\": {\n    \"resources\": {\n      \"/absolute/path/to/textfile.txt\": \"resources/textfile.txt\",\n      \"relative/path/to/jsonfile.json\": \"resources/jsonfile.json\",\n      \"resources/**/*\": \"resources/\"\n    }\n  }\n}",
          "context": "general",
          "file_path": "tauri.conf.json",
          "description": "json\",\n      \"resources/**/*\"\n    ]\n  }\n}\n```\n\nAlternatively the `resources` config also accepts a map object if you want to change where the files will be copied to",
          "dependencies": null
        },
        {
          "language": "json",
          "code": "{\n  \"hello\": \"Guten Tag!\",\n  \"bye\": \"Auf Wiedersehen!\"\n}",
          "context": "rust_backend",
          "file_path": "de.json",
          "description": "- `\"dir/**/**`: throws an error because `**` only matches directories and therefore no files can be found",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "tauri::Builder::default()\n  .setup(|app| {\n    // The path specified must follow the same syntax as defined in\n    // `tauri.conf.json > bundle > resources`\n    let resource_path = app.path().resolve(\"lang/de.json\", BaseDirectory::Resource)?;\n\n    let file = std::fs::File::open(&resource_path).unwrap();\n    let lang_de: serde_json::Value = serde_json::from_reader(file).unwrap();\n\n    // This will print 'Guten Tag!' to the terminal\n    println!(\"{}\", lang_de.get(\"hello\").unwrap());\n\n    Ok(())\n  })",
          "context": "rust_backend",
          "file_path": null,
          "description": "For this we add `\"lang/*\"` to `resources` as shown above",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "#[tauri::command]\nfn hello(handle: tauri::AppHandle) -> String {\n    let resource_path = handle.path().resolve(\"lang/de.json\", BaseDirectory::Resource)?;\n\n    let file = std::fs::File::open(&resource_path).unwrap();\n    let lang_de: serde_json::Value = serde_json::from_reader(file).unwrap();\n\n    lang_de.get(\"hello\").unwrap()\n}",
          "context": "general",
          "file_path": null,
          "description": "get(\"hello\")",
          "dependencies": null
        },
        {
          "language": "json",
          "code": "{\n  \"$schema\": \"../gen/schemas/desktop-schema.json\",\n  \"identifier\": \"main-capability\",\n  \"description\": \"Capability for the main window\",\n  \"windows\": [\"main\"],\n  \"permissions\": [\n    \"core:default\",\n    \"fs:allow-read-text-file\",\n    \"fs:allow-resource-read-recursive\"\n  ]\n}",
          "context": "permissions",
          "file_path": "src-tauri/capabilities/default.json ins={8-9}",
          "description": "get(\"hello\")",
          "dependencies": null
        },
        {
          "language": "javascript",
          "code": "import { resolveResource } from '@tauri-apps/api/path';\nimport { readTextFile } from '@tauri-apps/plugin-fs';\n\nconst resourcePath = await resolveResource('lang/de.json');\nconst langDe = JSON.parse(await readTextFile(resourcePath));\nconsole.log(langDe.hello); // This will print 'Guten Tag!' to the devtools console",
          "context": "permissions",
          "file_path": null,
          "description": "For more information, read [Scope Permissions] for other options, or [Scopes] for more fine-grained control",
          "dependencies": null
        }
      ],
      "related_concepts": [
        "permission system"
      ],
      "difficulty": "intermediate",
      "tags": [
        "desktop",
        "resources",
        "windows",
        "rust",
        "javascript"
      ]
    },
    {
      "name": "Node.js as a sidecar",
      "category": "resources",
      "description": "import CommandTabs from '@components/CommandTabs.astro'; import { Tabs, TabItem, Steps } from '@astrojs/starlight/components'; import CTA from '@fragments/cta.mdx';",
      "key_points": [
        "Project name: `node-sidecar-lab`",
        "Choose which language to use for your frontend: `Typescript / Javascript`",
        "Choose your package manager: `pnpm`",
        "Choose your UI template: `Vanilla`",
        "Choose your UI flavor: `Typescript`",
        "Would you like to setup the project for mobile as well? `yes`",
        "that each has their own advantages, drawbacks and security concerns",
        "Please follow the [shell plugin guide](/plugin/shell/) first to set up and initialize the plugin correctly"
      ],
      "code_examples": [
        {
          "language": "js",
          "code": "const command = process.argv[2];\n\n    switch (command) {\n      case 'ping':\n        const message = process.argv[3];\n        console.log(`pong, ${message}`);\n        break;\n      default:\n        console.error(`unknown command ${command}`);\n        process.exit(1);\n    }",
          "context": "general",
          "file_path": "sidecar-app/index.js",
          "description": "js` file in our `sidecar-app` directory and write a basic Node",
          "dependencies": null
        },
        {
          "language": "js",
          "code": "import { execSync } from 'child_process';\n    import fs from 'fs';\n\n    const ext = process.platform === 'win32' ? '.exe' : '';\n\n    const rustInfo = execSync('rustc -vV');\n    const targetTriple = /host: (\\S+)/g.exec(rustInfo)[1];\n    if (!targetTriple) {\n      console.error('Failed to determine platform target triple');\n    }\n    fs.renameSync(\n      `app${ext}`,\n      `../src-tauri/binaries/app-${targetTriple}${ext}`\n    );",
          "context": "window_management",
          "file_path": null,
          "description": "To rename this file to the expected Tauri sidecar filename, we can use the following Node",
          "dependencies": null
        },
        {
          "language": "json",
          "code": "{\n      \"bundle\": {\n        \"externalBin\": [\"binaries/app\"]\n      }\n    }",
          "context": "general",
          "file_path": "src-tauri/tauri.conf.json",
          "description": "##### Configure the Sidecar in the Tauri Application\n\n    Now that we have our Node",
          "dependencies": null
        },
        {
          "language": "javascript",
          "code": "import { Command } from '@tauri-apps/plugin-shell';\n\n        const message = 'Tauri';\n\n        const command = Command.sidecar('binaries/app', ['ping', message]);\n        const output = await command.execute();\n        const response = output.stdout;",
          "context": "command",
          "file_path": null,
          "description": "<Tabs syncKey=\"lang\">\n\n      <TabItem label=\"JavaScript\">\n\n        Let's execute the `ping` command in the Node",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "#[tauri::command]\n        async fn ping(app: tauri::AppHandle, message: String) -> String {\n          let sidecar_command = app\n            .shell()\n            .sidecar(\"app\")\n            .unwrap()\n            .arg(\"ping\")\n            .arg(message);\n          let output = sidecar_command.output().unwrap();\n          let response = String::from_utf8(output.stdout).unwrap();\n          response\n        }",
          "context": "command",
          "file_path": null,
          "description": "stdout;\n        ```\n\n      </TabItem>\n\n      <TabItem label=\"Rust\">\n\n        Let's pipe a `ping` Tauri command to the Node",
          "dependencies": null
        }
      ],
      "related_concepts": [
        "shell plugin guide"
      ],
      "difficulty": "intermediate",
      "tags": [
        "nodejs",
        "desktop",
        "rust",
        "windows",
        "linux",
        "typescript",
        "mobile",
        "javascript",
        "sidecar",
        "macos"
      ]
    },
    {
      "name": "Embedding External Binaries",
      "category": "resources",
      "description": "You may need to embed external binaries to add additional functionality to your application or prevent users from installing additional dependencies (e.g., Node.js or Python). We call this binary a `sidecar`.",
      "key_points": [
        "The relative paths are relative to the `tauri",
        "Please follow the [shell plugin guide](/plugin/shell/) first to set up and initialize the plugin correctly",
        "The `sidecar()` function expects just the filename, NOT the whole path configured in the `externalBin` array",
        "The `shell:allow-execute` identifier is used because the sidecar's child process will be started using the `command",
        "The string provided to `Command",
        "If you are migrating from Tauri v1, the `migrate` command in Tauri v2 CLI should take care of this for you"
      ],
      "code_examples": [
        {
          "language": "json",
          "code": "{\n  \"bundle\": {\n    \"externalBin\": [\n      \"/absolute/path/to/sidecar\",\n      \"../relative/path/to/binary\",\n      \"binaries/my-sidecar\"\n    ]\n  }\n}",
          "context": "general",
          "file_path": "src-tauri/tauri.conf.json",
          "description": "The `externalBin` configuration expects a list of strings targeting binaries either with absolute or relative paths",
          "dependencies": null
        },
        {
          "language": "sh",
          "code": "rustc -Vv",
          "context": "command",
          "file_path": null,
          "description": "For instance, `\"externalBin\": [\"binaries/my-sidecar\"]` requires a `src-tauri/binaries/my-sidecar-x86_64-unknown-linux-gnu` executable on Linux or `src-tauri/binaries/my-sidecar-aarch64-apple-darwin` on Mac OS with Apple Silicon",
          "dependencies": null
        },
        {
          "language": "shell",
          "code": "rustc -Vv | grep host | cut -f2 -d' '",
          "context": "command",
          "file_path": null,
          "description": "idecar\"]` requires a `src-tauri/binaries/my-sidecar-x86_64-unknown-linux-gnu` executable on Linux or `src-tauri/binaries/my-sidecar-aarch64-apple-darwin` on Mac OS with Apple Silicon",
          "dependencies": null
        },
        {
          "language": "powershell",
          "code": "rustc -Vv | Select-String \"host:\" | ForEach-Object {$_.Line.split(\" \")[1]}",
          "context": "command",
          "file_path": null,
          "description": "x or `src-tauri/binaries/my-sidecar-aarch64-apple-darwin` on Mac OS with Apple Silicon",
          "dependencies": null
        },
        {
          "language": "javascript",
          "code": "import { execSync } from 'child_process';\nimport fs from 'fs';\n\nconst extension = process.platform === 'win32' ? '.exe' : '';\n\nconst rustInfo = execSync('rustc -vV');\nconst targetTriple = /host: (\\S+)/g.exec(rustInfo)[1];\nif (!targetTriple) {\n  console.error('Failed to determine platform target triple');\n}\nfs.renameSync(\n  `src-tauri/binaries/sidecar${extension}`,\n  `src-tauri/binaries/sidecar-${targetTriple}${extension}`\n);",
          "context": "rust_backend",
          "file_path": null,
          "description": "split(\" \")[1]}\n```\n\nHere's a Node",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "use tauri_plugin_shell::ShellExt;\nuse tauri_plugin_shell::process::CommandEvent;\n\nlet sidecar_command = app.shell().sidecar(\"my-sidecar\").unwrap();\nlet (mut rx, mut _child) = sidecar_command\n  .spawn()\n  .expect(\"Failed to spawn sidecar\");\n\ntauri::async_runtime::spawn(async move {\n  // read events such as stdout\n  while let Some(event) = rx.recv().await {\n    if let CommandEvent::Stdout(line_bytes) = event {\n      let line = String::from_utf8_lossy(&line_bytes);\n      window\n        .emit(\"message\", Some(format!(\"'{}'\", line)))\n        .expect(\"failed to emit event\");\n      // write to stdin\n      child.write(\"message from Rust\\n\".as_bytes()).unwrap();\n    }\n  }\n});",
          "context": "plugin",
          "file_path": null,
          "description": ":::\n\nOn the Rust side, import the `tauri_plugin_shell::ShellExt` trait and call the `shell()",
          "dependencies": null
        },
        {
          "language": "json",
          "code": "{\n  \"bundle\": {\n    \"externalBin\": [\"binaries/app\", \"my-sidecar\", \"../scripts/sidecar\"]\n  }\n}",
          "context": "general",
          "file_path": "src-tauri/tauri.conf.json",
          "description": "unwrap();\n    }\n  }\n});\n```\n\n:::note\nThe `sidecar()` function expects just the filename, NOT the whole path configured in the `externalBin` array",
          "dependencies": null
        },
        {
          "language": "json",
          "code": "{\n  \"permissions\": [\n    \"core:default\",\n    {\n      \"identifier\": \"shell:allow-execute\",\n      \"allow\": [\n        {\n          \"name\": \"binaries/app\",\n          \"sidecar\": true\n        }\n      ]\n    }\n  ]\n}",
          "context": "permissions",
          "file_path": "src-tauri/capabilities/default.json",
          "description": "Don't forget to name your sidecar according to the relative path mentioned earlier",
          "dependencies": null
        },
        {
          "language": "javascript",
          "code": "import { Command } from '@tauri-apps/plugin-shell';\nconst command = Command.sidecar('binaries/my-sidecar');\nconst output = await command.execute();",
          "context": "command",
          "file_path": null,
          "description": ":::\n\nIn the JavaScript code, import the `Command` class from the `@tauri-apps/plugin-shell` module and use the `sidecar` static method",
          "dependencies": null
        },
        {
          "language": "json",
          "code": "{\n  \"$schema\": \"../gen/schemas/desktop-schema.json\",\n  \"identifier\": \"default\",\n  \"description\": \"Capability for the main window\",\n  \"windows\": [\"main\"],\n  \"permissions\": [\n    \"core:default\",\n    {\n      \"identifier\": \"shell:allow-execute\",\n      \"allow\": [\n        {\n          \"args\": [\n            \"arg1\",\n            \"-a\",\n            \"--arg2\",\n            {\n              \"validator\": \"\\\\S+\"\n            }\n          ],\n          \"name\": \"binaries/my-sidecar\",\n          \"sidecar\": true\n        }\n      ]\n    }\n  ]\n}",
          "context": "command",
          "file_path": "src-tauri/capabilities/default.json",
          "description": "First, define the arguments that need to be passed to the sidecar command in `src-tauri/capabilities/default",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "use tauri_plugin_shell::ShellExt;\n#[tauri::command]\nasync fn call_my_sidecar(app: tauri::AppHandle) {\n  let sidecar_command = app\n    .shell()\n    .sidecar(\"my-sidecar\")\n    .unwrap()\n    .args([\"arg1\", \"-a\", \"--arg2\", \"any-string-that-matches-the-validator\"]);\n  let (mut _rx, mut _child) = sidecar_command.spawn().unwrap();\n}",
          "context": "command",
          "file_path": null,
          "description": ":::\n\nThen, to call the sidecar command, simply pass in **all** the arguments as an array",
          "dependencies": null
        },
        {
          "language": "javascript",
          "code": "import { Command } from '@tauri-apps/plugin-shell';\n// notice that the args array matches EXACTLY what is specified in `capabilities/default.json`.\nconst command = Command.sidecar('binaries/my-sidecar', [\n  'arg1',\n  '-a',\n  '--arg2',\n  'any-string-that-matches-the-validator',\n]);\nconst output = await command.execute();",
          "context": "command",
          "file_path": null,
          "description": "spawn()",
          "dependencies": null
        }
      ],
      "related_concepts": [
        "Automated Migration",
        "shell plugin guide"
      ],
      "difficulty": "intermediate",
      "tags": [
        "desktop",
        "windows",
        "rust",
        "linux",
        "javascript",
        "sidecar"
      ]
    },
    {
      "name": "Splashscreen",
      "category": "general",
      "description": "import { Image } from 'astro:assets'; import step_1 from '@assets/learn/splashscreen/step_1.png'; import step_3 from '@assets/learn/splashscreen/step_3.png'; import { Steps, Tabs, TabItem } from '@astrojs/starlight/components';",
      "key_points": [
        "Project name: `splashscreen-lab`",
        "Choose which language to use for your frontend: `Typescript / Javascript`",
        "Choose your package manager: `pnpm`",
        "Choose your UI template: `Vanilla`",
        "Choose your UI flavor: `Typescript`",
        "to build and run the initial template, just to validate your setup is working as intended",
        "here is that you can navigate to a `/splashscreen` URL and be shown the contents you want for your splashscreen"
      ],
      "code_examples": [
        {
          "language": "json",
          "code": "// src-tauri/tauri.conf.json\n    {\n        \"windows\": [\n            {\n                \"label\": \"main\",\n                \"visible\": false\n            },\n            {\n                \"label\": \"splashscreen\",\n                \"url\": \"/splashscreen\"\n            }\n        ]\n    }",
          "context": "window_management",
          "file_path": null,
          "description": "You can leave all other options as their defaults, or tweak them based on preference",
          "dependencies": null
        },
        {
          "language": "html",
          "code": "// /splashscreen.html\n    <!doctype html>\n    <html lang=\"en\">\n    <head>\n        <meta charset=\"UTF-8\" />\n        <link rel=\"stylesheet\" href=\"/src/styles.css\" />\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n        <title>Tauri App</title>\n    </head>\n    <body>\n        <div class=\"container\">\n            <h1>Tauri used Splash!</h1>\n            <div class=\"row\">\n                <h5>It was super effective!</h5>\n            </div>\n        </div>\n    </body>\n    </html>",
          "context": "general",
          "file_path": null,
          "description": "What's important here is that you can navigate to a `/splashscreen` URL and be shown the contents you want for your splashscreen",
          "dependencies": null
        },
        {
          "language": "javascript",
          "code": "// src/main.ts\n    // These contents can be copy-pasted below the existing code, don't replace the entire file!!\n\n    // Utility function to implement a sleep function in TypeScript\n    function sleep(seconds: number): Promise<void> {\n        return new Promise(resolve => setTimeout(resolve, seconds * 1000));\n    }\n\n    // Setup function\n    async function setup() {\n        // Fake perform some really heavy setup task\n        console.log('Performing really heavy frontend setup task...')\n        await sleep(3);\n        console.log('Frontend setup task complete!')\n        // Set the frontend task as being completed\n        invoke('set_complete', {task: 'frontend'})\n    }\n\n    // Effectively a JavaScript main function\n    window.addEventListener(\"DOMContentLoaded\", () => {\n        setup()\n    });",
          "context": "general",
          "file_path": null,
          "description": "",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "// /src-tauri/src/lib.rs\n    // Import functionalities we'll be using\n    use std::sync::Mutex;\n    use tauri::async_runtime::spawn;\n    use tauri::{AppHandle, Manager, State};\n    use tokio::time::{sleep, Duration};\n\n    // Create a struct we'll use to track the completion of\n    // setup related tasks\n    struct SetupState {\n        frontend_task: bool,\n        backend_task: bool,\n    }\n\n    // Our main entrypoint in a version 2 mobile compatible app\n    #[cfg_attr(mobile, tauri::mobile_entry_point)]\n    pub fn run() {\n        // Don't write code before Tauri starts, write it in the\n        // setup hook instead!\n        tauri::Builder::default()\n            // Register a `State` to be managed by Tauri\n            // We need write access to it so we wrap it in a `Mutex`\n            .manage(Mutex::new(SetupState {\n                frontend_task: false,\n                backend_task: false,\n            }))\n            // Add a command we can use to check\n            .invoke_handler(tauri::generate_handler![greet, set_complete])\n            // Use the setup hook to execute setup related tasks\n            // Runs before the main loop, so no windows are yet created\n            .setup(|app| {\n                // Spawn setup as a non-blocking task so the windows can be\n                // created and ran while it executes\n                spawn(setup(app.handle().clone()));\n                // The hook expects an Ok result\n                Ok(())\n            })\n            // Run the app\n            .run(tauri::generate_context!())\n            .expect(\"error while running tauri application\");\n    }\n\n    #[tauri::command]\n    fn greet(name: String) -> String {\n        format!(\"Hello {name} from Rust!\")\n    }\n\n    // A custom task for setting the state of a setup task\n    #[tauri::command]\n    async fn set_complete(\n        app: AppHandle,\n        state: State<'_, Mutex<SetupState>>,\n        task: String,\n    ) -> Result<(), ()> {\n        // Lock the state without write access\n        let mut state_lock = state.lock().unwrap();\n        match task.as_str() {\n            \"frontend\" => state_lock.frontend_task = true,\n            \"backend\" => state_lock.backend_task = true,\n            _ => panic!(\"invalid task completed!\"),\n        }\n        // Check if both tasks are completed\n        if state_lock.backend_task && state_lock.frontend_task {\n            // Setup is complete, we can close the splashscreen\n            // and unhide the main window!\n            let splash_window = app.get_webview_window(\"splashscreen\").unwrap();\n            let main_window = app.get_webview_window(\"main\").unwrap();\n            splash_window.close().unwrap();\n            main_window.show().unwrap();\n        }\n        Ok(())\n    }\n\n    // An async function that does some heavy setup task\n    async fn setup(app: AppHandle) -> Result<(), ()> {\n        // Fake performing some heavy action for 3 seconds\n        println!(\"Performing really heavy backend setup task...\");\n        sleep(Duration::from_secs(3)).await;\n        println!(\"Backend setup task completed!\");\n        // Set the backend task as being completed\n        // Commands can be ran as regular functions as long as you take\n        // care of the input arguments yourself\n        set_complete(\n            app.clone(),\n            app.state::<Mutex<SetupState>>(),\n            \"backend\".to_string(),\n        )\n        .await?;\n        Ok(())\n    }",
          "context": "window_management",
          "file_path": null,
          "description": "log('Frontend setup task complete!')\n        // Set the frontend task as being completed\n        invoke('set_complete', {task: 'frontend'})\n    }\n\n    // Effectively a JavaScript main function\n    window",
          "dependencies": null
        }
      ],
      "related_concepts": [],
      "difficulty": "advanced",
      "tags": [
        "splashscreen",
        "windows",
        "rust",
        "typescript",
        "mobile",
        "javascript"
      ]
    },
    {
      "name": "State Management",
      "category": "state_management",
      "description": "In a Tauri application, you often need to keep track of the current state of your application or manage the lifecycle of things associated with it. Tauri provides an easy way to manage the state of your application using the [`Manager`] API, and read it when commands are called.",
      "key_points": [
        "that the return type must be [`Result`] if you use asynchronous commands"
      ],
      "code_examples": [
        {
          "language": "rust",
          "code": "use tauri::{Builder, Manager};\n\nstruct AppData {\n  welcome_message: &'static str,\n}\n\nfn main() {\n  Builder::default()\n    .setup(|app| {\n      app.manage(AppData {\n        welcome_message: \"Welcome to Tauri!\",\n      });\n      Ok(())\n    })\n    .run(tauri::generate_context!())\n    .unwrap();\n}",
          "context": "command",
          "file_path": null,
          "description": "Tauri provides an easy way to manage the state of your application using the [`Manager`] API, and read it when commands are called",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "let data = app.state::<AppData>();",
          "context": "state_management",
          "file_path": null,
          "description": "run(tauri::generate_context!())",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "use std::sync::Mutex;\n\nuse tauri::{Builder, Manager};\n\n#[derive(Default)]\nstruct AppState {\n  counter: u32,\n}\n\nfn main() {\n  Builder::default()\n    .setup(|app| {\n      app.manage(Mutex::new(AppState::default()));\n      Ok(())\n    })\n    .run(tauri::generate_context!())\n    .unwrap();\n}",
          "context": "state_management",
          "file_path": null,
          "description": "This allows you to lock the value when you need to modify it, and unlock it when you are done",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "let state = app.state::<Mutex<AppState>>();\n\n// Lock the mutex to get mutable access:\nlet mut state = state.lock().unwrap();\n\n// Modify the state:\nstate.counter += 1;",
          "context": "state_management",
          "file_path": null,
          "description": "run(tauri::generate_context!())",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "#[tauri::command]\nfn increase_counter(state: State<'_, Mutex<AppState>>) -> u32 {\n  let mut state = state.lock().unwrap();\n  state.counter += 1;\n  state.counter\n}",
          "context": "command",
          "file_path": null,
          "description": "`AppHandle`s are deliberately cheap to clone for use-cases like this",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "#[tauri::command]\nasync fn increase_counter(state: State<'_, Mutex<AppState>>) -> Result<u32, ()> {\n  let mut state = state.lock().await;\n  state.counter += 1;\n  Ok(state.counter)\n}",
          "context": "command",
          "file_path": null,
          "description": "Mutex",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "use std::sync::Mutex;\nuse tauri::{Builder, Window, WindowEvent, Manager};\n\n#[derive(Default)]\nstruct AppState {\n  counter: u32,\n}\n\n// In an event handler:\nfn on_window_event(window: &Window, _event: &WindowEvent) {\n    // Get a handle to the app so we can get the global state.\n    let app_handle = window.app_handle();\n    let state = app_handle.state::<Mutex<AppState>>();\n\n    // Lock the mutex to mutably access the state.\n    let mut state = state.lock().unwrap();\n    state.counter += 1;\n}\n\nfn main() {\n  Builder::default()\n    .setup(|app| {\n      app.manage(Mutex::new(AppState::default()));\n      Ok(())\n    })\n    .on_window_event(on_window_event)\n    .run(tauri::generate_context!())\n    .unwrap();\n}",
          "context": "state_management",
          "file_path": null,
          "description": "### Access state with the [`Manager`] trait\n\nSometimes you may need to access the state outside of commands, such as in a different thread or in an event handler like `on_window_event`",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "use std::sync::Mutex;\n\n#[derive(Default)]\nstruct AppStateInner {\n  counter: u32,\n}\n\ntype AppState = Mutex<AppStateInner>;",
          "context": "state_management",
          "file_path": null,
          "description": "For example, if you use `State<'_, AppState>` instead of `State<'_, Mutex<AppState>>`, there won't be any state managed with that type",
          "dependencies": null
        }
      ],
      "related_concepts": [
        "Calling Rust from the Frontend",
        "Access state with the Manager trait",
        "Accessing State"
      ],
      "difficulty": "advanced",
      "tags": [
        "state",
        "management",
        "rust"
      ]
    },
    {
      "name": "System Tray",
      "category": "ui_customization",
      "description": "import { Icon } from '@astrojs/starlight/components'; import { Tabs, TabItem } from '@astrojs/starlight/components';",
      "key_points": [
        "By default the menu is displayed on both left and right clicks"
      ],
      "code_examples": [
        {
          "language": "toml",
          "code": "tauri = { version = \"2.0.0\", features = [ \"tray-icon\" ] }",
          "context": "general",
          "file_path": "src-tauri/Cargo.toml",
          "description": "toml` to include the necessary feature for the system tray",
          "dependencies": null
        },
        {
          "language": "javascript",
          "code": "import { TrayIcon } from '@tauri-apps/api/tray';\n\nconst options = {\n  // here you can add a tray menu, title, tooltip, event handler, etc\n};\n\nconst tray = await TrayIcon.new(options);",
          "context": "frontend_integration",
          "file_path": null,
          "description": "### Create a Tray Icon\n\n<Tabs synckey=\"language\">\n<TabItem label=\"JavaScript\">\nUse the [`TrayIcon",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "use tauri::tray::TrayIconBuilder;\n\ntauri::Builder::default()\n    .setup(|app| {\n        let tray = TrayIconBuilder::new().build(app)?;\n        Ok(())\n    })",
          "context": "rust_backend",
          "file_path": null,
          "description": "new(options);\n```\n\nSee [`TrayIconOptions`] for more information on the customization options",
          "dependencies": null
        },
        {
          "language": "javascript",
          "code": "import { TrayIcon } from '@tauri-apps/api/tray';\nimport { defaultWindowIcon } from '@tauri-apps/api/app';\n\nconst options = {\n  icon: await defaultWindowIcon(),\n};\n\nconst tray = await TrayIcon.new(options);",
          "context": "frontend_integration",
          "file_path": null,
          "description": "build(app)?;\n        Ok(())\n    })\n\n```\n\nSee [`TrayIconBuilder`] for more information on customization options",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "let tray = TrayIconBuilder::new()\n  .icon(app.default_window_icon().unwrap().clone())\n  .build(app)?;",
          "context": "window_management",
          "file_path": null,
          "description": "</TabItem>\n</Tabs>\n\n### Change the Tray Icon\n\nWhen creating the tray you can use the application icon as the tray icon:\n\n<Tabs syncKey=\"lang\">\n<TabItem label=\"JavaScript\">\n\n```javascript\nimport { TrayIcon } from '@tauri-apps/api/tray';\nimport { defaultWindowIcon } from '@tauri-apps/api/app';\n\nconst options = {\n  icon: await defaultWindowIcon(),\n};\n\nconst tray = await TrayIcon",
          "dependencies": null
        },
        {
          "language": "javascript",
          "code": "import { TrayIcon } from '@tauri-apps/api/tray';\nimport { Menu } from '@tauri-apps/api/menu';\n\nconst menu = await Menu.new({\n  items: [\n    {\n      id: 'quit',\n      text: 'Quit',\n    },\n  ],\n});\n\nconst options = {\n  menu,\n  menuOnLeftClick: true,\n};\n\nconst tray = await TrayIcon.new(options);",
          "context": "plugin",
          "file_path": null,
          "description": "To prevent the menu from popping up on left click, call the [`menu_on_left_click(false)`][TrayIconBuilder::menu_on_left_click] Rust function\nor set the [`menuOnLeftClick`] JavaScript option to `false`",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "use tauri::{\n  menu::{Menu, MenuItem},\n  tray::TrayIconBuilder,\n};\n\nlet quit_i = MenuItem::with_id(app, \"quit\", \"Quit\", true, None::<&str>)?;\nlet menu = Menu::with_items(app, &[&quit_i])?;\n\nlet tray = TrayIconBuilder::new()\n  .menu(&menu)\n  .menu_on_left_click(true)\n  .build(app)?;",
          "context": "rust_backend",
          "file_path": null,
          "description": "new({\n  items: [\n    {\n      id: 'quit',\n      text: 'Quit',\n    },\n  ],\n});\n\nconst options = {\n  menu,\n  menuOnLeftClick: true,\n};\n\nconst tray = await TrayIcon",
          "dependencies": null
        },
        {
          "language": "javascript",
          "code": "import { Menu } from '@tauri-apps/api/menu';\n\n  function onTrayMenuClick(itemId) {\n    // itemId === 'quit'\n  }\n\n  const menu = await Menu.new({\n    items: [\n      {\n        id: 'quit',\n        text: 'Quit',\n        action: onTrayMenuClick,\n      },\n    ],\n  });",
          "context": "frontend_integration",
          "file_path": null,
          "description": "menu_on_left_click(true)",
          "dependencies": null
        },
        {
          "language": "javascript",
          "code": "import { Menu } from '@tauri-apps/api/menu';\n\n  const menu = await Menu.new({\n    items: [\n      {\n        id: 'quit',\n        text: 'Quit',\n        action: () => {\n          console.log('quit pressed');\n        },\n      },\n    ],\n  });",
          "context": "general",
          "file_path": null,
          "description": "bs syncKey=\"lang\">\n<TabItem label=\"JavaScript\">\nOn JavaScript you can attach a menu click event listener directly to the menu item:\n\n- Using a shared menu click handler\n\n  ```javascript\n  import { Menu } from '@tauri-apps/api/menu';\n\n  function onTrayMenuClick(itemId) {\n    // itemId === 'quit'\n  }\n\n  const menu = await Menu",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "use tauri::tray::TrayIconBuilder;\n\nTrayIconBuilder::new()\n  .on_menu_event(|app, event| match event.id.as_ref() {\n    \"quit\" => {\n      println!(\"quit menu item was clicked\");\n      app.exit(0);\n    }\n    _ => {\n      println!(\"menu item {:?} not handled\", event.id);\n    }\n  })",
          "context": "rust_backend",
          "file_path": null,
          "description": "new({\n    items: [\n      {\n        id: 'quit',\n        text: 'Quit',\n        action: () => {\n          console",
          "dependencies": null
        },
        {
          "language": "javascript",
          "code": "import { TrayIcon } from '@tauri-apps/api/tray';\n\nconst options = {\n  action: (event) => {\n    switch (event.type) {\n      case 'Click':\n        console.log(\n          `mouse ${event.button} button pressed, state: ${event.buttonState}`\n        );\n        break;\n      case 'DoubleClick':\n        console.log(`mouse ${event.button} button pressed`);\n        break;\n      case 'Enter':\n        console.log(\n          `mouse hovered tray at ${event.rect.position.x}, ${event.rect.position.y}`\n        );\n        break;\n      case 'Move':\n        console.log(\n          `mouse moved on tray at ${event.rect.position.x}, ${event.rect.position.y}`\n        );\n        break;\n      case 'Leave':\n        console.log(\n          `mouse left tray at ${event.rect.position.x}, ${event.rect.position.y}`\n        );\n        break;\n    }\n  },\n};\n\nconst tray = await TrayIcon.new(options);",
          "context": "frontend_integration",
          "file_path": null,
          "description": "s for the following mouse events:\n\n- click: triggered when the cursor receives a single left, right or middle click, including information on whether the mouse press was released or not\n- Double click: triggered when the cursor receives a double left, right or middle click\n- Enter: triggered when the cursor enters the tray icon area\n- Move: triggered when the cursor moves around the tray icon area\n- Leave: triggered when the cursor leaves the tray icon area\n\n<Tabs>\n<TabItem label=\"JavaScript\">",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "use tauri::{\n    Manager,\n    tray::{MouseButton, MouseButtonState, TrayIconBuilder, TrayIconEvent}\n};\n\nTrayIconBuilder::new()\n  .on_tray_icon_event(|tray, event| match event {\n    TrayIconEvent::Click {\n      button: MouseButton::Left,\n      button_state: MouseButtonState::Up,\n      ..\n    } => {\n      println!(\"left click pressed and released\");\n      // in this example, let's show and focus the main window when the tray is clicked\n      let app = tray.app_handle();\n      if let Some(window) = app.get_webview_window(\"main\") {\n        let _ = window.unminimize();\n        let _ = window.show();\n        let _ = window.set_focus();\n      }\n    }\n    _ => {\n      println!(\"unhandled event {event:?}\");\n    }\n  })",
          "context": "rust_backend",
          "file_path": null,
          "description": "new(options);\n```\n\nSee [`TrayIconEvent`][js TrayIconEvent] for more information on the event payload",
          "dependencies": null
        }
      ],
      "related_concepts": [
        "Window Menu"
      ],
      "difficulty": "intermediate",
      "tags": [
        "system",
        "javascript",
        "tray",
        "rust"
      ]
    },
    {
      "name": "Updating Dependencies",
      "category": "communication",
      "description": "{/* TODO: Add plugin update example */}",
      "key_points": [],
      "code_examples": [
        {
          "language": "toml",
          "code": "[build-dependencies]\ntauri-build = \"%version%\"\n\n[dependencies]\ntauri = { version = \"%version%\" }",
          "context": "general",
          "file_path": null,
          "description": "Go to `src-tauri/Cargo",
          "dependencies": null
        },
        {
          "language": "shell",
          "code": "cd src-tauri\ncargo update",
          "context": "general",
          "file_path": null,
          "description": "toml` and change `tauri` and `tauri-build` to\n\n```toml\n[build-dependencies]\ntauri-build = \"%version%\"\n\n[dependencies]\ntauri = { version = \"%version%\" }\n```\n\nwhere `%version%` is the corresponding version number from above",
          "dependencies": null
        }
      ],
      "related_concepts": [],
      "difficulty": "beginner",
      "tags": [
        "dependencies",
        "javascript",
        "updating",
        "rust"
      ]
    },
    {
      "name": "Using Plugin Permissions",
      "category": "security",
      "description": "import { Steps } from '@astrojs/starlight/components'; import ShowSolution from '@components/ShowSolution.astro' import Cta from '@fragments/cta.mdx';",
      "key_points": [],
      "code_examples": [
        {
          "language": "sh",
          "code": "cargo add tauri-plugin-fs",
          "context": "plugin",
          "file_path": null,
          "description": "io](https://crates",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "#[cfg_attr(mobile, tauri::mobile_entry_point)]\n    fn run() {\n      tauri::Builder::default()\n        .plugin(tauri_plugin_fs::init())\n        .run(tauri::generate_context!())\n        .expect(\"error while running tauri application\");\n    }",
          "context": "plugin",
          "file_path": "src-tauri/src/lib.rs",
          "description": "io/crates/tauri-plugin-fs)\n    you need to manually add it as a dependency and modify the Tauri builder\n    to initialize the plugin:\n\n    ```sh\n    cargo add tauri-plugin-fs\n    ```\n\n    Modify `lib",
          "dependencies": null
        },
        {
          "language": "ts",
          "code": "import { writeTextFile, BaseDirectory } from '@tauri-apps/plugin-fs';\n\n        let greetInputEl: HTMLInputElement | null;\n\n        async function write(message: string) {\n            await writeTextFile('test.txt', message, { baseDir: BaseDirectory.Home });\n        }\n\n        window.addEventListener(\"DOMContentLoaded\", () => {\n          greetInputEl = document.querySelector(\"#greet-input\");\n          document.querySelector(\"#greet-form\")?.addEventListener(\"submit\", (e) => {\n            e.preventDefault();\n            if (!greetInputEl )\n              return;\n\n            write(greetInputEl.value == \"\" ? \"No input provided\": greetInputEl.value);\n\n          });\n        });",
          "context": "general",
          "file_path": "src/main.ts",
          "description": "### Test Permissions in Practice\n\n        After we have added the necessary permission we want to\n        confirm that our application can access the file and write\n        it's content",
          "dependencies": null
        },
        {
          "language": "sh",
          "code": "[Error] Unhandled Promise Rejection: fs.write_text_file not allowed. Permissions associated with this command: fs:allow-app-write, fs:allow-app-write-recursive, fs:allow-appcache-write, fs:allow-appcache-write-recursive, fs:allow-appconf...\n        (anonymous function) (main.ts:5)",
          "context": "permissions",
          "file_path": null,
          "description": "txt\n        ```\n\n        You should be presented with your input and finished learning about using permissions from plugins in Tauri applications",
          "dependencies": null
        }
      ],
      "related_concepts": [
        "previous instructions",
        "documentation",
        "Plugins",
        "instructions",
        "fs default"
      ],
      "difficulty": "advanced",
      "tags": [
        "permissions",
        "plugin",
        "desktop",
        "rust",
        "windows",
        "using",
        "typescript",
        "mobile",
        "javascript"
      ]
    },
    {
      "name": "Vite",
      "category": "general",
      "description": "import { Tabs, TabItem, Steps } from '@astrojs/starlight/components';",
      "key_points": [
        "Use `../dist` as `frontendDist` in `src-tauri/tauri.conf.json`.",
        "Use `process.env.TAURI_DEV_HOST` as the development server host IP when set to run on iOS physical devices."
      ],
      "code_examples": [
        {
          "language": "json",
          "code": "{\n      \"scripts\": {\n        \"dev\": \"vite\",\n        \"build\": \"tsc && vite build\",\n        \"preview\": \"vite preview\",\n        \"tauri\": \"tauri\"\n      }\n    }",
          "context": "general",
          "file_path": null,
          "description": "##### Update Tauri configuration\n\n    Assuming you have the following `dev` and `build` scripts in your `package",
          "dependencies": null
        },
        {
          "language": "json",
          "code": "// tauri.conf.json\n    {\n      \"build\": {\n        \"beforeDevCommand\": \"npm run dev\",\n        \"beforeBuildCommand\": \"npm run build\",\n        \"devUrl\": \"http://localhost:5173\",\n        \"frontendDist\": \"../dist\"\n      }\n    }",
          "context": "general",
          "file_path": null,
          "description": "##### Update Tauri configuration\n\n    Assuming you have the following `dev` and `build` scripts in your `package",
          "dependencies": null
        },
        {
          "language": "json",
          "code": "// tauri.conf.json\n    {\n      \"build\": {\n        \"beforeDevCommand\": \"yarn dev\",\n        \"beforeBuildCommand\": \"yarn build\",\n        \"devUrl\": \"http://localhost:5173\",\n        \"frontendDist\": \"../dist\"\n      }\n    }",
          "context": "command",
          "file_path": null,
          "description": "",
          "dependencies": null
        },
        {
          "language": "json",
          "code": "// tauri.conf.json\n    {\n      \"build\": {\n        \"beforeDevCommand\": \"pnpm dev\",\n        \"beforeBuildCommand\": \"pnpm build\",\n        \"devUrl\": \"http://localhost:5173\",\n        \"frontendDist\": \"../dist\"\n      }\n    }",
          "context": "command",
          "file_path": null,
          "description": "",
          "dependencies": null
        },
        {
          "language": "json",
          "code": "// tauri.conf.json\n    {\n      \"build\": {\n        \"beforeDevCommand\": \"deno task dev\",\n        \"beforeBuildCommand\": \"deno task build\",\n        \"devUrl\": \"http://localhost:5173\",\n        \"frontendDist\": \"../dist\"\n      }\n    }",
          "context": "command",
          "file_path": null,
          "description": "",
          "dependencies": null
        },
        {
          "language": "js",
          "code": "import { defineConfig } from 'vite';\n\n    const host = process.env.TAURI_DEV_HOST;\n\n    export default defineConfig({\n      // prevent vite from obscuring rust errors\n      clearScreen: false,\n      server: {\n        // make sure this port matches the devUrl port in tauri.conf.json file\n        port: 5173,\n        // Tauri expects a fixed port, fail if that port is not available\n        strictPort: true,\n        // if the host Tauri is expecting is set, use it\n        host: host || false,\n        hmr: host\n          ? {\n              protocol: 'ws',\n              host,\n              port: 1421,\n            }\n          : undefined,\n\n        watch: {\n          // tell vite to ignore watching `src-tauri`\n          ignored: ['**/src-tauri/**'],\n        },\n      },\n      // Env variables starting with the item of `envPrefix` will be exposed in tauri's source code through `import.meta.env`.\n      envPrefix: ['VITE_', 'TAURI_ENV_*'],\n      build: {\n        // Tauri uses Chromium on Windows and WebKit on macOS and Linux\n        target:\n          process.env.TAURI_ENV_PLATFORM == 'windows'\n            ? 'chrome105'\n            : 'safari13',\n        // don't minify for debug builds\n        minify: !process.env.TAURI_ENV_DEBUG ? 'esbuild' : false,\n        // produce sourcemaps for debug builds\n        sourcemap: !!process.env.TAURI_ENV_DEBUG,\n      },\n    });",
          "context": "command",
          "file_path": "vite.config.js",
          "description": "/dist\"\n      }\n    }\n    ```\n\n    </TabItem>\n\n    </Tabs>\n\n1",
          "dependencies": null
        }
      ],
      "related_concepts": [],
      "difficulty": "beginner",
      "tags": [
        "windows",
        "rust",
        "linux",
        "vite",
        "ios",
        "macos"
      ]
    },
    {
      "name": "Window Customization",
      "category": "ui_customization",
      "description": "import { Icon } from '@astrojs/starlight/components';",
      "key_points": [
        "[Creating a Custom Titlebar](#creating-a-custom-titlebar)",
        "[(macOS) Transparent Titlebar with Custom Window Background Color](#macos-transparent-titlebar-with-custom-window-background-color)",
        "For macOS, using a custom titlebar will also lose some features provided by the system, such as [moving or aligning the window](https://support",
        "that you may need to move the rest of your content down so that the titlebar doesn't cover it",
        "that if you are using a Rust-based frontend, you can copy the code above into a `<script>` element in your `index",
        "`data-tauri-drag-region` will only work on the element to which it is directly applied"
      ],
      "code_examples": [
        {
          "language": "json",
          "code": "{\n  \"$schema\": \"../gen/schemas/desktop-schema.json\",\n  \"identifier\": \"main-capability\",\n  \"description\": \"Capability for the main window\",\n  \"windows\": [\"main\"],\n  \"permissions\": [\"core:window:default\", \"core:window:allow-start-dragging\"]\n}",
          "context": "permissions",
          "file_path": "src-tauri/capabilities/default.json",
          "description": "See the [Capabilities Overview](/security/capabilities/) for more information and the [step by step guide](/learn/security/using-plugin-permissions/) to use plugin permissions",
          "dependencies": null
        },
        {
          "language": "css",
          "code": ".titlebar {\n  height: 30px;\n  background: #329ea3;\n  user-select: none;\n  display: grid;\n  grid-template-columns: auto max-content;\n  position: fixed;\n  top: 0;\n  left: 0;\n  right: 0;\n}\n.titlebar > .controls {\n  display: flex;\n}\n.titlebar button {\n  appearance: none;\n  padding: 0;\n  margin: 0;\n  border: none;\n  display: inline-flex;\n  justify-content: center;\n  align-items: center;\n  width: 30px;\n  background-color: transparent;\n}\n.titlebar button:hover {\n  background: #5bbec3;\n}",
          "context": "command",
          "file_path": null,
          "description": "|\n| `core:window:allow-internal-toggle-maximize` | Enables the internal_toggle_maximize command without any pre-configured scope",
          "dependencies": null
        },
        {
          "language": "html",
          "code": "<div class=\"titlebar\">\n  <div data-tauri-drag-region></div>\n  <div class=\"controls\">\n    <button id=\"titlebar-minimize\" title=\"minimize\">\n      <!-- https://api.iconify.design/mdi:window-minimize.svg -->\n      <svg\n        xmlns=\"http://www.w3.org/2000/svg\"\n        width=\"24\"\n        height=\"24\"\n        viewBox=\"0 0 24 24\"\n      >\n        <path fill=\"currentColor\" d=\"M19 13H5v-2h14z\" />\n      </svg>\n    </button>\n    <button id=\"titlebar-maximize\" title=\"maximize\">\n      <!-- https://api.iconify.design/mdi:window-maximize.svg -->\n      <svg\n        xmlns=\"http://www.w3.org/2000/svg\"\n        width=\"24\"\n        height=\"24\"\n        viewBox=\"0 0 24 24\"\n      >\n        <path fill=\"currentColor\" d=\"M4 4h16v16H4zm2 4v10h12V8z\" />\n      </svg>\n    </button>\n    <button id=\"titlebar-close\" title=\"close\">\n      <!-- https://api.iconify.design/mdi:close.svg -->\n      <svg\n        xmlns=\"http://www.w3.org/2000/svg\"\n        width=\"24\"\n        height=\"24\"\n        viewBox=\"0 0 24 24\"\n      >\n        <path\n          fill=\"currentColor\"\n          d=\"M13.46 12L19 17.54V19h-1.46L12 13.46L6.46 19H5v-1.46L10.54 12L5 6.46V5h1.46L12 10.54L17.54 5H19v1.46z\"\n        />\n      </svg>\n    </button>\n  </div>\n</div>",
          "context": "general",
          "file_path": null,
          "description": "titlebar button {\n  appearance: none;\n  padding: 0;\n  margin: 0;\n  border: none;\n  display: inline-flex;\n  justify-content: center;\n  align-items: center;\n  width: 30px;\n  background-color: transparent;\n}",
          "dependencies": null
        },
        {
          "language": "css",
          "code": "*[data-tauri-drag-region] {\n  app-region: drag;\n}",
          "context": "window_management",
          "file_path": null,
          "description": "46z\"\n        />\n      </svg>\n    </button>\n  </div>\n</div>\n```\n\nNote that you may need to move the rest of your content down so that the titlebar doesn't cover it",
          "dependencies": null
        },
        {
          "language": "javascript",
          "code": "import { getCurrentWindow } from '@tauri-apps/api/window';\n\n// when using `\"withGlobalTauri\": true`, you may use\n// const { getCurrentWindow } = window.__TAURI__.window;\n\nconst appWindow = getCurrentWindow();\n\ndocument\n  .getElementById('titlebar-minimize')\n  ?.addEventListener('click', () => appWindow.minimize());\ndocument\n  .getElementById('titlebar-maximize')\n  ?.addEventListener('click', () => appWindow.toggleMaximize());\ndocument\n  .getElementById('titlebar-close')\n  ?.addEventListener('click', () => appWindow.close());",
          "context": "frontend_integration",
          "file_path": null,
          "description": "46z\"\n        />\n      </svg>\n    </button>\n  </div>\n</div>\n```\n\nNote that you may need to move the rest of your content down so that the titlebar doesn't cover it",
          "dependencies": null
        },
        {
          "language": "json",
          "code": "\"tauri\": {\n    \t\"windows\": [\n    \t\t{\n    \t\t\t\"title\": \"Transparent Titlebar Window\",\n    \t\t\t\"width\": 800,\n    \t\t\t\"height\": 600\n    \t\t}\n    \t],\n    }",
          "context": "window_management",
          "file_path": "tauri.conf.json",
          "description": "conf",
          "dependencies": null
        },
        {
          "language": "toml",
          "code": "[target.\"cfg(target_os = \\\"macos\\\")\".dependencies]\n    cocoa = \"0.26\"",
          "context": "window_management",
          "file_path": "src-tauri/Cargo.toml",
          "description": "conf",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "use tauri::{TitleBarStyle, WebviewUrl, WebviewWindowBuilder};\n\n    pub fn run() {\n    \ttauri::Builder::default()\n    \t\t.setup(|app| {\n    \t\t\tlet win_builder =\n    \t\t\t\tWebviewWindowBuilder::new(app, \"main\", WebviewUrl::default())\n    \t\t\t\t\t.title(\"Transparent Titlebar Window\")\n    \t\t\t\t\t.inner_size(800.0, 600.0);\n\n    \t\t\t// set transparent title bar only when building for macOS\n    \t\t\t#[cfg(target_os = \"macos\")]\n    \t\t\tlet win_builder = win_builder.title_bar_style(TitleBarStyle::Transparent);\n\n    \t\t\tlet window = win_builder.build().unwrap();\n\n    \t\t\t// set background color only when building for macOS\n    \t\t\t#[cfg(target_os = \"macos\")]\n    \t\t\t{\n    \t\t\t\tuse cocoa::appkit::{NSColor, NSWindow};\n    \t\t\t\tuse cocoa::base::{id, nil};\n\n    \t\t\t\tlet ns_window = window.ns_window().unwrap() as id;\n    \t\t\t\tunsafe {\n    \t\t\t\t\tlet bg_color = NSColor::colorWithRed_green_blue_alpha_(\n    \t\t\t\t\t\t\tnil,\n    \t\t\t\t\t\t\t50.0 / 255.0,\n    \t\t\t\t\t\t\t158.0 / 255.0,\n    \t\t\t\t\t\t\t163.5 / 255.0,\n    \t\t\t\t\t\t\t1.0,\n    \t\t\t\t\t);\n    \t\t\t\t\tns_window.setBackgroundColor_(bg_color);\n    \t\t\t\t}\n    \t\t\t}\n\n    \t\t\tOk(())\n    \t\t})\n    \t\t.run(tauri::generate_context!())\n    \t\t.expect(\"error while running tauri application\");\n    }",
          "context": "window_management",
          "file_path": "src-tauri/src/lib.rs",
          "description": "dependencies]\n    cocoa = \"0",
          "dependencies": null
        }
      ],
      "related_concepts": [
        "Creating a Custom Titlebar",
        "Through the JavaScript\n  API",
        "Through\n  tauri.conf.json",
        "(macOS) Transparent Titlebar with Custom Window Background Color",
        "Capabilities Overview",
        "step by step guide"
      ],
      "difficulty": "intermediate",
      "tags": [
        "desktop",
        "windows",
        "rust",
        "customization",
        "window",
        "javascript",
        "macos"
      ]
    },
    {
      "name": "Window Menu",
      "category": "ui_customization",
      "description": "import { Tabs, TabItem } from '@astrojs/starlight/components';",
      "key_points": [
        "** When using submenus on MacOS, all items must be grouped under a submenu",
        "Icon support for submenus is available since Tauri 2"
      ],
      "code_examples": [
        {
          "language": "javascript",
          "code": "import { Menu } from '@tauri-apps/api/menu';\n\nconst menu = await Menu.new({\n  items: [\n    {\n      id: 'quit',\n      text: 'Quit',\n      action: () => {\n        console.log('quit pressed');\n      },\n    },\n    {\n      id: 'check_item',\n      text: 'Check Item',\n      checked: true,\n    },\n    {\n      type: 'Separator',\n    },\n    {\n      id: 'disabled_item',\n      text: 'Disabled Item',\n      enabled: false,\n    },\n    {\n      id: 'status',\n      text: 'Status: Processing...',\n    },\n  ],\n});\n\n// If a window was not created with an explicit menu or had one set explicitly,\n// this menu will be assigned to it.\nmenu.setAsAppMenu().then(async (res) => {\n  console.log('menu set success', res);\n\n  // Update individual menu item text\n  const statusItem = await menu.get('status');\n  if (statusItem) {\n    await statusItem.setText('Status: Ready');\n  }\n});",
          "context": "window_management",
          "file_path": null,
          "description": "You can create various types of menu items including basic items, check items, and separators:\n\n<Tabs>\n<TabItem label=\"JavaScript\">\n\nUse the [`Menu",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "use tauri::menu::MenuBuilder;\n\nfn main() {\n    tauri::Builder::default()\n        .setup(|app| {\n            let menu = MenuBuilder::new(app)\n                .text(\"open\", \"Open\")\n                .text(\"close\", \"Close\")\n                .check(\"check_item\", \"Check Item\")\n                .separator()\n                .text(\"disabled_item\", \"Disabled Item\")\n                .text(\"status\", \"Status: Processing...\")\n                .build()?;\n\n            app.set_menu(menu.clone())?;\n\n            // Update individual menu item text\n            menu\n                .get(\"status\")\n                .unwrap()\n                .as_menuitem_unchecked()\n                .set_text(\"Status: Ready\")?;\n\n            Ok(())\n        })\n        .run(tauri::generate_context!());\n}",
          "context": "rust_backend",
          "file_path": null,
          "description": "get('status');\n  if (statusItem) {\n    await statusItem",
          "dependencies": null
        },
        {
          "language": "javascript",
          "code": "import { Menu } from '@tauri-apps/api/menu';\n\nconst menu = await Menu.new({\n  items: [\n    {\n      id: 'Open',\n      text: 'open',\n      action: () => {\n        console.log('open pressed');\n      },\n    },\n    {\n      id: 'Close',\n      text: 'close',\n      action: () => {\n        console.log('close pressed');\n      },\n    },\n  ],\n});\n\nawait menu.setAsAppMenu();",
          "context": "frontend_integration",
          "file_path": null,
          "description": "Use the `on_menu_event` API to handle them",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "#![cfg_attr(not(debug_assertions), windows_subsystem = \"windows\")]\nuse tauri::menu::{MenuBuilder};\n\nfn main() {\n  tauri::Builder::default()\n        .setup(|app| {\n            let menu = MenuBuilder::new(app)\n                .text(\"open\", \"Open\")\n                .text(\"close\", \"Close\")\n                .build()?;\n\n            app.set_menu(menu)?;\n\n            app.on_menu_event(move |app_handle: &tauri::AppHandle, event| {\n\n                println!(\"menu event: {:?}\", event.id());\n\n                match event.id().0.as_str() {\n                    \"open\" => {\n                        println!(\"open event\");\n                    }\n                    \"close\" => {\n                        println!(\"close event\");\n                    }\n                    _ => {\n                        println!(\"unexpected menu event\");\n                    }\n                }\n            });\n\n            Ok(())\n        })\n}",
          "context": "rust_backend",
          "file_path": null,
          "description": "log('close pressed');\n      },\n    },\n  ],\n});\n\nawait menu",
          "dependencies": null
        },
        {
          "language": "javascript",
          "code": "import { Menu, MenuItem, Submenu } from '@tauri-apps/api/menu';\n\n// Will become the application submenu on MacOS\nconst aboutSubmenu = await Submenu.new({\n  text: 'About',\n  items: [\n    await MenuItem.new({\n      id: 'quit',\n      text: 'Quit',\n      action: () => {\n        console.log('Quit pressed');\n      },\n    }),\n  ],\n});\n\nconst fileSubmenu = await Submenu.new({\n  text: 'File',\n  icon: 'folder', // Optional: Add an icon to the submenu\n  items: [\n    await MenuItem.new({\n      id: 'new',\n      text: 'New',\n      action: () => {\n        console.log('New clicked');\n      },\n    }),\n    await MenuItem.new({\n      id: 'open',\n      text: 'Open',\n      action: () => {\n        console.log('Open clicked');\n      },\n    }),\n    await MenuItem.new({\n      id: 'save_as',\n      text: 'Save As...',\n      action: () => {\n        console.log('Save As clicked');\n      },\n    }),\n  ],\n});\n\nconst editSubmenu = await Submenu.new({\n  text: 'Edit',\n  items: [\n    await MenuItem.new({\n      id: 'undo',\n      text: 'Undo',\n      action: () => {\n        console.log('Undo clicked');\n      },\n    }),\n    await MenuItem.new({\n      id: 'redo',\n      text: 'Redo',\n      action: () => {\n        console.log('Redo clicked');\n      },\n    }),\n  ],\n});\n\nconst menu = await Menu.new({\n  items: [aboutSubmenu, fileSubmenu, editSubmenu],\n});\n\nmenu.setAsAppMenu();\n\n// You can also update the submenu icon dynamically\nfileSubmenu.setIcon('document');\n// Or set a native icon (only one type applies per platform)\nfileSubmenu.setNativeIcon('NSFolder');",
          "context": "frontend_integration",
          "file_path": null,
          "description": "0",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "use tauri::{\n    image::Image,\n    menu::{CheckMenuItemBuilder, IconMenuItemBuilder, MenuBuilder, SubmenuBuilder},\n};\n\nfn main() {\n    tauri::Builder::default()\n        .setup(|app| {\n            let menu_image = Image::from_bytes(include_bytes!(\"../icons/menu.png\")).unwrap();\n            let file_menu = SubmenuBuilder::new(app, \"File\")\n                .submenu_icon(menu_image)) // Optional: Add an icon to the submenu\n                .text(\"open\", \"Open\")\n                .text(\"quit\", \"Quit\")\n                .build()?;\n\n            let lang_str = \"en\";\n            let check_sub_item_1 = CheckMenuItemBuilder::new(\"English\")\n                .id(\"en\")\n                .checked(lang_str == \"en\")\n                .build(app)?;\n\n            let check_sub_item_2 = CheckMenuItemBuilder::new(\"Chinese\")\n                .id(\"en\")\n                .checked(lang_str == \"en\")\n                .enabled(false)\n                .build(app)?;\n\n            // Load icon from path\n            let icon_image = Image::from_bytes(include_bytes!(\"../icons/icon.png\")).unwrap();\n\n            let icon_item = IconMenuItemBuilder::new(\"icon\")\n                .icon(icon_image)\n                .build(app)?;\n\n            let other_item = SubmenuBuilder::new(app, \"language\")\n                .item(&check_sub_item_1)\n                .item(&check_sub_item_2)\n                .build()?;\n\n            let menu = MenuBuilder::new(app)\n                .items(&[&file_menu, &other_item, &icon_item])\n                .build()?;\n\n            app.set_menu(menu)?;\n\n            let menu_image_update =\n                Image::from_bytes(include_bytes!(\"../icons/menu_update.png\")).unwrap();\n            // You can also update the submenu icon dynamically\n            file_menu.set_icon(Some(menu_image_update))?;\n            // Or set a native icon (only one type applies per platform)\n            file_menu.set_native_icon(Some(tauri::menu::NativeIcon::Folder))?;\n\n            Ok(())\n        })\n        .run(tauri::generate_context!());\n}",
          "context": "rust_backend",
          "file_path": null,
          "description": "setIcon('document');\n// Or set a native icon (only one type applies per platform)\nfileSubmenu",
          "dependencies": null
        },
        {
          "language": "toml",
          "code": "[dependencies]\ntauri = { version = \"...\", features = [\"...\", \"image-png\"] }",
          "context": "general",
          "file_path": "src-tauri/Cargo.toml",
          "description": "set_native_icon(Some(tauri::menu::NativeIcon::Folder))?;\n\n            Ok(())\n        })",
          "dependencies": null
        },
        {
          "language": "javascript",
          "code": "import { Menu, PredefinedMenuItem } from '@tauri-apps/api/menu';\n\nconst copy = await PredefinedMenuItem.new({\n  text: 'copy-text',\n  item: 'Copy',\n});\n\nconst separator = await PredefinedMenuItem.new({\n  text: 'separator-text',\n  item: 'Separator',\n});\n\nconst undo = await PredefinedMenuItem.new({\n  text: 'undo-text',\n  item: 'Undo',\n});\n\nconst redo = await PredefinedMenuItem.new({\n  text: 'redo-text',\n  item: 'Redo',\n});\n\nconst cut = await PredefinedMenuItem.new({\n  text: 'cut-text',\n  item: 'Cut',\n});\n\nconst paste = await PredefinedMenuItem.new({\n  text: 'paste-text',\n  item: 'Paste',\n});\n\nconst select_all = await PredefinedMenuItem.new({\n  text: 'select_all-text',\n  item: 'SelectAll',\n});\n\nconst menu = await Menu.new({\n  items: [copy, separator, undo, redo, cut, paste, select_all],\n});\n\nawait menu.setAsAppMenu();",
          "context": "frontend_integration",
          "file_path": null,
          "description": "",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "#![cfg_attr(not(debug_assertions), windows_subsystem = \"windows\")]\nuse tauri::menu::{MenuBuilder, PredefinedMenuItem};\n\nfn main() {\n  tauri::Builder::default()\n        .setup(|app| {\n      let menu = MenuBuilder::new(app)\n                .copy()\n                .separator()\n                .undo()\n                .redo()\n                .cut()\n                .paste()\n                .select_all()\n                .item(&PredefinedMenuItem::copy(app, Some(\"custom text\"))?)\n                .build()?;\n            app.set_menu(menu)?;\n\n            Ok(())\n        })\n}",
          "context": "rust_backend",
          "file_path": null,
          "description": "new({\n  items: [copy, separator, undo, redo, cut, paste, select_all],\n});\n\nawait menu",
          "dependencies": null
        },
        {
          "language": "javascript",
          "code": "import {\n  Menu,\n  CheckMenuItem,\n  IconMenuItem,\n  MenuItem,\n} from '@tauri-apps/api/menu';\nimport { Image } from '@tauri-apps/api/image';\n\nlet currentLanguage = 'en';\n\nconst check_sub_item_en = await CheckMenuItem.new({\n  id: 'en',\n  text: 'English',\n  checked: currentLanguage === 'en',\n  action: () => {\n    currentLanguage = 'en';\n    check_sub_item_en.setChecked(currentLanguage === 'en');\n    check_sub_item_zh.setChecked(currentLanguage === 'cn');\n    console.log('English pressed');\n  },\n});\n\nconst check_sub_item_zh = await CheckMenuItem.new({\n  id: 'zh',\n  text: 'Chinese',\n  checked: currentLanguage === 'zh',\n  action: () => {\n    currentLanguage = 'zh';\n    check_sub_item_en.setChecked(currentLanguage === 'en');\n    check_sub_item_zh.setChecked(currentLanguage === 'zh');\n    check_sub_item_zh.setAccelerator('Ctrl+L');\n    console.log('Chinese pressed');\n  },\n});\n\n// Load icon from path\nconst icon = await Image.fromPath('../src/icon.png');\nconst icon2 = await Image.fromPath('../src/icon-2.png');\n\nconst icon_item = await IconMenuItem.new({\n  id: 'icon_item',\n  text: 'Icon Item',\n  icon: icon,\n  action: () => {\n    icon_item.setIcon(icon2);\n    console.log('icon pressed');\n  },\n});\n\nconst text_item = await MenuItem.new({\n  id: 'text_item',\n  text: 'Text Item',\n  action: () => {\n    text_item.setText('Text Item Changed');\n    console.log('text pressed');\n  },\n});\n\nconst menu = await Menu.new({\n  items: [\n    {\n      id: 'change menu',\n      text: 'change_menu',\n      items: [text_item, check_sub_item_en, check_sub_item_zh, icon_item],\n    },\n  ],\n});\n\nawait menu.setAsAppMenu();",
          "context": "frontend_integration",
          "file_path": null,
          "description": "item(&PredefinedMenuItem::copy(app, None)?)`",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "// change-menu-status\n#![cfg_attr(not(debug_assertions), windows_subsystem = \"windows\")]\n\nuse tauri::{\n    image::Image,\n    menu::{CheckMenuItemBuilder, IconMenuItem, MenuBuilder, MenuItem, SubmenuBuilder},\n};\n\nfn main() {\n    tauri::Builder::default()\n        .setup(|app| {\n            let check_sub_item_en = CheckMenuItemBuilder::with_id(\"en\", \"EN\")\n                .checked(true)\n                .build(app)?;\n\n            let check_sub_item_zh = CheckMenuItemBuilder::with_id(\"zh\", \"ZH\")\n                .checked(false)\n                .build(app)?;\n\n            let text_menu = MenuItem::with_id(\n                app,\n                \"change_text\",\n                &\"Change menu\".to_string(),\n                true,\n                Some(\"Ctrl+Z\"),\n            )\n            .unwrap();\n\n            let icon_menu = IconMenuItem::with_id(\n                app,\n                \"change_icon\",\n                &\"Change icon menu\",\n                true,\n                Some(Image::from_bytes(include_bytes!(\"../icons/icon.png\")).unwrap()),\n                Some(\"Ctrl+F\"),\n            )\n            .unwrap();\n\n            let menu_item = SubmenuBuilder::new(app, \"Change menu\")\n                .item(&text_menu)\n                .item(&icon_menu)\n                .items(&[&check_sub_item_en, &check_sub_item_zh])\n                .build()?;\n            let menu = MenuBuilder::new(app).items(&[&menu_item]).build()?;\n            app.set_menu(menu)?;\n            app.on_menu_event(move |_app_handle: &tauri::AppHandle, event| {\n                match event.id().0.as_str() {\n                    \"change_text\" => {\n                        text_menu\n                            .set_text(\"changed menu text\")\n                            .expect(\"Change text error\");\n\n                        text_menu\n                            .set_text(\"changed menu text\")\n                            .expect(\"Change text error\");\n                    }\n                    \"change_icon\" => {\n                        icon_menu\n                            .set_text(\"changed menu-icon text\")\n                            .expect(\"Change text error\");\n                        icon_menu\n                            .set_icon(Some(\n                                Image::from_bytes(include_bytes!(\"../icons/icon-2.png\")).unwrap(),\n                            ))\n                            .expect(\"Change icon error\");\n                    }\n\n                    \"en\" | \"zh\" => {\n                        check_sub_item_en\n                            .set_checked(event.id().0.as_str() == \"en\")\n                            .expect(\"Change check error\");\n                        check_sub_item_zh\n                            .set_checked(event.id().0.as_str() == \"zh\")\n                            .expect(\"Change check error\");\n                        check_sub_item_zh.set_accelerator(Some(\"Ctrl+L\"))\n                        .expect(\"Change accelerator error\");\n                    }\n                    _ => {\n                        println!(\"unexpected menu event\");\n                    }\n                }\n            });\n\n            Ok(())\n        })\n        .run(tauri::generate_context!())\n        .expect(\"error while running tauri application\");\n}",
          "context": "rust_backend",
          "file_path": null,
          "description": "new({\n  items: [\n    {\n      id: 'change menu',\n      text: 'change_menu',\n      items: [text_item, check_sub_item_en, check_sub_item_zh, icon_item],\n    },\n  ],\n});\n\nawait menu",
          "dependencies": null
        }
      ],
      "related_concepts": [],
      "difficulty": "intermediate",
      "tags": [
        "desktop",
        "javascript",
        "windows",
        "rust",
        "linux",
        "window",
        "menu",
        "macos"
      ]
    },
    {
      "name": "Writing Plugin Permissions",
      "category": "security",
      "description": "import { Steps } from '@astrojs/starlight/components'; import ShowSolution from '@components/ShowSolution.astro' import Cta from '@fragments/cta.mdx';",
      "key_points": [],
      "code_examples": [
        {
          "language": "sh",
          "code": "mkdir -p tauri-learning\n    cd tauri-learning\n    cargo tauri plugin new test\n    cd tauri-plugin-test\n    pnpm install\n    pnpm build\n    cargo build",
          "context": "command",
          "file_path": null,
          "description": "Once you have a recent version installed you can go\n    ahead and create the plugin using the Tauri CLI",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "pub fn init<R: Runtime>() -> TauriPlugin<R> {\n    Builder::new(\"test\")\n        .invoke_handler(tauri::generate_handler![\n            commands::ping,\n            commands::write_custom_file,\n        ])\n        .setup(|app, api| {\n            #[cfg(mobile)]\n            let test = mobile::init(app, api)?;\n            #[cfg(desktop)]\n            let test = desktop::init(app, api)?;\n            app.manage(test);\n\n            // manage state so it is accessible by the commands\n            app.manage(MyState::default());\n            Ok(())\n        })\n        .build()\n    }",
          "context": "command",
          "file_path": "src/lib.rs",
          "description": "Next we want to expose it to the frontend so it can be consumed",
          "dependencies": null
        },
        {
          "language": "ts",
          "code": "import { invoke } from '@tauri-apps/api/core'\n\n    export async function ping(value: string): Promise<string | null> {\n      return await invoke<{value?: string}>('plugin:test|ping', {\n        payload: {\n          value,\n        },\n      }).then((r) => (r.value ? r.value : null));\n    }\n\n    export async function writeCustomFile(user_input: string): Promise<string> {\n     return await invoke('plugin:test|write_custom_file',{userInput: user_input});\n    }",
          "context": "command",
          "file_path": "guest-js/index.ts",
          "description": "This is for convenience and has\n    no security impact, as the command handler is already generated\n    and the command can be manually invoked from the frontend",
          "dependencies": null
        }
      ],
      "related_concepts": [
        "`cli`",
        "Prerequisites"
      ],
      "difficulty": "intermediate",
      "tags": [
        "permissions",
        "plugin",
        "desktop",
        "rust",
        "svelte",
        "mobile",
        "writing"
      ]
    }
  ],
  "commands": [
    {
      "name": "download",
      "description": "Tauri command: download",
      "syntax": "invoke('download', args)",
      "examples": [
        "invoke('download', {\n  url: 'https://raw.githubusercontent.com/tauri-apps/tauri/dev/crates/tauri-schema-generator/schemas/config.schema.json',\n  onEvent,\n})"
      ],
      "options": null,
      "related_commands": null
    },
    {
      "name": "login",
      "description": "Tauri command: login",
      "syntax": "invoke('login', args)",
      "examples": [],
      "options": null,
      "related_commands": null
    },
    {
      "name": "open_file",
      "description": "Tauri command: open_file",
      "syntax": "invoke('open_file', args)",
      "examples": [],
      "options": null,
      "related_commands": null
    },
    {
      "name": "download",
      "description": "Tauri command: download",
      "syntax": "invoke('download', args)",
      "examples": [
        "invoke('download', {\n  url: 'https://raw.githubusercontent.com/tauri-apps/tauri/dev/crates/tauri-schema-generator/schemas/config.schema.json',\n  onEvent,\n})"
      ],
      "options": null,
      "related_commands": null
    },
    {
      "name": "download",
      "description": "Tauri command: download",
      "syntax": "invoke('download', args)",
      "examples": [
        "invoke('download', {\n  url: 'https://raw.githubusercontent.com/tauri-apps/tauri/dev/crates/tauri-schema-generator/schemas/config.schema.json',\n  onEvent,\n})"
      ],
      "options": null,
      "related_commands": null
    },
    {
      "name": "tauri_application",
      "description": ".expect(\"error while running",
      "syntax": "tauri application",
      "examples": [
        "tauri application"
      ],
      "options": {},
      "related_commands": null
    },
    {
      "name": "tauri_application",
      "description": ".expect(\"error while running",
      "syntax": "tauri application",
      "examples": [
        "tauri application"
      ],
      "options": {},
      "related_commands": null
    },
    {
      "name": "tauri_application",
      "description": ".expect(\"error while running",
      "syntax": "tauri application",
      "examples": [
        "tauri application"
      ],
      "options": {},
      "related_commands": null
    },
    {
      "name": "tauri_application",
      "description": ".expect(\"error while running",
      "syntax": "tauri application",
      "examples": [
        "tauri application"
      ],
      "options": {},
      "related_commands": null
    },
    {
      "name": "tauri_application",
      "description": ".expect(\"error while running",
      "syntax": "tauri application",
      "examples": [
        "tauri application"
      ],
      "options": {},
      "related_commands": null
    },
    {
      "name": "my_custom_command",
      "description": "Tauri command: my_custom_command",
      "syntax": "invoke('my_custom_command', args)",
      "examples": [
        "invoke('my_custom_command')",
        "invoke(\"my_custom_command\")",
        "invoke('my_custom_command', { invokeMessage: 'Hello!' })"
      ],
      "options": null,
      "related_commands": null
    },
    {
      "name": "my_custom_command",
      "description": "Tauri command: my_custom_command",
      "syntax": "invoke('my_custom_command', args)",
      "examples": [
        "invoke('my_custom_command')",
        "invoke(\"my_custom_command\")",
        "invoke('my_custom_command', { invokeMessage: 'Hello!' })"
      ],
      "options": null,
      "related_commands": null
    },
    {
      "name": "my_custom_command",
      "description": "Tauri command: my_custom_command",
      "syntax": "invoke('my_custom_command', args)",
      "examples": [
        "invoke('my_custom_command')",
        "invoke(\"my_custom_command\")",
        "invoke('my_custom_command', { invokeMessage: 'Hello!' })"
      ],
      "options": null,
      "related_commands": null
    },
    {
      "name": "my_custom_command",
      "description": "Tauri command: my_custom_command",
      "syntax": "invoke('my_custom_command', args)",
      "examples": [
        "invoke('my_custom_command')",
        "invoke(\"my_custom_command\")",
        "invoke('my_custom_command', { invokeMessage: 'Hello!' })"
      ],
      "options": null,
      "related_commands": null
    },
    {
      "name": "read_file",
      "description": "Tauri command: read_file",
      "syntax": "invoke('read_file', args)",
      "examples": [],
      "options": null,
      "related_commands": null
    },
    {
      "name": "login",
      "description": "Tauri command: login",
      "syntax": "invoke('login', args)",
      "examples": [
        "invoke('login', { user: 'tauri', password: '0j4rijw8=' })"
      ],
      "options": null,
      "related_commands": null
    },
    {
      "name": "my_custom_command",
      "description": "Tauri command: my_custom_command",
      "syntax": "invoke('my_custom_command', args)",
      "examples": [
        "invoke('my_custom_command')",
        "invoke(\"my_custom_command\")",
        "invoke('my_custom_command', { invokeMessage: 'Hello!' })"
      ],
      "options": null,
      "related_commands": null
    },
    {
      "name": "my_custom_command",
      "description": "Tauri command: my_custom_command",
      "syntax": "invoke('my_custom_command', args)",
      "examples": [
        "invoke('my_custom_command')",
        "invoke(\"my_custom_command\")",
        "invoke('my_custom_command', { invokeMessage: 'Hello!' })"
      ],
      "options": null,
      "related_commands": null
    },
    {
      "name": "read",
      "description": "Tauri command: read",
      "syntax": "invoke('read', args)",
      "examples": [
        "invoke('read')"
      ],
      "options": null,
      "related_commands": null
    },
    {
      "name": "my_custom_command",
      "description": "Tauri command: my_custom_command",
      "syntax": "invoke('my_custom_command', args)",
      "examples": [
        "invoke('my_custom_command')",
        "invoke(\"my_custom_command\")",
        "invoke('my_custom_command', { invokeMessage: 'Hello!' })"
      ],
      "options": null,
      "related_commands": null
    },
    {
      "name": "my_custom_command",
      "description": "Tauri command: my_custom_command",
      "syntax": "invoke('my_custom_command', args)",
      "examples": [
        "invoke('my_custom_command')",
        "invoke(\"my_custom_command\")",
        "invoke('my_custom_command', { invokeMessage: 'Hello!' })"
      ],
      "options": null,
      "related_commands": null
    },
    {
      "name": "load_image",
      "description": "Tauri command: load_image",
      "syntax": "invoke('load_image', args)",
      "examples": [],
      "options": null,
      "related_commands": null
    },
    {
      "name": "my_custom_command",
      "description": "Tauri command: my_custom_command",
      "syntax": "invoke('my_custom_command', args)",
      "examples": [
        "invoke('my_custom_command')",
        "invoke(\"my_custom_command\")",
        "invoke('my_custom_command', { invokeMessage: 'Hello!' })"
      ],
      "options": null,
      "related_commands": null
    },
    {
      "name": "my_custom_command",
      "description": "Tauri command: my_custom_command",
      "syntax": "invoke('my_custom_command', args)",
      "examples": [
        "invoke('my_custom_command')",
        "invoke(\"my_custom_command\")",
        "invoke('my_custom_command', { invokeMessage: 'Hello!' })"
      ],
      "options": null,
      "related_commands": null
    },
    {
      "name": "my_custom_command",
      "description": "Tauri command: my_custom_command",
      "syntax": "invoke('my_custom_command', args)",
      "examples": [
        "invoke('my_custom_command')",
        "invoke(\"my_custom_command\")",
        "invoke('my_custom_command', { invokeMessage: 'Hello!' })"
      ],
      "options": null,
      "related_commands": null
    },
    {
      "name": "my_custom_command",
      "description": "Tauri command: my_custom_command",
      "syntax": "invoke('my_custom_command', args)",
      "examples": [
        "invoke('my_custom_command')",
        "invoke(\"my_custom_command\")",
        "invoke('my_custom_command', { invokeMessage: 'Hello!' })"
      ],
      "options": null,
      "related_commands": null
    },
    {
      "name": "upload",
      "description": "Tauri command: upload",
      "syntax": "invoke('upload', args)",
      "examples": [
        "invoke('upload', data, {\n  headers: {\n    Authorization: 'apikey',\n  },\n})"
      ],
      "options": null,
      "related_commands": null
    },
    {
      "name": "cmd_a",
      "description": "Tauri command: cmd_a",
      "syntax": "invoke('cmd_a', args)",
      "examples": [],
      "options": null,
      "related_commands": null
    },
    {
      "name": "cmd_b",
      "description": "Tauri command: cmd_b",
      "syntax": "invoke('cmd_b', args)",
      "examples": [],
      "options": null,
      "related_commands": null
    },
    {
      "name": "my_custom_command",
      "description": "Tauri command: my_custom_command",
      "syntax": "invoke('my_custom_command', args)",
      "examples": [
        "invoke('my_custom_command')",
        "invoke(\"my_custom_command\")",
        "invoke('my_custom_command', { invokeMessage: 'Hello!' })"
      ],
      "options": null,
      "related_commands": null
    },
    {
      "name": "tauri_application",
      "description": ".expect(\"error while running",
      "syntax": "tauri application",
      "examples": [
        "tauri application"
      ],
      "options": {},
      "related_commands": null
    },
    {
      "name": "tauri_build",
      "description": "This file is used by the Tauri runtime and the Tauri CLI. You can define build settings (such as the [command run before `",
      "syntax": "tauri build",
      "examples": [
        "tauri build"
      ],
      "options": {},
      "related_commands": null
    },
    {
      "name": "tauri_dev",
      "description": "This file is used by the Tauri runtime and the Tauri CLI. You can define build settings (such as the [command run before `tauri build`][before-build-command] or [`",
      "syntax": "tauri dev",
      "examples": [
        "tauri dev"
      ],
      "options": {},
      "related_commands": null
    },
    {
      "name": "tauri_build",
      "description": "npm=\"",
      "syntax": "npm run tauri build",
      "examples": [
        "npm run tauri build"
      ],
      "options": {},
      "related_commands": null
    },
    {
      "name": "tauri_build",
      "description": "yarn=\"yarn",
      "syntax": "tauri build",
      "examples": [
        "tauri build"
      ],
      "options": {},
      "related_commands": null
    },
    {
      "name": "tauri_build",
      "description": "pnpm=\"",
      "syntax": "pnpm tauri build",
      "examples": [
        "pnpm tauri build"
      ],
      "options": {},
      "related_commands": null
    },
    {
      "name": "tauri_build",
      "description": "deno=\"deno task",
      "syntax": "tauri build",
      "examples": [
        "tauri build"
      ],
      "options": {},
      "related_commands": null
    },
    {
      "name": "tauri_build",
      "description": "bun=\"bun",
      "syntax": "tauri build",
      "examples": [
        "tauri build"
      ],
      "options": {},
      "related_commands": null
    },
    {
      "name": "tauri_build",
      "description": "cargo=\"",
      "syntax": "cargo tauri build",
      "examples": [
        "cargo tauri build"
      ],
      "options": {},
      "related_commands": null
    },
    {
      "name": "tauri_dev",
      "description": "An additional thing to take note of is the `features=[]` portion of the `tauri` dependency. Running `",
      "syntax": "tauri dev",
      "examples": [
        "tauri dev"
      ],
      "options": {},
      "related_commands": null
    },
    {
      "name": "tauri_build",
      "description": "An additional thing to take note of is the `features=[]` portion of the `tauri` dependency. Running `tauri dev` and `",
      "syntax": "tauri build",
      "examples": [
        "tauri build"
      ],
      "options": {},
      "related_commands": null
    },
    {
      "name": "tauri_Cargo_features",
      "description": "g to take note of is the `features=[]` portion of the `tauri` dependency. Running `tauri dev` and `tauri build` will automatically manage which features need to be enabled in your project based on the your Tauri configuration. For more information about `tauri` feature flags see the [documentation][",
      "syntax": "tauri Cargo features",
      "examples": [
        "tauri Cargo features"
      ],
      "options": {},
      "related_commands": null
    },
    {
      "name": "tauri_Cargo_features",
      "description": "[",
      "syntax": "tauri Cargo features",
      "examples": [
        "tauri Cargo features"
      ],
      "options": {},
      "related_commands": null
    },
    {
      "name": "tauri_dev",
      "description": "npm install",
      "syntax": "npm run tauri dev",
      "examples": [
        "npm run tauri dev"
      ],
      "options": {},
      "related_commands": null
    },
    {
      "name": "tauri_dev",
      "description": "yarn",
      "syntax": "tauri dev",
      "examples": [
        "tauri dev"
      ],
      "options": {},
      "related_commands": null
    },
    {
      "name": "tauri_dev",
      "description": "pnpm install",
      "syntax": "pnpm tauri dev",
      "examples": [
        "pnpm tauri dev"
      ],
      "options": {},
      "related_commands": null
    },
    {
      "name": "tauri_dev",
      "description": "deno task",
      "syntax": "tauri dev",
      "examples": [
        "tauri dev"
      ],
      "options": {},
      "related_commands": null
    },
    {
      "name": "tauri_dev",
      "description": "bun",
      "syntax": "tauri dev",
      "examples": [
        "tauri dev"
      ],
      "options": {},
      "related_commands": null
    },
    {
      "name": "tauri_dev",
      "description": "cargo=\"cd tauri-app",
      "syntax": "cargo tauri dev",
      "examples": [
        "cargo tauri dev"
      ],
      "options": {},
      "related_commands": null
    },
    {
      "name": "tauri_init",
      "description": "npm=\"npx",
      "syntax": "tauri init",
      "examples": [
        "tauri init"
      ],
      "options": {},
      "related_commands": null
    },
    {
      "name": "tauri_init",
      "description": "yarn=\"yarn",
      "syntax": "tauri init",
      "examples": [
        "tauri init"
      ],
      "options": {},
      "related_commands": null
    },
    {
      "name": "tauri_init",
      "description": "pnpm=\"",
      "syntax": "pnpm tauri init",
      "examples": [
        "pnpm tauri init"
      ],
      "options": {},
      "related_commands": null
    },
    {
      "name": "tauri_init",
      "description": "deno=\"deno task",
      "syntax": "tauri init",
      "examples": [
        "tauri init"
      ],
      "options": {},
      "related_commands": null
    },
    {
      "name": "tauri_init",
      "description": "bun=\"bun",
      "syntax": "tauri init",
      "examples": [
        "tauri init"
      ],
      "options": {},
      "related_commands": null
    },
    {
      "name": "tauri_init",
      "description": "cargo=\"",
      "syntax": "cargo tauri init",
      "examples": [
        "cargo tauri init"
      ],
      "options": {},
      "related_commands": null
    },
    {
      "name": "tauri_dev",
      "description": "npm=\"npx",
      "syntax": "tauri dev",
      "examples": [
        "tauri dev"
      ],
      "options": {},
      "related_commands": null
    },
    {
      "name": "tauri_dev",
      "description": "yarn=\"yarn",
      "syntax": "tauri dev",
      "examples": [
        "tauri dev"
      ],
      "options": {},
      "related_commands": null
    },
    {
      "name": "tauri_dev",
      "description": "pnpm=\"",
      "syntax": "pnpm tauri dev",
      "examples": [
        "pnpm tauri dev"
      ],
      "options": {},
      "related_commands": null
    },
    {
      "name": "tauri_dev",
      "description": "deno=\"deno task",
      "syntax": "tauri dev",
      "examples": [
        "tauri dev"
      ],
      "options": {},
      "related_commands": null
    },
    {
      "name": "tauri_dev",
      "description": "bun=\"bun",
      "syntax": "tauri dev",
      "examples": [
        "tauri dev"
      ],
      "options": {},
      "related_commands": null
    },
    {
      "name": "tauri_dev",
      "description": "cargo=\"",
      "syntax": "cargo tauri dev",
      "examples": [
        "cargo tauri dev"
      ],
      "options": {},
      "related_commands": null
    },
    {
      "name": "tauri_dev",
      "description": "To develop your application for desktop, run the `",
      "syntax": "tauri dev",
      "examples": [
        "tauri dev"
      ],
      "options": {},
      "related_commands": null
    },
    {
      "name": "tauri_dev",
      "description": "npm=\"",
      "syntax": "npm run tauri dev",
      "examples": [
        "npm run tauri dev"
      ],
      "options": {},
      "related_commands": null
    },
    {
      "name": "tauri_dev",
      "description": "yarn=\"yarn",
      "syntax": "tauri dev",
      "examples": [
        "tauri dev"
      ],
      "options": {},
      "related_commands": null
    },
    {
      "name": "tauri_dev",
      "description": "pnpm=\"",
      "syntax": "pnpm tauri dev",
      "examples": [
        "pnpm tauri dev"
      ],
      "options": {},
      "related_commands": null
    },
    {
      "name": "tauri_dev",
      "description": "deno=\"deno task",
      "syntax": "tauri dev",
      "examples": [
        "tauri dev"
      ],
      "options": {},
      "related_commands": null
    },
    {
      "name": "tauri_dev",
      "description": "bun=\"bun",
      "syntax": "tauri dev",
      "examples": [
        "tauri dev"
      ],
      "options": {},
      "related_commands": null
    },
    {
      "name": "tauri_dev",
      "description": "cargo=\"",
      "syntax": "cargo tauri dev",
      "examples": [
        "cargo tauri dev"
      ],
      "options": {},
      "related_commands": null
    },
    {
      "name": "tauri_android_dev",
      "description": "Developing for mobile is similar to how desktop development works, but you must run `",
      "syntax": "tauri android dev",
      "examples": [
        "tauri android dev"
      ],
      "options": {},
      "related_commands": null
    },
    {
      "name": "tauri_ios_dev",
      "description": "Developing for mobile is similar to how desktop development works, but you must run `tauri android dev` or `",
      "syntax": "tauri ios dev",
      "examples": [
        "tauri ios dev"
      ],
      "options": {},
      "related_commands": null
    },
    {
      "name": "tauri_ios_dev",
      "description": "Then you must run `",
      "syntax": "tauri ios dev",
      "examples": [
        "tauri ios dev"
      ],
      "options": {},
      "related_commands": null
    },
    {
      "name": "tauri_ios_dev",
      "description": "npm=\"",
      "syntax": "npm run tauri ios dev",
      "examples": [
        "npm run tauri ios dev"
      ],
      "options": {},
      "related_commands": null
    },
    {
      "name": "tauri_ios_dev",
      "description": "yarn=\"yarn",
      "syntax": "tauri ios dev",
      "examples": [
        "tauri ios dev"
      ],
      "options": {},
      "related_commands": null
    },
    {
      "name": "tauri_ios_dev",
      "description": "pnpm=\"",
      "syntax": "pnpm tauri ios dev",
      "examples": [
        "pnpm tauri ios dev"
      ],
      "options": {},
      "related_commands": null
    },
    {
      "name": "tauri_ios_dev",
      "description": "deno=\"deno task",
      "syntax": "tauri ios dev",
      "examples": [
        "tauri ios dev"
      ],
      "options": {},
      "related_commands": null
    },
    {
      "name": "tauri_ios_dev",
      "description": "bun=\"bun",
      "syntax": "tauri ios dev",
      "examples": [
        "tauri ios dev"
      ],
      "options": {},
      "related_commands": null
    },
    {
      "name": "tauri_ios_dev",
      "description": "cargo=\"",
      "syntax": "cargo tauri ios dev",
      "examples": [
        "cargo tauri ios dev"
      ],
      "options": {},
      "related_commands": null
    },
    {
      "name": "tauri_ios_dev",
      "description": "On the first time you execute `",
      "syntax": "tauri ios dev",
      "examples": [
        "tauri ios dev"
      ],
      "options": {},
      "related_commands": null
    },
    {
      "name": "tauri_dev",
      "description": "You can disable this behavior by using the `--no-watch` flag on the `",
      "syntax": "tauri dev",
      "examples": [
        "tauri dev"
      ],
      "options": {},
      "related_commands": null
    },
    {
      "name": "tauri_folder",
      "description": "To restrict the files that are watched for changes you can create a `.taurignore` file in the src-",
      "syntax": "tauri folder",
      "examples": [
        "tauri folder"
      ],
      "options": {},
      "related_commands": null
    },
    {
      "name": "tauri_core_crates_and_tauri_CLI",
      "description": "This is a documentation of all environment variables used by",
      "syntax": "tauri core crates and tauri CLI",
      "examples": [
        "tauri core crates and tauri CLI"
      ],
      "options": {},
      "related_commands": null
    },
    {
      "name": "tauri_configuration_file",
      "description": "- `TAURI_CLI_CONFIG_DEPTH` — Number of levels to traverse and find",
      "syntax": "tauri configuration file",
      "examples": [
        "tauri configuration file"
      ],
      "options": {},
      "related_commands": null
    },
    {
      "name": "tauri_application",
      "description": "- `TAURI_CLI_NO_DEV_SERVER_WAIT` — Skip waiting for the frontend dev server to start before building the",
      "syntax": "tauri application",
      "examples": [
        "tauri application"
      ],
      "options": {},
      "related_commands": null
    },
    {
      "name": "tauri_bundler",
      "description": "- `TAURI_BUNDLER_TOOLS_GITHUB_MIRROR` - Specify a GitHub mirror to download files and tools used by",
      "syntax": "tauri bundler",
      "examples": [
        "tauri bundler"
      ],
      "options": {},
      "related_commands": null
    },
    {
      "name": "tauri_bundler",
      "description": "- `TAURI_BUNDLER_TOOLS_GITHUB_MIRROR_TEMPLATE` - Specify a GitHub mirror template to download files and tools used by",
      "syntax": "tauri bundler",
      "examples": [
        "tauri bundler"
      ],
      "options": {},
      "related_commands": null
    },
    {
      "name": "tauri_android_project",
      "description": "- `TAURI_ANDROID_PROJECT_PATH` — Path of the",
      "syntax": "tauri android project",
      "examples": [
        "tauri android project"
      ],
      "options": {},
      "related_commands": null
    },
    {
      "name": "tauri_iOS_project",
      "description": "- `TAURI_IOS_PROJECT_PATH` — Path of the",
      "syntax": "tauri iOS project",
      "examples": [
        "tauri iOS project"
      ],
      "options": {},
      "related_commands": null
    },
    {
      "name": "tauri_application",
      "description": ".expect(\"error while running",
      "syntax": "tauri application",
      "examples": [
        "tauri application"
      ],
      "options": {},
      "related_commands": null
    },
    {
      "name": "tauri_application",
      "description": ".expect(\"error while running",
      "syntax": "tauri application",
      "examples": [
        "tauri application"
      ],
      "options": {},
      "related_commands": null
    },
    {
      "name": "tauri_icon",
      "description": "npm=\"",
      "syntax": "npm run tauri icon",
      "examples": [
        "npm run tauri icon"
      ],
      "options": {
        "o": "<OUTPUT>        Output directory. Default: 'icons' directory next to the tauri.conf.json file",
        "output": "<OUTPUT>        Output directory. Default: 'icons' directory next to the tauri.conf.json file",
        "p": "<PNG>              Custom PNG icon sizes to generate. When set, the default icons are not generated",
        "png": "<PNG>              Custom PNG icon sizes to generate. When set, the default icons are not generated",
        "h": "Print help",
        "help": "Print help",
        "V": "Print version",
        "version": "Print version"
      },
      "related_commands": null
    },
    {
      "name": "tauri_icon",
      "description": "yarn=\"yarn",
      "syntax": "tauri icon",
      "examples": [
        "tauri icon"
      ],
      "options": {
        "o": "<OUTPUT>        Output directory. Default: 'icons' directory next to the tauri.conf.json file",
        "output": "<OUTPUT>        Output directory. Default: 'icons' directory next to the tauri.conf.json file",
        "p": "<PNG>              Custom PNG icon sizes to generate. When set, the default icons are not generated",
        "png": "<PNG>              Custom PNG icon sizes to generate. When set, the default icons are not generated",
        "h": "Print help",
        "help": "Print help",
        "V": "Print version",
        "version": "Print version"
      },
      "related_commands": null
    },
    {
      "name": "tauri_icon",
      "description": "pnpm=\"",
      "syntax": "pnpm tauri icon",
      "examples": [
        "pnpm tauri icon"
      ],
      "options": {
        "o": "<OUTPUT>        Output directory. Default: 'icons' directory next to the tauri.conf.json file",
        "output": "<OUTPUT>        Output directory. Default: 'icons' directory next to the tauri.conf.json file",
        "p": "<PNG>              Custom PNG icon sizes to generate. When set, the default icons are not generated",
        "png": "<PNG>              Custom PNG icon sizes to generate. When set, the default icons are not generated",
        "h": "Print help",
        "help": "Print help",
        "V": "Print version",
        "version": "Print version"
      },
      "related_commands": null
    },
    {
      "name": "tauri_icon",
      "description": "cargo=\"",
      "syntax": "cargo tauri icon",
      "examples": [
        "cargo tauri icon"
      ],
      "options": {
        "o": "<OUTPUT>        Output directory. Default: 'icons' directory next to the tauri.conf.json file",
        "output": "<OUTPUT>        Output directory. Default: 'icons' directory next to the tauri.conf.json file",
        "p": "<PNG>              Custom PNG icon sizes to generate. When set, the default icons are not generated",
        "png": "<PNG>              Custom PNG icon sizes to generate. When set, the default icons are not generated",
        "h": "Print help",
        "help": "Print help",
        "V": "Print version",
        "version": "Print version"
      },
      "related_commands": null
    },
    {
      "name": "tauri_icon",
      "description": "deno=\"deno task",
      "syntax": "tauri icon",
      "examples": [
        "tauri icon"
      ],
      "options": {
        "o": "<OUTPUT>        Output directory. Default: 'icons' directory next to the tauri.conf.json file",
        "output": "<OUTPUT>        Output directory. Default: 'icons' directory next to the tauri.conf.json file",
        "p": "<PNG>              Custom PNG icon sizes to generate. When set, the default icons are not generated",
        "png": "<PNG>              Custom PNG icon sizes to generate. When set, the default icons are not generated",
        "h": "Print help",
        "help": "Print help",
        "V": "Print version",
        "version": "Print version"
      },
      "related_commands": null
    },
    {
      "name": "tauri_icon",
      "description": ">",
      "syntax": "pnpm tauri icon",
      "examples": [
        "pnpm tauri icon"
      ],
      "options": {
        "o": "<OUTPUT>        Output directory. Default: 'icons' directory next to the tauri.conf.json file",
        "output": "<OUTPUT>        Output directory. Default: 'icons' directory next to the tauri.conf.json file",
        "p": "<PNG>              Custom PNG icon sizes to generate. When set, the default icons are not generated",
        "png": "<PNG>              Custom PNG icon sizes to generate. When set, the default icons are not generated",
        "h": "Print help",
        "help": "Print help",
        "V": "Print version",
        "version": "Print version"
      },
      "related_commands": null
    },
    {
      "name": "tauri_icon",
      "description": "Usage: p",
      "syntax": "npm run tauri icon",
      "examples": [
        "npm run tauri icon"
      ],
      "options": {
        "o": "<OUTPUT>        Output directory. Default: 'icons' directory next to the tauri.conf.json file",
        "output": "<OUTPUT>        Output directory. Default: 'icons' directory next to the tauri.conf.json file",
        "p": "<PNG>              Custom PNG icon sizes to generate. When set, the default icons are not generated",
        "png": "<PNG>              Custom PNG icon sizes to generate. When set, the default icons are not generated",
        "h": "Print help",
        "help": "Print help",
        "V": "Print version",
        "version": "Print version"
      },
      "related_commands": null
    },
    {
      "name": "tauri_icon",
      "description": "- `png`: The requirements for the png icons are: width == height, RGBA (RGB + Transparency), and 32bit per pixel (8bit per channel). Commonly expected sizes on desktop are 32, 128, 256, and 512 pixels. We recommend to at least match the output of `",
      "syntax": "tauri icon",
      "examples": [
        "tauri icon"
      ],
      "options": {},
      "related_commands": null
    },
    {
      "name": "tauri_icon",
      "description": "If `",
      "syntax": "tauri icon",
      "examples": [
        "tauri icon"
      ],
      "options": {},
      "related_commands": null
    },
    {
      "name": "tauri_repo",
      "description": "[in the",
      "syntax": "tauri repo",
      "examples": [
        "tauri repo"
      ],
      "options": {},
      "related_commands": null
    },
    {
      "name": "tauri_icon",
      "description": "npm=\"",
      "syntax": "npm run tauri icon",
      "examples": [
        "npm run tauri icon"
      ],
      "options": {
        "o": "<OUTPUT>        Output directory. Default: 'icons' directory next to the tauri.conf.json file",
        "output": "<OUTPUT>        Output directory. Default: 'icons' directory next to the tauri.conf.json file",
        "p": "<PNG>              Custom PNG icon sizes to generate. When set, the default icons are not generated",
        "png": "<PNG>              Custom PNG icon sizes to generate. When set, the default icons are not generated",
        "h": "Print help",
        "help": "Print help",
        "V": "Print version",
        "version": "Print version"
      },
      "related_commands": null
    },
    {
      "name": "tauri_icon",
      "description": "yarn=\"yarn",
      "syntax": "tauri icon",
      "examples": [
        "tauri icon"
      ],
      "options": {
        "o": "<OUTPUT>        Output directory. Default: 'icons' directory next to the tauri.conf.json file",
        "output": "<OUTPUT>        Output directory. Default: 'icons' directory next to the tauri.conf.json file",
        "p": "<PNG>              Custom PNG icon sizes to generate. When set, the default icons are not generated",
        "png": "<PNG>              Custom PNG icon sizes to generate. When set, the default icons are not generated",
        "h": "Print help",
        "help": "Print help",
        "V": "Print version",
        "version": "Print version"
      },
      "related_commands": null
    },
    {
      "name": "tauri_icon",
      "description": "pnpm=\"",
      "syntax": "pnpm tauri icon",
      "examples": [
        "pnpm tauri icon"
      ],
      "options": {
        "o": "<OUTPUT>        Output directory. Default: 'icons' directory next to the tauri.conf.json file",
        "output": "<OUTPUT>        Output directory. Default: 'icons' directory next to the tauri.conf.json file",
        "p": "<PNG>              Custom PNG icon sizes to generate. When set, the default icons are not generated",
        "png": "<PNG>              Custom PNG icon sizes to generate. When set, the default icons are not generated",
        "h": "Print help",
        "help": "Print help",
        "V": "Print version",
        "version": "Print version"
      },
      "related_commands": null
    },
    {
      "name": "tauri_icon",
      "description": "cargo=\"",
      "syntax": "cargo tauri icon",
      "examples": [
        "cargo tauri icon"
      ],
      "options": {
        "o": "<OUTPUT>        Output directory. Default: 'icons' directory next to the tauri.conf.json file",
        "output": "<OUTPUT>        Output directory. Default: 'icons' directory next to the tauri.conf.json file",
        "p": "<PNG>              Custom PNG icon sizes to generate. When set, the default icons are not generated",
        "png": "<PNG>              Custom PNG icon sizes to generate. When set, the default icons are not generated",
        "h": "Print help",
        "help": "Print help",
        "V": "Print version",
        "version": "Print version"
      },
      "related_commands": null
    },
    {
      "name": "tauri_icon",
      "description": "deno=\"deno task",
      "syntax": "tauri icon",
      "examples": [
        "tauri icon"
      ],
      "options": {
        "o": "<OUTPUT>        Output directory. Default: 'icons' directory next to the tauri.conf.json file",
        "output": "<OUTPUT>        Output directory. Default: 'icons' directory next to the tauri.conf.json file",
        "p": "<PNG>              Custom PNG icon sizes to generate. When set, the default icons are not generated",
        "png": "<PNG>              Custom PNG icon sizes to generate. When set, the default icons are not generated",
        "h": "Print help",
        "help": "Print help",
        "V": "Print version",
        "version": "Print version"
      },
      "related_commands": null
    },
    {
      "name": "tauri_icon",
      "description": ">",
      "syntax": "pnpm tauri icon",
      "examples": [
        "pnpm tauri icon"
      ],
      "options": {
        "o": "<OUTPUT>        Output directory. Default: 'icons' directory next to the tauri.conf.json file",
        "output": "<OUTPUT>        Output directory. Default: 'icons' directory next to the tauri.conf.json file",
        "p": "<PNG>              Custom PNG icon sizes to generate. When set, the default icons are not generated",
        "png": "<PNG>              Custom PNG icon sizes to generate. When set, the default icons are not generated",
        "h": "Print help",
        "help": "Print help",
        "V": "Print version",
        "version": "Print version"
      },
      "related_commands": null
    },
    {
      "name": "tauri_icon",
      "description": "Usage: p",
      "syntax": "npm run tauri icon",
      "examples": [
        "npm run tauri icon"
      ],
      "options": {
        "o": "<OUTPUT>        Output directory. Default: 'icons' directory next to the tauri.conf.json file",
        "output": "<OUTPUT>        Output directory. Default: 'icons' directory next to the tauri.conf.json file",
        "p": "<PNG>              Custom PNG icon sizes to generate. When set, the default icons are not generated",
        "png": "<PNG>              Custom PNG icon sizes to generate. When set, the default icons are not generated",
        "h": "Print help",
        "help": "Print help",
        "V": "Print version",
        "version": "Print version"
      },
      "related_commands": null
    },
    {
      "name": "tauri_icon",
      "description": "- `png`: The requirements for the png icons are: width == height, RGBA (RGB + Transparency), and 32bit per pixel (8bit per channel). Commonly expected sizes on desktop are 32, 128, 256, and 512 pixels. We recommend to at least match the output of `",
      "syntax": "tauri icon",
      "examples": [
        "tauri icon"
      ],
      "options": {},
      "related_commands": null
    },
    {
      "name": "tauri_icon",
      "description": "If `",
      "syntax": "tauri icon",
      "examples": [
        "tauri icon"
      ],
      "options": {},
      "related_commands": null
    },
    {
      "name": "tauri_repo",
      "description": "[in the",
      "syntax": "tauri repo",
      "examples": [
        "tauri repo"
      ],
      "options": {},
      "related_commands": null
    },
    {
      "name": "tauri_migrate",
      "description": "npm=\"npm install @tauri-apps/cli@latest",
      "syntax": "npm run tauri migrate",
      "examples": [
        "npm run tauri migrate"
      ],
      "options": {},
      "related_commands": null
    },
    {
      "name": "tauri_migrate",
      "description": "yarn",
      "syntax": "tauri migrate",
      "examples": [
        "tauri migrate"
      ],
      "options": {},
      "related_commands": null
    },
    {
      "name": "tauri_migrate",
      "description": "pnpm=\"pnpm update @tauri-apps/cli@latest",
      "syntax": "pnpm tauri migrate",
      "examples": [
        "pnpm tauri migrate"
      ],
      "options": {},
      "related_commands": null
    },
    {
      "name": "tauri_migrate",
      "description": "cargo='cargo install tauri-cli --version \"^2.0.0\" --locked",
      "syntax": "cargo tauri migrate",
      "examples": [
        "cargo tauri migrate"
      ],
      "options": {},
      "related_commands": null
    },
    {
      "name": "tauri_migrate",
      "description": "npm=\"npm install @tauri-apps/cli@latest",
      "syntax": "npm run tauri migrate",
      "examples": [
        "npm run tauri migrate"
      ],
      "options": {},
      "related_commands": null
    },
    {
      "name": "tauri_migrate",
      "description": "yarn",
      "syntax": "tauri migrate",
      "examples": [
        "tauri migrate"
      ],
      "options": {},
      "related_commands": null
    },
    {
      "name": "tauri_migrate",
      "description": "pnpm=\"pnpm update @tauri-apps/cli@latest",
      "syntax": "pnpm tauri migrate",
      "examples": [
        "pnpm tauri migrate"
      ],
      "options": {},
      "related_commands": null
    },
    {
      "name": "tauri_migrate",
      "description": "cargo='cargo install tauri-cli --version \"^2.0.0\" --locked",
      "syntax": "cargo tauri migrate",
      "examples": [
        "cargo tauri migrate"
      ],
      "options": {},
      "related_commands": null
    },
    {
      "name": "tauri_ios_dev",
      "description": "then running `",
      "syntax": "tauri ios dev",
      "examples": [
        "tauri ios dev"
      ],
      "options": {},
      "related_commands": null
    },
    {
      "name": "tauri_icon",
      "description": "- `icons/` directory is the default output directory of the [`",
      "syntax": "tauri icon",
      "examples": [
        "tauri icon"
      ],
      "options": {},
      "related_commands": null
    },
    {
      "name": "hello",
      "description": "Tauri command: hello",
      "syntax": "invoke('hello', args)",
      "examples": [
        "invoke('hello')"
      ],
      "options": null,
      "related_commands": null
    },
    {
      "name": "call_my_sidecar",
      "description": "Tauri command: call_my_sidecar",
      "syntax": "invoke('call_my_sidecar', args)",
      "examples": [],
      "options": null,
      "related_commands": null
    },
    {
      "name": "tauri_dev",
      "description": "pnpm install",
      "syntax": "pnpm tauri dev",
      "examples": [
        "pnpm tauri dev"
      ],
      "options": {},
      "related_commands": null
    },
    {
      "name": "tauri_dev",
      "description": "cargo add tokio",
      "syntax": "tauri dev",
      "examples": [
        "tauri dev"
      ],
      "options": {},
      "related_commands": null
    },
    {
      "name": "tauri_application",
      "description": ".expect(\"error while running",
      "syntax": "tauri application",
      "examples": [
        "tauri application"
      ],
      "options": {},
      "related_commands": null
    },
    {
      "name": "increase_counter",
      "description": "Tauri command: increase_counter",
      "syntax": "invoke('increase_counter', args)",
      "examples": [],
      "options": null,
      "related_commands": null
    },
    {
      "name": "increase_counter",
      "description": "Tauri command: increase_counter",
      "syntax": "invoke('increase_counter', args)",
      "examples": [],
      "options": null,
      "related_commands": null
    },
    {
      "name": "tauri_cargo_update",
      "description": "cd src-",
      "syntax": "tauri\ncargo update",
      "examples": [
        "tauri\ncargo update"
      ],
      "options": {},
      "related_commands": null
    },
    {
      "name": "tauri_dev",
      "description": "pnpm install",
      "syntax": "pnpm tauri dev",
      "examples": [
        "pnpm tauri dev"
      ],
      "options": {},
      "related_commands": null
    },
    {
      "name": "tauri_add_fs",
      "description": "If it is an existing plugin from our workspace you can use the automated way:",
      "syntax": "pnpm tauri add fs",
      "examples": [
        "pnpm tauri add fs"
      ],
      "options": {},
      "related_commands": null
    },
    {
      "name": "tauri_application",
      "description": ".expect(\"error while running",
      "syntax": "tauri application",
      "examples": [
        "tauri application"
      ],
      "options": {},
      "related_commands": null
    },
    {
      "name": "tauri_dev",
      "description": "p",
      "syntax": "npm run tauri dev",
      "examples": [
        "npm run tauri dev"
      ],
      "options": {},
      "related_commands": null
    },
    {
      "name": "tauri_application",
      "description": ".expect(\"error while running",
      "syntax": "tauri application",
      "examples": [
        "tauri application"
      ],
      "options": {},
      "related_commands": null
    },
    {
      "name": "tauri_application",
      "description": ".expect(\"error while running",
      "syntax": "tauri application",
      "examples": [
        "tauri application"
      ],
      "options": {},
      "related_commands": null
    },
    {
      "name": "tauri_info",
      "description": "by running `",
      "syntax": "cargo tauri info",
      "examples": [
        "cargo tauri info"
      ],
      "options": {},
      "related_commands": null
    },
    {
      "name": "tauri_plugin_new_test\n____cd_tauri",
      "description": "cd tauri-learning",
      "syntax": "cargo tauri plugin new test\n    cd tauri",
      "examples": [
        "cargo tauri plugin new test\n    cd tauri"
      ],
      "options": {},
      "related_commands": null
    }
  ],
  "workflows": [
    {
      "name": "workflow_capabilities-for-windows-and-platforms.mdx_d0c8d388",
      "description": "Step-by-step guide from capabilities-for-windows-and-platforms.mdx",
      "steps": [
        {
          "description": "### Create Multiple Windows in a Tauri Application\n\n   Here we create an app with two windows labelled `first` and `second`.\n   There are multiple ways to create windows in your Tauri application.\n\n  ",
          "details": "### Create Multiple Windows in a Tauri Application\n\n   Here we create an app with two windows labelled `first` and `second`.\n   There are multiple ways to create windows in your Tauri application.\n\n   #### Create Windows with the Tauri Configuration File\n\n   In the Tauri configuration file, usually named `tauri.conf.json`:\n\n    <ShowSolution>\n    ```javascript\n      \"productName\": \"multiwindow\",\n      ...\n      \"app\": {\n        \"windows\": [\n          {\n            \"label\": \"first\",\n            \"title\": \"First\",\n            \"width\": 800,\n            \"height\": 600\n          },\n          {\n            \"label\": \"second\",\n            \"title\": \"Second\",\n            \"width\": 800,\n            \"height\": 600\n          }\n        ],\n      },\n      ...\n    }\n    ```\n    </ShowSolution>\n\n   #### Create Windows Programmatically\n\n    In the Rust code to create a Tauri app:\n\n    <ShowSolution>\n    ```rust\n    tauri::Builder::default()\n        .invoke_handler(tauri::generate_handler![greet])\n        .setup(|app| {\n            let webview_url = tauri::WebviewUrl::App(\"index.html\".into());\n            // First window\n            tauri::WebviewWindowBuilder::new(app, \"first\", webview_url.clone())\n                .title(\"First\")\n                .build()?;\n            // Second window\n            tauri::WebviewWindowBuilder::new(app, \"second\", webview_url)\n                .title(\"Second\")\n                .build()?;\n            Ok(())\n        })\n        .run(context)\n        .expect(\"error while running tauri application\");\n    ```\n    </ShowSolution>"
        },
        {
          "description": "### Apply Different Capabilities to Different Windows\n\n    The windows of a Tauri app can use different features or plugins of the Tauri backend.\n    For better security it is recommended to only give",
          "details": "### Apply Different Capabilities to Different Windows\n\n    The windows of a Tauri app can use different features or plugins of the Tauri backend.\n    For better security it is recommended to only give the necessary capabilities to each window.\n    We simulate a scenario where the `first` windows uses filesystem and dialog functionalities and `second`\n    only needs dialog functionalities.\n\n    #### Separate capability files per category\n\n    It is recommended to separate the capability files per category of actions they enable.\n\n    <ShowSolution>\n    JSON files in the `src-tauri/capabilities` will be taken into account for the capability system.\n    Here we separate capabilities related to the filesystem and dialog window into `filesystem.json`\n    and `dialog.json`."
        },
        {
          "description": "filetree of the Tauri project:*\n    ```\n    /src\n    /src-tauri\n      /capabilities\n        filesystem.json\n        dialog.json\n      tauri.conf.json\n    package.json\n    README.md\n    ```\n    </ShowS",
          "details": "filetree of the Tauri project:*\n    ```\n    /src\n    /src-tauri\n      /capabilities\n        filesystem.json\n        dialog.json\n      tauri.conf.json\n    package.json\n    README.md\n    ```\n    </ShowSolution>\n\n    #### Give filesystem capabilities to the `first` window\n\n    We give the `first` window the capability to have read access to the content of the `$HOME` directory.\n\n    <ShowSolution>\n    Use the `windows` field in a capability file with one or multiple window labels.\n\n    ```json title=\"filesystem.json\"\n    {\n      \"identifier\": \"fs-read-home\",\n      \"description\": \"Allow access file access to home directory\",\n      \"local\": true,\n      \"windows\": [\"first\"],\n      \"permissions\": [\n        \"fs:allow-home-read\",\n      ]\n    }\n    ```\n    </ShowSolution>\n\n    #### Give dialog capabilities to the `first` and `second` window\n\n    We give to `first` and `second` windows the capability to create a \"Yes/No\" dialog\n\n    <ShowSolution>\n    Use the `windows` field in a capability file with one or multiple window labels.\n\n    ```json title=\"dialog.json\"\n    {\n      \"identifier\": \"dialog\",\n      \"description\": \"Allow to open a dialog\",\n      \"local\": true,\n      \"windows\": [\"first\", \"second\"],\n      \"permissions\": [\"dialog:allow-ask\"]\n    }\n    ```\n\n    </ShowSolution>"
        },
        {
          "description": "### Make Capabilities Platform Dependent\n\n    We now want to customize the capabilities to be active only on certain platforms.\n    We make our filesystem capabilities only active on `linux` and `wind",
          "details": "### Make Capabilities Platform Dependent\n\n    We now want to customize the capabilities to be active only on certain platforms.\n    We make our filesystem capabilities only active on `linux` and `windows`.\n\n    <ShowSolution>\n    Use the `platforms` field in a capability file to make it platform-specific.\n\n    ```json title=\"filesystem.json\"\n    {\n      \"identifier\": \"fs-read-home\",\n      \"description\": \"Allow access file access to home directory\",\n      \"local\": true,\n      \"windows\": [\"first\"],\n      \"permissions\": [\n        \"fs:allow-home-read\",\n      ],\n      \"platforms\": [\"linux\", \"windows\"]\n    }\n    ```\n\n    The currently available platforms are `linux`, `windows`, `macos`, `android`, and `ios`.\n    </ShowSolution>"
        }
      ],
      "prerequisites": [],
      "code_snippets": [
        {
          "language": "javascript",
          "code": "\"productName\": \"multiwindow\",\n      ...\n      \"app\": {\n        \"windows\": [\n          {\n            \"label\": \"first\",\n            \"title\": \"First\",\n            \"width\": 800,\n            \"height\": 600\n          },\n          {\n            \"label\": \"second\",\n            \"title\": \"Second\",\n            \"width\": 800,\n            \"height\": 600\n          }\n        ],\n      },\n      ...\n    }",
          "context": "window_management",
          "file_path": null,
          "description": "conf",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "tauri::Builder::default()\n        .invoke_handler(tauri::generate_handler![greet])\n        .setup(|app| {\n            let webview_url = tauri::WebviewUrl::App(\"index.html\".into());\n            // First window\n            tauri::WebviewWindowBuilder::new(app, \"first\", webview_url.clone())\n                .title(\"First\")\n                .build()?;\n            // Second window\n            tauri::WebviewWindowBuilder::new(app, \"second\", webview_url)\n                .title(\"Second\")\n                .build()?;\n            Ok(())\n        })\n        .run(context)\n        .expect(\"error while running tauri application\");",
          "context": "window_management",
          "file_path": null,
          "description": "",
          "dependencies": null
        },
        {
          "language": "json",
          "code": "{\n      \"identifier\": \"fs-read-home\",\n      \"description\": \"Allow access file access to home directory\",\n      \"local\": true,\n      \"windows\": [\"first\"],\n      \"permissions\": [\n        \"fs:allow-home-read\",\n      ]\n    }",
          "context": "window_management",
          "file_path": "filesystem.json",
          "description": "<ShowSolution>\n    Use the `windows` field in a capability file with one or multiple window labels",
          "dependencies": null
        },
        {
          "language": "json",
          "code": "{\n      \"identifier\": \"dialog\",\n      \"description\": \"Allow to open a dialog\",\n      \"local\": true,\n      \"windows\": [\"first\", \"second\"],\n      \"permissions\": [\"dialog:allow-ask\"]\n    }",
          "context": "window_management",
          "file_path": "dialog.json",
          "description": "er\": \"fs-read-home\",\n      \"description\": \"Allow access file access to home directory\",\n      \"local\": true,\n      \"windows\": [\"first\"],\n      \"permissions\": [\n        \"fs:allow-home-read\",\n      ]\n    }\n    ```\n    </ShowSolution>\n\n    #### Give dialog capabilities to the `first` and `second` window\n\n    We give to `first` and `second` windows the capability to create a \"Yes/No\" dialog\n\n    <ShowSolution>\n    Use the `windows` field in a capability file with one or multiple window labels",
          "dependencies": null
        },
        {
          "language": "json",
          "code": "{\n      \"identifier\": \"fs-read-home\",\n      \"description\": \"Allow access file access to home directory\",\n      \"local\": true,\n      \"windows\": [\"first\"],\n      \"permissions\": [\n        \"fs:allow-home-read\",\n      ],\n      \"platforms\": [\"linux\", \"windows\"]\n    }",
          "context": "window_management",
          "file_path": "filesystem.json",
          "description": "<ShowSolution>\n    Use the `platforms` field in a capability file to make it platform-specific",
          "dependencies": null
        }
      ],
      "common_errors": [],
      "best_practices": []
    },
    {
      "name": "workflow_capabilities-for-windows-and-platforms.mdx_1",
      "description": "Workflow from capabilities-for-windows-and-platforms.mdx",
      "steps": [
        {
          "number": 1,
          "description": "### Create Multiple Windows in a Tauri Application"
        },
        {
          "number": 2,
          "description": "### Apply Different Capabilities to Different Windows"
        },
        {
          "number": 3,
          "description": "### Make Capabilities Platform Dependent"
        }
      ],
      "prerequisites": [],
      "code_snippets": [
        {
          "language": "javascript",
          "code": "\"productName\": \"multiwindow\",\n      ...\n      \"app\": {\n        \"windows\": [\n          {\n            \"label\": \"first\",\n            \"title\": \"First\",\n            \"width\": 800,\n            \"height\": 600\n          },\n          {\n            \"label\": \"second\",\n            \"title\": \"Second\",\n            \"width\": 800,\n            \"height\": 600\n          }\n        ],\n      },\n      ...\n    }",
          "context": "window_management",
          "file_path": null,
          "description": "conf",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "tauri::Builder::default()\n        .invoke_handler(tauri::generate_handler![greet])\n        .setup(|app| {\n            let webview_url = tauri::WebviewUrl::App(\"index.html\".into());\n            // First window\n            tauri::WebviewWindowBuilder::new(app, \"first\", webview_url.clone())\n                .title(\"First\")\n                .build()?;\n            // Second window\n            tauri::WebviewWindowBuilder::new(app, \"second\", webview_url)\n                .title(\"Second\")\n                .build()?;\n            Ok(())\n        })\n        .run(context)\n        .expect(\"error while running tauri application\");",
          "context": "window_management",
          "file_path": null,
          "description": "",
          "dependencies": null
        },
        {
          "language": "json",
          "code": "{\n      \"identifier\": \"fs-read-home\",\n      \"description\": \"Allow access file access to home directory\",\n      \"local\": true,\n      \"windows\": [\"first\"],\n      \"permissions\": [\n        \"fs:allow-home-read\",\n      ]\n    }",
          "context": "window_management",
          "file_path": "filesystem.json",
          "description": "<ShowSolution>\n    Use the `windows` field in a capability file with one or multiple window labels",
          "dependencies": null
        },
        {
          "language": "json",
          "code": "{\n      \"identifier\": \"dialog\",\n      \"description\": \"Allow to open a dialog\",\n      \"local\": true,\n      \"windows\": [\"first\", \"second\"],\n      \"permissions\": [\"dialog:allow-ask\"]\n    }",
          "context": "window_management",
          "file_path": "dialog.json",
          "description": "er\": \"fs-read-home\",\n      \"description\": \"Allow access file access to home directory\",\n      \"local\": true,\n      \"windows\": [\"first\"],\n      \"permissions\": [\n        \"fs:allow-home-read\",\n      ]\n    }\n    ```\n    </ShowSolution>\n\n    #### Give dialog capabilities to the `first` and `second` window\n\n    We give to `first` and `second` windows the capability to create a \"Yes/No\" dialog\n\n    <ShowSolution>\n    Use the `windows` field in a capability file with one or multiple window labels",
          "dependencies": null
        },
        {
          "language": "json",
          "code": "{\n      \"identifier\": \"fs-read-home\",\n      \"description\": \"Allow access file access to home directory\",\n      \"local\": true,\n      \"windows\": [\"first\"],\n      \"permissions\": [\n        \"fs:allow-home-read\",\n      ],\n      \"platforms\": [\"linux\", \"windows\"]\n    }",
          "context": "window_management",
          "file_path": "filesystem.json",
          "description": "<ShowSolution>\n    Use the `platforms` field in a capability file to make it platform-specific",
          "dependencies": null
        }
      ],
      "common_errors": [],
      "best_practices": []
    },
    {
      "name": "workflow_create-project.mdx_633a2444",
      "description": "Step-by-step guide from create-project.mdx",
      "steps": [
        {
          "description": "Choose a name and a bundle identifier (unique-id for your app):\n   ```\n   ? Project name (tauri-app) ›\n   ? Identifier (com.tauri-app.app) ›\n   ```",
          "details": "Choose a name and a bundle identifier (unique-id for your app):\n   ```\n   ? Project name (tauri-app) ›\n   ? Identifier (com.tauri-app.app) ›\n   ```"
        },
        {
          "description": "Select a flavor for your frontend. First the language:\n   ```\n   ? Choose which language to use for your frontend ›\n   Rust  (cargo)\n   TypeScript / JavaScript  (pnpm, yarn, npm, bun)\n   .NET  (dotnet",
          "details": "Select a flavor for your frontend. First the language:\n   ```\n   ? Choose which language to use for your frontend ›\n   Rust  (cargo)\n   TypeScript / JavaScript  (pnpm, yarn, npm, bun)\n   .NET  (dotnet)\n   ```"
        },
        {
          "description": "Select a package manager (if there are multiple available):\n\n   Options for **TypeScript / JavaScript**:\n\n   ```\n   ? Choose your package manager ›\n   pnpm\n   yarn\n   npm\n   bun\n   ```",
          "details": "Select a package manager (if there are multiple available):\n\n   Options for **TypeScript / JavaScript**:\n\n   ```\n   ? Choose your package manager ›\n   pnpm\n   yarn\n   npm\n   bun\n   ```"
        },
        {
          "description": "Select a UI Template and flavor (if there are multiple available):\n\n   Options for **Rust**:\n\n   ```\n   ? Choose your UI template ›\n   Vanilla\n   Yew\n   Leptos\n   Sycamore\n   ```\n\n   Options for **Typ",
          "details": "Select a UI Template and flavor (if there are multiple available):\n\n   Options for **Rust**:\n\n   ```\n   ? Choose your UI template ›\n   Vanilla\n   Yew\n   Leptos\n   Sycamore\n   ```\n\n   Options for **TypeScript / JavaScript**:\n\n   ```\n   ? Choose your UI template ›\n   Vanilla\n   Vue\n   Svelte\n   React\n   Solid\n   Angular\n   Preact\n\n   ? Choose your UI flavor ›\n   TypeScript\n   JavaScript\n   ```\n\n   Options for **.NET**:\n\n   ```\n   ? Choose your UI template ›\n   Blazor  (https://dotnet.microsoft.com/en-us/apps/aspnet/web-apps/blazor/)\n   ```"
        }
      ],
      "prerequisites": [],
      "code_snippets": [],
      "common_errors": [],
      "best_practices": []
    },
    {
      "name": "workflow_create-project.mdx_2a8f70bd",
      "description": "Step-by-step guide from create-project.mdx",
      "steps": [
        {
          "description": "Create a new directory for your project and initialize the frontend. You can use plain HTML, CSS, and JavaScript, or any framework you prefer such as Next.js, Nuxt, Svelte, Yew, or Leptos. You just ne",
          "details": "Create a new directory for your project and initialize the frontend. You can use plain HTML, CSS, and JavaScript, or any framework you prefer such as Next.js, Nuxt, Svelte, Yew, or Leptos. You just need a way of serving the app in your browser. Just as an example, this is how you would setup a simple Vite app:\n\n        <CommandTabs\n            npm=\"mkdir tauri-app\n                cd tauri-app\n                npm create vite@latest .\"\n            yarn=\"mkdir tauri-app\n                cd tauri-app\n                yarn create vite .\"\n            pnpm=\"mkdir tauri-app\n                cd tauri-app\n                pnpm create vite .\"\n            deno=\"mkdir tauri-app\n                cd tauri-app\n                deno run -A npm:create-vite .\"\n            bun=\"mkdir tauri-app\n                cd tauri-app\n                bun create vite\"\n        />"
        },
        {
          "description": "Then, install Tauri's CLI tool using your package manager of choice. If you are using `cargo` to install the Tauri CLI, you will have to install it globally.\n\n        <CommandTabs\n            npm=\"npm",
          "details": "Then, install Tauri's CLI tool using your package manager of choice. If you are using `cargo` to install the Tauri CLI, you will have to install it globally.\n\n        <CommandTabs\n            npm=\"npm install -D @tauri-apps/cli@latest\"\n            yarn=\"yarn add -D @tauri-apps/cli@latest\"\n            pnpm=\"pnpm add -D @tauri-apps/cli@latest\"\n            deno=\"deno add -D npm:@tauri-apps/cli@latest\"\n            bun=\"bun add -D @tauri-apps/cli@latest\"\n            cargo='cargo install tauri-cli --version \"^2.0.0\" --locked'\n        />"
        },
        {
          "description": "Determine the URL of your frontend development server. This is the URL that Tauri will use to load your content. For example, if you are using Vite, the default URL is `http://localhost:5173`.",
          "details": "Determine the URL of your frontend development server. This is the URL that Tauri will use to load your content. For example, if you are using Vite, the default URL is `http://localhost:5173`."
        },
        {
          "description": "In your project directory, initialize Tauri:\n\n        <CommandTabs\n            npm=\"npx tauri init\"\n            yarn=\"yarn tauri init\"\n            pnpm=\"pnpm tauri init\"\n            deno=\"deno task ta",
          "details": "In your project directory, initialize Tauri:\n\n        <CommandTabs\n            npm=\"npx tauri init\"\n            yarn=\"yarn tauri init\"\n            pnpm=\"pnpm tauri init\"\n            deno=\"deno task tauri init\"\n            bun=\"bun tauri init\"\n            cargo=\"cargo tauri init\"\n        />\n\n        After running the command it will display a prompt asking you for different options:\n\n        ```sh frame=none\n        ✔ What is your app name? tauri-app\n        ✔ What should the window title be? tauri-app\n        ✔ Where are your web assets located? ..\n        ✔ What is the url of your dev server? http://localhost:5173\n        ✔ What is your frontend dev command? pnpm run dev\n        ✔ What is your frontend build command? pnpm run build\n        ```\n\n        This will create a `src-tauri` directory in your project with the necessary Tauri configuration files."
        },
        {
          "description": "Verify your Tauri app is working by running the development server:\n\n        <CommandTabs\n            npm=\"npx tauri dev\"\n            yarn=\"yarn tauri dev\"\n            pnpm=\"pnpm tauri dev\"\n          ",
          "details": "Verify your Tauri app is working by running the development server:\n\n        <CommandTabs\n            npm=\"npx tauri dev\"\n            yarn=\"yarn tauri dev\"\n            pnpm=\"pnpm tauri dev\"\n            deno=\"deno task tauri dev\"\n            bun=\"bun tauri dev\"\n            cargo=\"cargo tauri dev\"\n        />\n\n        This command will compile the Rust code and open a window with your web content."
        }
      ],
      "prerequisites": [],
      "code_snippets": [],
      "common_errors": [],
      "best_practices": []
    },
    {
      "name": "workflow_create-project.mdx_2",
      "description": "Workflow from create-project.mdx",
      "steps": [
        {
          "number": 1,
          "description": "Choose a name and a bundle identifier (unique-id for your app):\n   ```\n   ? Project name (tauri-app) ›\n   ? Identifier (com.tauri-app.app) ›\n   ```"
        },
        {
          "number": 2,
          "description": "Select a flavor for your frontend. First the language:\n   ```\n   ? Choose which language to use for your frontend ›\n   Rust  (cargo)\n   TypeScript / JavaScript  (pnpm, yarn, npm, bun)\n   .NET  (dotnet)\n   ```"
        },
        {
          "number": 3,
          "description": "Select a package manager (if there are multiple available):"
        },
        {
          "number": 4,
          "description": "Select a UI Template and flavor (if there are multiple available):"
        }
      ],
      "prerequisites": [],
      "code_snippets": [],
      "common_errors": [],
      "best_practices": []
    },
    {
      "name": "workflow_migrate-from-tauri-1.mdx_0",
      "description": "Workflow from migrate-from-tauri-1.mdx",
      "steps": [
        {
          "number": 1,
          "description": "Change the Cargo manifest to produce the library. Append the following block:"
        },
        {
          "number": 2,
          "description": "Rename `src-tauri/src/main.rs` to `src-tauri/src/lib.rs`. This file will be shared by both desktop and mobile targets."
        },
        {
          "number": 3,
          "description": "Rename the `main` function header in `lib.rs` to the following:"
        },
        {
          "number": 4,
          "description": "Recreate the `main.rs` file calling the shared run function:"
        },
        {
          "number": 1,
          "description": "Add to cargo dependencies:"
        },
        {
          "number": 2,
          "description": "Use in JavaScript or Rust project:"
        },
        {
          "number": 1,
          "description": "Add to cargo dependencies:"
        },
        {
          "number": 2,
          "description": "Use in JavaScript or Rust project:"
        },
        {
          "number": 1,
          "description": "Add to cargo dependencies:"
        },
        {
          "number": 2,
          "description": "Use in JavaScript or Rust project:"
        },
        {
          "number": 1,
          "description": "Add to cargo dependencies:"
        },
        {
          "number": 2,
          "description": "Use in JavaScript or Rust project:"
        },
        {
          "number": 1,
          "description": "Add to cargo dependencies:"
        },
        {
          "number": 2,
          "description": "Use in JavaScript or Rust project:"
        },
        {
          "number": 1,
          "description": "Add to cargo dependencies:"
        },
        {
          "number": 2,
          "description": "Use in JavaScript or Rust project:"
        },
        {
          "number": 1,
          "description": "Add to cargo dependencies:"
        },
        {
          "number": 2,
          "description": "Use in JavaScript or Rust project:"
        },
        {
          "number": 1,
          "description": "Add to cargo dependencies:"
        },
        {
          "number": 2,
          "description": "Use in JavaScript or Rust project:"
        },
        {
          "number": 1,
          "description": "Add to cargo dependencies:"
        },
        {
          "number": 2,
          "description": "Use in JavaScript or Rust project:"
        },
        {
          "number": 1,
          "description": "Add to cargo dependencies:"
        },
        {
          "number": 2,
          "description": "Use in JavaScript or Rust project:"
        }
      ],
      "prerequisites": [],
      "code_snippets": [
        {
          "language": "toml",
          "code": "// src-tauri/Cargo.toml\n[lib]\nname = \"app_lib\"\ncrate-type = [\"staticlib\", \"cdylib\", \"rlib\"]",
          "context": "general",
          "file_path": null,
          "description": "Change the Cargo manifest to produce the library",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "// src-tauri/src/lib.rs\n#[cfg_attr(mobile, tauri::mobile_entry_point)]\npub fn run() {\n    // your code here\n}",
          "context": "general",
          "file_path": null,
          "description": "Rename the `main` function header in `lib",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "// src-tauri/src/main.rs\n#![cfg_attr(not(debug_assertions), windows_subsystem = \"windows\")]\n\nfn main() {\n  app_lib::run();\n}",
          "context": "general",
          "file_path": null,
          "description": "Recreate the `main",
          "dependencies": null
        },
        {
          "language": "diff",
          "code": "- import { invoke } from \"@tauri-apps/api/tauri\"\n+ import { invoke } from \"@tauri-apps/api/core\"",
          "context": "general",
          "file_path": null,
          "description": "### Migrate to Core Module\n\nThe `@tauri-apps/api/tauri` module was renamed to `@tauri-apps/api/core`",
          "dependencies": null
        },
        {
          "language": "toml",
          "code": "# Cargo.toml\n[dependencies]\ntauri-plugin-cli = \"2\"",
          "context": "plugin",
          "file_path": null,
          "description": "Use the `@tauri-apps/plugin-cli` plugin instead:\n\n1",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "fn main() {\n    tauri::Builder::default()\n        .plugin(tauri_plugin_cli::init())\n}",
          "context": "plugin",
          "file_path": null,
          "description": "toml\n[dependencies]\ntauri-plugin-cli = \"2\"\n```\n\n2",
          "dependencies": null
        },
        {
          "language": "json",
          "code": "// package.json\n{\n  \"dependencies\": {\n    \"@tauri-apps/plugin-cli\": \"^2.0.0\"\n  }\n}",
          "context": "plugin",
          "file_path": null,
          "description": "Use in JavaScript or Rust project:\n\n<Tabs syncKey=\"lang\">\n<TabItem label=\"JavaScript\">\n\n```rust\nfn main() {\n    tauri::Builder::default()",
          "dependencies": null
        },
        {
          "language": "javascript",
          "code": "import { getMatches } from '@tauri-apps/plugin-cli';\nconst matches = await getMatches();",
          "context": "plugin",
          "file_path": null,
          "description": "0",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "fn main() {\n    use tauri_plugin_cli::CliExt;\n    tauri::Builder::default()\n        .plugin(tauri_plugin_cli::init())\n        .setup(|app| {\n            let cli_matches = app.cli().matches()?;\n            Ok(())\n        })\n}",
          "context": "plugin",
          "file_path": null,
          "description": "0",
          "dependencies": null
        },
        {
          "language": "toml",
          "code": "[dependencies]\ntauri-plugin-clipboard-manager = \"2\"",
          "context": "plugin",
          "file_path": null,
          "description": "matches()?;\n            Ok(())\n        })\n}\n```\n\n</TabItem>\n</Tabs>\n\n### Migrate to Clipboard Plugin\n\nThe Rust `App::clipboard_manager` and `AppHandle::clipboard_manager` and JavaScript `@tauri-apps/api/clipboard` APIs have been removed",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "fn main() {\n    tauri::Builder::default()\n        .plugin(tauri_plugin_clipboard_manager::init())\n}",
          "context": "plugin",
          "file_path": null,
          "description": "matches()?;\n            Ok(())\n        })\n}\n```\n\n</TabItem>\n</Tabs>\n\n### Migrate to Clipboard Plugin\n\nThe Rust `App::clipboard_manager` and `AppHandle::clipboard_manager` and JavaScript `@tauri-apps/api/clipboard` APIs have been removed",
          "dependencies": null
        },
        {
          "language": "json",
          "code": "// package.json\n{\n  \"dependencies\": {\n    \"@tauri-apps/plugin-clipboard-manager\": \"^2.0.0\"\n  }\n}",
          "context": "plugin",
          "file_path": null,
          "description": "Use the `@tauri-apps/plugin-clipboard-manager` plugin instead:\n\n```toml\n[dependencies]\ntauri-plugin-clipboard-manager = \"2\"\n```\n\n<Tabs syncKey=\"lang\">\n<TabItem label=\"JavaScript\">\n\n```rust\nfn main() {\n    tauri::Builder::default()",
          "dependencies": null
        },
        {
          "language": "javascript",
          "code": "import { writeText, readText } from '@tauri-apps/plugin-clipboard-manager';\nawait writeText('Tauri is awesome!');\nassert(await readText(), 'Tauri is awesome!');",
          "context": "plugin",
          "file_path": null,
          "description": "0",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "use tauri_plugin_clipboard::{ClipboardExt, ClipKind};\ntauri::Builder::default()\n    .plugin(tauri_plugin_clipboard::init())\n    .setup(|app| {\n        app.clipboard().write(ClipKind::PlainText {\n            label: None,\n            text: \"Tauri is awesome!\".into(),\n        })?;\n        Ok(())\n    })",
          "context": "plugin",
          "file_path": null,
          "description": "0",
          "dependencies": null
        },
        {
          "language": "toml",
          "code": "# Cargo.toml\n[dependencies]\ntauri-plugin-dialog = \"2\"",
          "context": "plugin",
          "file_path": null,
          "description": "Use the `@tauri-apps/plugin-dialog` plugin instead:\n\n1",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "fn main() {\n    tauri::Builder::default()\n        .plugin(tauri_plugin_dialog::init())\n}",
          "context": "plugin",
          "file_path": null,
          "description": "toml\n[dependencies]\ntauri-plugin-dialog = \"2\"\n```\n\n2",
          "dependencies": null
        },
        {
          "language": "json",
          "code": "// package.json\n{\n  \"dependencies\": {\n    \"@tauri-apps/plugin-dialog\": \"^2.0.0\"\n  }\n}",
          "context": "plugin",
          "file_path": null,
          "description": "Use in JavaScript or Rust project:\n\n<Tabs syncKey=\"lang\">\n<TabItem label=\"JavaScript\">\n\n```rust\nfn main() {\n    tauri::Builder::default()",
          "dependencies": null
        },
        {
          "language": "javascript",
          "code": "import { save } from '@tauri-apps/plugin-dialog';\nconst filePath = await save({\n  filters: [\n    {\n      name: 'Image',\n      extensions: ['png', 'jpeg'],\n    },\n  ],\n});",
          "context": "plugin",
          "file_path": null,
          "description": "0",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "use tauri_plugin_dialog::DialogExt;\ntauri::Builder::default()\n    .plugin(tauri_plugin_dialog::init())\n    .setup(|app| {\n        app.dialog().file().pick_file(|file_path| {\n            // do something with the optional file path here\n            // the file path is `None` if the user closed the dialog\n        });\n\n        app.dialog().message(\"Tauri is Awesome!\").show();\n        Ok(())\n     })",
          "context": "plugin",
          "file_path": null,
          "description": "0",
          "dependencies": null
        },
        {
          "language": "toml",
          "code": "# Cargo.toml\n[dependencies]\ntauri-plugin-fs = \"2\"",
          "context": "plugin",
          "file_path": null,
          "description": "org/std/fs/) for Rust and `@tauri-apps/plugin-fs` plugin for JavaScript instead:\n\n1",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "fn main() {\n    tauri::Builder::default()\n        .plugin(tauri_plugin_fs::init())\n}",
          "context": "plugin",
          "file_path": null,
          "description": "toml\n[dependencies]\ntauri-plugin-fs = \"2\"\n```\n\n2",
          "dependencies": null
        },
        {
          "language": "json",
          "code": "// package.json\n{\n  \"dependencies\": {\n    \"@tauri-apps/plugin-fs\": \"^2.0.0\"\n  }\n}",
          "context": "plugin",
          "file_path": null,
          "description": "Use in JavaScript or Rust project:\n\n<Tabs syncKey=\"lang\">\n<TabItem label=\"JavaScript\">\n\n```rust\nfn main() {\n    tauri::Builder::default()",
          "dependencies": null
        },
        {
          "language": "javascript",
          "code": "import { mkdir, BaseDirectory } from '@tauri-apps/plugin-fs';\nawait mkdir('db', { baseDir: BaseDirectory.AppLocalData });",
          "context": "plugin",
          "file_path": null,
          "description": "0",
          "dependencies": null
        },
        {
          "language": "toml",
          "code": "# Cargo.toml\n[dependencies]\n[target.\"cfg(not(any(target_os = \\\"android\\\", target_os = \\\"ios\\\")))\".dependencies]\ntauri-plugin-global-shortcut = \"2\"",
          "context": "plugin",
          "file_path": null,
          "description": "Use the `@tauri-apps/plugin-global-shortcut` plugin instead:\n\n1",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "fn main() {\n    tauri::Builder::default()\n        .plugin(tauri_plugin_global_shortcut::Builder::default().build())\n}",
          "context": "plugin",
          "file_path": null,
          "description": "dependencies]\ntauri-plugin-global-shortcut = \"2\"\n```\n\n2",
          "dependencies": null
        },
        {
          "language": "json",
          "code": "// package.json\n{\n  \"dependencies\": {\n    \"@tauri-apps/plugin-global-shortcut\": \"^2.0.0\"\n  }\n}",
          "context": "plugin",
          "file_path": null,
          "description": "plugin(tauri_plugin_global_shortcut::Builder::default()",
          "dependencies": null
        },
        {
          "language": "javascript",
          "code": "import { register } from '@tauri-apps/plugin-global-shortcut';\nawait register('CommandOrControl+Shift+C', () => {\n  console.log('Shortcut triggered');\n});",
          "context": "plugin",
          "file_path": null,
          "description": "0",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "use tauri_plugin_global_shortcut::GlobalShortcutExt;\n\ntauri::Builder::default()\n    .plugin(\n        tauri_plugin_global_shortcut::Builder::new().with_handler(|app, shortcut| {\n            println!(\"Shortcut triggered: {:?}\", shortcut);\n        })\n        .build(),\n    )\n    .setup(|app| {\n        // register a global shortcut\n        // on macOS, the Cmd key is used\n        // on Windows and Linux, the Ctrl key is used\n        app.global_shortcut().register(\"CmdOrCtrl+Y\")?;\n        Ok(())\n    })",
          "context": "command",
          "file_path": null,
          "description": "0\"\n  }\n}\n```\n\n```javascript\nimport { register } from '@tauri-apps/plugin-global-shortcut';\nawait register('CommandOrControl+Shift+C', () => {\n  console",
          "dependencies": null
        },
        {
          "language": "toml",
          "code": "# Cargo.toml\n[dependencies]\ntauri-plugin-http = \"2\"",
          "context": "plugin",
          "file_path": null,
          "description": "Use the `@tauri-apps/plugin-http` plugin instead:\n\n1",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "fn main() {\n    tauri::Builder::default()\n        .plugin(tauri_plugin_http::init())\n}",
          "context": "plugin",
          "file_path": null,
          "description": "toml\n[dependencies]\ntauri-plugin-http = \"2\"\n```\n\n2",
          "dependencies": null
        },
        {
          "language": "json",
          "code": "// package.json\n{\n  \"dependencies\": {\n    \"@tauri-apps/plugin-http\": \"^2.0.0\"\n  }\n}",
          "context": "plugin",
          "file_path": null,
          "description": "Use in JavaScript or Rust project:\n\n<Tabs syncKey=\"lang\">\n<TabItem label=\"JavaScript\">\n\n```rust\nfn main() {\n    tauri::Builder::default()",
          "dependencies": null
        },
        {
          "language": "javascript",
          "code": "import { fetch } from '@tauri-apps/plugin-http';\nconst response = await fetch(\n  'https://raw.githubusercontent.com/tauri-apps/tauri/dev/package.json'\n);",
          "context": "plugin",
          "file_path": null,
          "description": "0",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "use tauri_plugin_http::reqwest;\n\ntauri::Builder::default()\n    .plugin(tauri_plugin_http::init())\n    .setup(|app| {\n        let response_data = tauri::async_runtime::block_on(async {\n            let response = reqwest::get(\n                \"https://raw.githubusercontent.com/tauri-apps/tauri/dev/package.json\",\n            )\n            .await\n            .unwrap();\n            response.text().await\n        })?;\n        Ok(())\n    })",
          "context": "plugin",
          "file_path": null,
          "description": "com/tauri-apps/tauri/dev/package",
          "dependencies": null
        },
        {
          "language": "toml",
          "code": "# Cargo.toml\n[dependencies]\ntauri-plugin-notification = \"2\"",
          "context": "plugin",
          "file_path": null,
          "description": "Use the `@tauri-apps/plugin-notification` plugin instead:\n\n1",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "fn main() {\n    tauri::Builder::default()\n        .plugin(tauri_plugin_notification::init())\n}",
          "context": "plugin",
          "file_path": null,
          "description": "toml\n[dependencies]\ntauri-plugin-notification = \"2\"\n```\n\n2",
          "dependencies": null
        },
        {
          "language": "json",
          "code": "// package.json\n{\n  \"dependencies\": {\n    \"@tauri-apps/plugin-notification\": \"^2.0.0\"\n  }\n}",
          "context": "plugin",
          "file_path": null,
          "description": "Use in JavaScript or Rust project:\n\n<Tabs syncKey=\"lang\">\n<TabItem label=\"JavaScript\">\n\n```rust\nfn main() {\n    tauri::Builder::default()",
          "dependencies": null
        },
        {
          "language": "javascript",
          "code": "import { sendNotification } from '@tauri-apps/plugin-notification';\nsendNotification('Tauri is awesome!');",
          "context": "plugin",
          "file_path": null,
          "description": "0",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "use tauri_plugin_notification::NotificationExt;\nuse tauri::plugin::PermissionState;\n\nfn main() {\n    tauri::Builder::default()\n        .plugin(tauri_plugin_notification::init())\n        .setup(|app| {\n            if app.notification().permission_state()? == PermissionState::Unknown {\n                app.notification().request_permission()?;\n            }\n            if app.notification().permission_state()? == PermissionState::Granted {\n                app.notification()\n                    .builder()\n                    .body(\"Tauri is awesome!\")\n                    .show()?;\n            }\n            Ok(())\n        })\n}",
          "context": "plugin",
          "file_path": null,
          "description": "0",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "use tauri::menu::MenuBuilder;\n\ntauri::Builder::default()\n    .setup(|app| {\n        let menu = MenuBuilder::new(app)\n            .copy()\n            .paste()\n            .separator()\n            .undo()\n            .redo()\n            .text(\"open-url\", \"Open URL\")\n            .check(\"toggle\", \"Toggle\")\n            .icon(\"show-app\", \"Show App\", app.default_window_icon().cloned().unwrap())\n            .build()?;\n        Ok(())\n    })",
          "context": "window_management",
          "file_path": null,
          "description": "#### Use `tauri::menu::MenuBuilder`\n\nUse `tauri::menu::MenuBuilder` instead of `tauri::Menu`",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "use tauri::menu::{MenuBuilder, PredefinedMenuItem};\n\ntauri::Builder::default()\n    .setup(|app| {\n        let menu = MenuBuilder::new(app).item(&PredefinedMenuItem::copy(app)?).build()?;\n        Ok(())\n    })",
          "context": "window_management",
          "file_path": null,
          "description": "unwrap())",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "use tauri::menu::MenuItemBuilder;\n\ntauri::Builder::default()\n    .setup(|app| {\n        let toggle = MenuItemBuilder::new(\"Toggle\").accelerator(\"Ctrl+Shift+T\").build(app)?;\n        Ok(())\n    })",
          "context": "general",
          "file_path": null,
          "description": "item(&PredefinedMenuItem::copy(app, None)?)`",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "use tauri::menu::{MenuBuilder, SubmenuBuilder};\n\ntauri::Builder::default()\n    .setup(|app| {\n        let submenu = SubmenuBuilder::new(app, \"Sub\")\n            .text(\"Tauri\")\n            .separator()\n            .check(\"Is Awesome\")\n            .build()?;\n        let menu = MenuBuilder::new(app).item(&submenu).build()?;\n        Ok(())\n    })",
          "context": "general",
          "file_path": null,
          "description": "accelerator(\"Ctrl+Shift+T\")",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "use tauri::menu::{CheckMenuItemBuilder, MenuBuilder, MenuItemBuilder};\n\ntauri::Builder::default()\n    .setup(|app| {\n        let toggle = MenuItemBuilder::with_id(\"toggle\", \"Toggle\").build(app)?;\n        let check = CheckMenuItemBuilder::new(\"Mark\").build(app)?;\n        let menu = MenuBuilder::new(app).items(&[&toggle, &check]).build()?;\n\n        app.set_menu(menu)?;\n\n        app.on_menu_event(move |app, event| {\n            if event.id() == check.id() {\n                println!(\"`check` triggered, do something! is checked? {}\", check.is_checked().unwrap());\n            } else if event.id() == \"toggle\" {\n                println!(\"toggle triggered!\");\n            }\n        });\n        Ok(())\n    })",
          "context": "rust_backend",
          "file_path": null,
          "description": "#### Menu Events\n\nThe Rust `tauri::Builder::on_menu_event` API was removed",
          "dependencies": null
        },
        {
          "language": "toml",
          "code": "# Cargo.toml\n[dependencies]\ntauri-plugin-os = \"2\"",
          "context": "plugin",
          "file_path": null,
          "description": "Use the `@tauri-apps/plugin-os` plugin instead:\n\n1",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "fn main() {\n    tauri::Builder::default()\n        .plugin(tauri_plugin_os::init())\n}",
          "context": "plugin",
          "file_path": null,
          "description": "toml\n[dependencies]\ntauri-plugin-os = \"2\"\n```\n\n2",
          "dependencies": null
        },
        {
          "language": "json",
          "code": "// package.json\n{\n  \"dependencies\": {\n    \"@tauri-apps/plugin-os\": \"^2.0.0\"\n  }\n}",
          "context": "plugin",
          "file_path": null,
          "description": "Use in JavaScript or Rust project:\n\n<Tabs syncKey=\"lang\">\n<TabItem label=\"JavaScript\">\n\n```rust\nfn main() {\n    tauri::Builder::default()",
          "dependencies": null
        },
        {
          "language": "javascript",
          "code": "import { arch } from '@tauri-apps/plugin-os';\nconst architecture = await arch();",
          "context": "plugin",
          "file_path": null,
          "description": "0",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "fn main() {\n    tauri::Builder::default()\n        .plugin(tauri_plugin_os::init())\n        .setup(|app| {\n            let os_arch = tauri_plugin_os::arch();\n            Ok(())\n        })\n}",
          "context": "plugin",
          "file_path": null,
          "description": "0",
          "dependencies": null
        },
        {
          "language": "toml",
          "code": "# Cargo.toml\n[dependencies]\ntauri-plugin-process = \"2\"",
          "context": "plugin",
          "file_path": null,
          "description": "Use the `@tauri-apps/plugin-process` plugin instead:\n\n1",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "fn main() {\n    tauri::Builder::default()\n        .plugin(tauri_plugin_process::init())\n}",
          "context": "plugin",
          "file_path": null,
          "description": "toml\n[dependencies]\ntauri-plugin-process = \"2\"\n```\n\n2",
          "dependencies": null
        },
        {
          "language": "json",
          "code": "// package.json\n{\n  \"dependencies\": {\n    \"@tauri-apps/plugin-process\": \"^2.0.0\"\n  }\n}",
          "context": "plugin",
          "file_path": null,
          "description": "Use in JavaScript or Rust project:\n\n<Tabs syncKey=\"lang\">\n<TabItem label=\"JavaScript\">\n\n```rust\nfn main() {\n    tauri::Builder::default()",
          "dependencies": null
        },
        {
          "language": "javascript",
          "code": "import { exit, relaunch } from '@tauri-apps/plugin-process';\nawait exit(0);\nawait relaunch();",
          "context": "plugin",
          "file_path": null,
          "description": "0",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "fn main() {\n    tauri::Builder::default()\n        .plugin(tauri_plugin_process::init())\n        .setup(|app| {\n            // exit the app with a status code\n            app.handle().exit(1);\n            // restart the app\n            app.handle().restart();\n            Ok(())\n        })\n}",
          "context": "plugin",
          "file_path": null,
          "description": "0",
          "dependencies": null
        },
        {
          "language": "toml",
          "code": "# Cargo.toml\n[dependencies]\ntauri-plugin-shell = \"2\"",
          "context": "plugin",
          "file_path": null,
          "description": "Use the `@tauri-apps/plugin-shell` plugin instead:\n\n1",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "fn main() {\n    tauri::Builder::default()\n        .plugin(tauri_plugin_shell::init())\n}",
          "context": "plugin",
          "file_path": null,
          "description": "toml\n[dependencies]\ntauri-plugin-shell = \"2\"\n```\n\n2",
          "dependencies": null
        },
        {
          "language": "json",
          "code": "// package.json\n{\n  \"dependencies\": {\n    \"@tauri-apps/plugin-shell\": \"^2.0.0\"\n  }\n}",
          "context": "plugin",
          "file_path": null,
          "description": "Use in JavaScript or Rust project:\n\n<Tabs syncKey=\"lang\">\n<TabItem label=\"JavaScript\">\n\n```rust\nfn main() {\n    tauri::Builder::default()",
          "dependencies": null
        },
        {
          "language": "javascript",
          "code": "import { Command, open } from '@tauri-apps/plugin-shell';\nconst output = await Command.create('echo', 'message').execute();\n\nawait open('https://github.com/tauri-apps/tauri');",
          "context": "plugin",
          "file_path": null,
          "description": "0",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "use tauri_plugin_shell::ShellExt;\n\nfn main() {\n    tauri::Builder::default()\n        .plugin(tauri_plugin_shell::init())\n        .setup(|app| {\n            app.shell().open(\"https://github.com/tauri-apps/tauri\", None)?;\n            Ok(())\n        })\n}",
          "context": "command",
          "file_path": null,
          "description": "execute();\n\nawait open('https://github",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "use tauri_plugin_shell::ShellExt;\n\nfn main() {\n    tauri::Builder::default()\n        .plugin(tauri_plugin_shell::init())\n        .setup(|app| {\n            let status = tauri::async_runtime::block_on(async move { app.shell().command(\"which\").args([\"ls\"]).status().await.unwrap() });\n            println!(\"`which` finished with status: {:?}\", status.code());\n            Ok(())\n        })\n}",
          "context": "general",
          "file_path": null,
          "description": "open(\"https://github",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "use tauri_plugin_shell::ShellExt;\n\nfn main() {\n    tauri::Builder::default()\n        .plugin(tauri_plugin_shell::init())\n        .setup(|app| {\n            let output = tauri::async_runtime::block_on(async move { app.shell().command(\"echo\").args([\"TAURI\"]).output().await.unwrap() });\n            assert!(output.status.success());\n            assert_eq!(String::from_utf8(output.stdout).unwrap(), \"TAURI\");\n            Ok(())\n        })\n}",
          "context": "general",
          "file_path": null,
          "description": "unwrap() });\n            println!(\"`which` finished with status: {:?}\", status",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "use tauri_plugin_shell::{ShellExt, process::CommandEvent};\n\nfn main() {\n    tauri::Builder::default()\n        .plugin(tauri_plugin_shell::init())\n        .setup(|app| {\n            let handle = app.handle().clone();\n            tauri::async_runtime::spawn(async move {\n                let (mut rx, mut child) = handle.shell().command(\"cargo\")\n                    .args([\"tauri\", \"dev\"])\n                    .spawn()\n                    .expect(\"Failed to spawn cargo\");\n\n                let mut i = 0;\n                while let Some(event) = rx.recv().await {\n                    if let CommandEvent::Stdout(line) = event {\n                        println!(\"got: {}\", String::from_utf8(line).unwrap());\n                       i += 1;\n                       if i == 4 {\n                           child.write(\"message from Rust\\n\".as_bytes()).unwrap();\n                           i = 0;\n                       }\n                   }\n                }\n            });\n            Ok(())\n        })\n}",
          "context": "general",
          "file_path": null,
          "description": "stdout)",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "let tray = tauri::tray::TrayIconBuilder::with_id(\"my-tray\").build(app)?;",
          "context": "rust_backend",
          "file_path": null,
          "description": "The new APIs can be found in the Rust `tray` module",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "use tauri::{\n    menu::{MenuBuilder, MenuItemBuilder},\n    tray::{MouseButton, MouseButtonState, TrayIconBuilder, TrayIconEvent},\n};\n\ntauri::Builder::default()\n    .setup(|app| {\n        let toggle = MenuItemBuilder::with_id(\"toggle\", \"Toggle\").build(app)?;\n        let menu = MenuBuilder::new(app).items(&[&toggle]).build()?;\n        let tray = TrayIconBuilder::new()\n            .menu(&menu)\n            .on_menu_event(move |app, event| match event.id().as_ref() {\n                \"toggle\" => {\n                    println!(\"toggle clicked\");\n                }\n                _ => (),\n            })\n            .on_tray_icon_event(|tray, event| {\n                if let TrayIconEvent::Click {\n                        button: MouseButton::Left,\n                        button_state: MouseButtonState::Up,\n                        ..\n                } = event\n                {\n                    let app = tray.app_handle();\n                    if let Some(webview_window) = app.get_webview_window(\"main\") {\n                       let _ = webview_window.unminimize();\n                       let _ = webview_window.show();\n                       let _ = webview_window.set_focus();\n                    }\n                }\n            })\n            .build(app)?;\n\n        Ok(())\n    })",
          "context": "general",
          "file_path": null,
          "description": "#### Migrate to Menu\n\nUse `tauri::menu::Menu` instead of `tauri::SystemTrayMenu`, `tauri::menu::Submenu` instead of `tauri::SystemTraySubmenu` and `tauri::menu::PredefinedMenuItem` instead of `tauri::SystemTrayMenuItem`",
          "dependencies": null
        },
        {
          "language": "toml",
          "code": "[dependencies]\ntauri-plugin-updater = \"2\"",
          "context": "plugin",
          "file_path": null,
          "description": "To set a custom updater target with the `@tauri-apps/plugin-updater`:\n\n1",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "fn main() {\n    tauri::Builder::default()\n        .plugin(tauri_plugin_updater::Builder::new().build())\n}",
          "context": "plugin",
          "file_path": null,
          "description": "Add to cargo dependencies:\n\n```toml\n[dependencies]\ntauri-plugin-updater = \"2\"\n```\n\n2",
          "dependencies": null
        },
        {
          "language": "json",
          "code": "// package.json\n{\n  \"dependencies\": {\n    \"@tauri-apps/plugin-updater\": \"^2.0.0\"\n  }\n}",
          "context": "plugin",
          "file_path": null,
          "description": "plugin(tauri_plugin_updater::Builder::new()",
          "dependencies": null
        },
        {
          "language": "javascript",
          "code": "import { check } from '@tauri-apps/plugin-updater';\nimport { relaunch } from '@tauri-apps/plugin-process';\n\nconst update = await check();\nif (update?.available) {\n  console.log(`Update to ${update.version} available! Date: ${update.date}`);\n  console.log(`Release notes: ${update.body}`);\n  await update.downloadAndInstall();\n  // requires the `process` plugin\n  await relaunch();\n}",
          "context": "plugin",
          "file_path": null,
          "description": "0",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "use tauri_plugin_updater::UpdaterExt;\n\nfn main() {\n    tauri::Builder::default()\n        .plugin(tauri_plugin_updater::Builder::new().build())\n        .setup(|app| {\n            let handle = app.handle();\n            tauri::async_runtime::spawn(async move {\n                let response = handle.updater().check().await;\n            });\n            Ok(())\n        })\n}",
          "context": "plugin",
          "file_path": null,
          "description": "body}`);\n  await update",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "fn main() {\n    let mut updater = tauri_plugin_updater::Builder::new();\n    #[cfg(target_os = \"macos\")]\n    {\n        updater = updater.target(\"darwin-universal\");\n    }\n    tauri::Builder::default()\n        .plugin(updater.build())\n}",
          "context": "general",
          "file_path": null,
          "description": "check()",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "use tauri::{path::BaseDirectory, Manager};\n\ntauri::Builder::default()\n    .setup(|app| {\n        let home_dir_path = app.path().home_dir().expect(\"failed to get home dir\");\n\n        let path = app.path().resolve(\"path/to/something\", BaseDirectory::Config)?;\n\n        Ok(())\n  })",
          "context": "rust_backend",
          "file_path": null,
          "description": "plugin(updater",
          "dependencies": null
        }
      ],
      "common_errors": [],
      "best_practices": []
    },
    {
      "name": "workflow_prerequisites.mdx_0",
      "description": "Workflow from prerequisites.mdx",
      "steps": [
        {
          "number": 1,
          "description": "[System Dependencies](#system-dependencies)"
        },
        {
          "number": 2,
          "description": "[Rust](#rust)"
        },
        {
          "number": 3,
          "description": "[Configure for Mobile Targets](#configure-for-mobile-targets) (only required if developing for mobile)"
        },
        {
          "number": 1,
          "description": "Download the [Microsoft C++ Build Tools](https://visualstudio.microsoft.com/visual-cpp-build-tools/) installer and open it to begin installation."
        },
        {
          "number": 2,
          "description": "During installation check the \"Desktop development with C++\" option."
        },
        {
          "number": 1,
          "description": "Open **Settings** → **Apps** → **Optional features** → **More Windows features**"
        },
        {
          "number": 2,
          "description": "Locate **VBSCRIPT** in the list and ensure it's checked"
        },
        {
          "number": 3,
          "description": "Click **Next** and restart your computer if prompted"
        },
        {
          "number": 1,
          "description": "Go to the [Node.js website](https://nodejs.org), download the Long Term Support (LTS) version and install it."
        },
        {
          "number": 2,
          "description": "Check if Node was successfully installed by running:"
        },
        {
          "number": 1,
          "description": "Download and install [Android Studio from the Android Developers website](https://developer.android.com/studio)"
        },
        {
          "number": 2,
          "description": "Set the `JAVA_HOME` environment variable:"
        },
        {
          "number": 3,
          "description": "Use the SDK Manager in Android Studio to install the following:"
        },
        {
          "number": 4,
          "description": "Set `ANDROID_HOME` and `NDK_HOME` environment variables."
        },
        {
          "number": 5,
          "description": "Add the Android targets with `rustup`:"
        },
        {
          "number": 1,
          "description": "Add the iOS targets with `rustup` in Terminal:"
        },
        {
          "number": 2,
          "description": "Install [Homebrew](https://brew.sh):"
        },
        {
          "number": 3,
          "description": "Install [Cocoapods](https://cocoapods.org) using Homebrew:"
        }
      ],
      "prerequisites": [],
      "code_snippets": [
        {
          "language": "sh",
          "code": "sudo apt update\nsudo apt install libwebkit2gtk-4.1-dev \\\n  build-essential \\\n  curl \\\n  wget \\\n  file \\\n  libxdo-dev \\\n  libssl-dev \\\n  libayatana-appindicator3-dev \\\n  librsvg2-dev",
          "context": "general",
          "file_path": null,
          "description": "These may be different depending on your distribution but we've included some popular distributions below to help you get setup",
          "dependencies": null
        },
        {
          "language": "sh",
          "code": "sudo pacman -Syu\nsudo pacman -S --needed \\\n  webkit2gtk-4.1 \\\n  base-devel \\\n  curl \\\n  wget \\\n  file \\\n  openssl \\\n  appmenu-gtk-module \\\n  libappindicator-gtk3 \\\n  librsvg \\\n  xdotool",
          "context": "general",
          "file_path": null,
          "description": "<Tabs syncKey=\"distro\">\n  <TabItem label=\"Debian\">\n\n```sh\nsudo apt update\nsudo apt install libwebkit2gtk-4",
          "dependencies": null
        },
        {
          "language": "sh",
          "code": "sudo dnf check-update\nsudo dnf install webkit2gtk4.1-devel \\\n  openssl-devel \\\n  curl \\\n  wget \\\n  file \\\n  libappindicator-gtk3-devel \\\n  librsvg2-devel \\\n  libxdo-devel\nsudo dnf group install \"c-development\"",
          "context": "general",
          "file_path": null,
          "description": "1-dev \\\n  build-essential \\\n  curl \\\n  wget \\\n  file \\\n  libxdo-dev \\\n  libssl-dev \\\n  libayatana-appindicator3-dev \\\n  librsvg2-dev\n```\n\n  </TabItem>\n  <TabItem label=\"Arch\">\n\n```sh\nsudo pacman -Syu\nsudo pacman -S --needed \\\n  webkit2gtk-4",
          "dependencies": null
        },
        {
          "language": "sh",
          "code": "sudo emerge --ask \\\n  net-libs/webkit-gtk:4.1 \\\n  dev-libs/libappindicator \\\n  net-misc/curl \\\n  net-misc/wget \\\n  sys-apps/file",
          "context": "general",
          "file_path": null,
          "description": "1 \\\n  base-devel \\\n  curl \\\n  wget \\\n  file \\\n  openssl \\\n  appmenu-gtk-module \\\n  libappindicator-gtk3 \\\n  librsvg \\\n  xdotool\n```\n\n  </TabItem>\n  <TabItem label=\"Fedora\">\n\n```sh\nsudo dnf check-update\nsudo dnf install webkit2gtk4",
          "dependencies": null
        },
        {
          "language": "sh",
          "code": "sudo zypper up\nsudo zypper in webkit2gtk3-devel \\\n  libopenssl-devel \\\n  curl \\\n  wget \\\n  file \\\n  libappindicator3-1 \\\n  librsvg-devel\nsudo zypper in -t pattern devel_basis",
          "context": "general",
          "file_path": null,
          "description": "1-devel \\\n  openssl-devel \\\n  curl \\\n  wget \\\n  file \\\n  libappindicator-gtk3-devel \\\n  librsvg2-devel \\\n  libxdo-devel\nsudo dnf group install \"c-development\"\n```\n\n  </TabItem>\n  <TabItem label=\"Gentoo\">\n\n```sh\nsudo emerge --ask \\\n  net-libs/webkit-gtk:4",
          "dependencies": null
        },
        {
          "language": "sh",
          "code": "sudo apk add \\\n  build-base \\\n  webkit2gtk \\\n  curl \\\n  wget \\\n  file \\\n  openssl \\\n  libayatana-appindicator-dev \\\n  librsvg",
          "context": "general",
          "file_path": null,
          "description": "devel\nsudo dnf group install \"c-development\"\n```\n\n  </TabItem>\n  <TabItem label=\"Gentoo\">\n\n```sh\nsudo emerge --ask \\\n  net-libs/webkit-gtk:4",
          "dependencies": null
        },
        {
          "language": "sh",
          "code": "xcode-select --install",
          "context": "command",
          "file_path": null,
          "description": "Be sure to launch Xcode after installing so that it can finish setting up",
          "dependencies": null
        },
        {
          "language": "sh",
          "code": "curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh",
          "context": "command",
          "file_path": null,
          "description": "<Tabs syncKey=\"OS\">\n  <TabItem label=\"Linux and macOS\" class=\"content\">\n\nInstall via [`rustup`](https://github",
          "dependencies": null
        },
        {
          "language": "powershell",
          "code": "winget install --id Rustlang.Rustup",
          "context": "command",
          "file_path": null,
          "description": "org/tools/install to install `rustup`",
          "dependencies": null
        },
        {
          "language": "powershell",
          "code": "rustup default stable-msvc",
          "context": "command",
          "file_path": null,
          "description": "Depending on your system it should be either `x86_64-pc-windows-msvc`, `i686-pc-windows-msvc`, or `aarch64-pc-windows-msvc`",
          "dependencies": null
        },
        {
          "language": "sh",
          "code": "node -v\n# v20.10.0\nnpm -v\n# 10.2.3",
          "context": "frontend_integration",
          "file_path": null,
          "description": "2",
          "dependencies": null
        },
        {
          "language": "sh",
          "code": "export JAVA_HOME=/opt/android-studio/jbr",
          "context": "general",
          "file_path": null,
          "description": "com/studio)\n2",
          "dependencies": null
        },
        {
          "language": "sh",
          "code": "export JAVA_HOME=\"/Applications/Android Studio.app/Contents/jbr/Contents/Home\"",
          "context": "general",
          "file_path": null,
          "description": "com/studio)\n2",
          "dependencies": null
        },
        {
          "language": "ps",
          "code": "[System.Environment]::SetEnvironmentVariable(\"JAVA_HOME\", \"C:\\Program Files\\Android\\Android Studio\\jbr\", \"User\")",
          "context": "window_management",
          "file_path": null,
          "description": "Set the `JAVA_HOME` environment variable:\n\n{/* TODO: Can this be done in the 4th step? */}\n\n<Tabs syncKey=\"prereqs\">\n<TabItem label=\"Linux\">\n\n```sh\nexport JAVA_HOME=/opt/android-studio/jbr\n```\n\n</TabItem>\n<TabItem label=\"macOS\">\n\n```sh\nexport JAVA_HOME=\"/Applications/Android Studio",
          "dependencies": null
        },
        {
          "language": "sh",
          "code": "export ANDROID_HOME=\"$HOME/Android/Sdk\"\nexport NDK_HOME=\"$ANDROID_HOME/ndk/$(ls -1 $ANDROID_HOME/ndk)\"",
          "context": "general",
          "file_path": null,
          "description": "Set `ANDROID_HOME` and `NDK_HOME` environment variables",
          "dependencies": null
        },
        {
          "language": "sh",
          "code": "export ANDROID_HOME=\"$HOME/Library/Android/sdk\"\nexport NDK_HOME=\"$ANDROID_HOME/ndk/$(ls -1 $ANDROID_HOME/ndk)\"",
          "context": "general",
          "file_path": null,
          "description": "Set `ANDROID_HOME` and `NDK_HOME` environment variables",
          "dependencies": null
        },
        {
          "language": "ps",
          "code": "[System.Environment]::SetEnvironmentVariable(\"ANDROID_HOME\", \"$env:LocalAppData\\Android\\Sdk\", \"User\")\n$VERSION = Get-ChildItem -Name \"$env:LocalAppData\\Android\\Sdk\\ndk\" | Select-Object -Last 1\n[System.Environment]::SetEnvironmentVariable(\"NDK_HOME\", \"$env:LocalAppData\\Android\\Sdk\\ndk\\$VERSION\", \"User\")",
          "context": "window_management",
          "file_path": null,
          "description": "Set `ANDROID_HOME` and `NDK_HOME` environment variables",
          "dependencies": null
        },
        {
          "language": "ps",
          "code": "[System.Environment]::GetEnvironmentVariables(\"User\").GetEnumerator() | % { Set-Item -Path \"Env:\\$($_.key)\" -Value $_.value }",
          "context": "general",
          "file_path": null,
          "description": "ironmentVariable(\"ANDROID_HOME\", \"$env:LocalAppData\\Android\\Sdk\", \"User\")\n$VERSION = Get-ChildItem -Name \"$env:LocalAppData\\Android\\Sdk\\ndk\" | Select-Object -Last 1\n[System",
          "dependencies": null
        },
        {
          "language": "sh",
          "code": "rustup target add aarch64-linux-android armv7-linux-androideabi i686-linux-android x86_64-linux-android",
          "context": "rust_backend",
          "file_path": null,
          "description": "value }\n```\n\n:::\n\n</TabItem>\n\n</Tabs>\n\n5",
          "dependencies": null
        },
        {
          "language": "sh",
          "code": "rustup target add aarch64-apple-ios x86_64-apple-ios aarch64-apple-ios-sim",
          "context": "command",
          "file_path": null,
          "description": ":::\n\n1",
          "dependencies": null
        },
        {
          "language": "sh",
          "code": "/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"",
          "context": "rust_backend",
          "file_path": null,
          "description": "Install [Homebrew](https://brew",
          "dependencies": null
        },
        {
          "language": "sh",
          "code": "brew install cocoapods",
          "context": "general",
          "file_path": null,
          "description": "Install [Cocoapods](https://cocoapods",
          "dependencies": null
        }
      ],
      "common_errors": [],
      "best_practices": []
    },
    {
      "name": "workflow_sidecar-nodejs.mdx_23ac22ff",
      "description": "Step-by-step guide from sidecar-nodejs.mdx",
      "steps": [
        {
          "description": "##### Initialize Sidecar Project\n\n    Let's create a new Node.js project to contain our sidecar implementation.\n    Create a new directory **in your Tauri application root folder** (in this example we",
          "details": "##### Initialize Sidecar Project\n\n    Let's create a new Node.js project to contain our sidecar implementation.\n    Create a new directory **in your Tauri application root folder** (in this example we will call it `sidecar-app`)\n    and run the `init` command of your preferred Node.js package manager inside the directory:\n\n    <CommandTabs npm=\"npm init\" yarn=\"yarn init\" pnpm=\"pnpm init\" />\n\n    We will compile our Node.js application to a self container binary using [pkg].\n    Let's install it as a development dependency:\n\n    <CommandTabs\n      npm=\"npm add @yao-pkg/pkg --save-dev\"\n      yarn=\"yarn add @yao-pkg/pkg --dev\"\n      pnpm=\"pnpm add @yao-pkg/pkg --save-dev\"\n    />"
        },
        {
          "description": "##### Write Sidecar Logic\n\n    Now we can start writing JavaScript code that will be executed by our Tauri application.\n\n    In this example we will process a command from the command line argmuents a",
          "details": "##### Write Sidecar Logic\n\n    Now we can start writing JavaScript code that will be executed by our Tauri application.\n\n    In this example we will process a command from the command line argmuents and write output to stdout,\n    which means our process will be short lived and only handle a single command at a time.\n    If your application must be long lived, consider using alternative inter-process communication systems.\n\n    Let's create a `index.js` file in our `sidecar-app` directory and write a basic Node.js app:\n\n    ```js title=sidecar-app/index.js\n    const command = process.argv[2];\n\n    switch (command) {\n      case 'ping':\n        const message = process.argv[3];\n        console.log(`pong, ${message}`);\n        break;\n      default:\n        console.error(`unknown command ${command}`);\n        process.exit(1);\n    }\n    ```"
        },
        {
          "description": "##### Package the Sidecar\n\n    To package our Node.js application to a self contained binary, we can run the following `pkg` command:\n\n    <CommandTabs\n      npm=\"npm run pkg -- --output app\"\n      ya",
          "details": "##### Package the Sidecar\n\n    To package our Node.js application to a self contained binary, we can run the following `pkg` command:\n\n    <CommandTabs\n      npm=\"npm run pkg -- --output app\"\n      yarn=\"yarn pkg --output app\"\n      pnpm=\"pnpm pkg --output app\"\n    />\n\n    This will create the `sidecar-app/app` binary on Linux and macOS, and a `sidecar-app/app.exe` executable on Windows.\n    To rename this file to the expected Tauri sidecar filename, we can use the following Node.js script:\n\n    ```js\n    import { execSync } from 'child_process';\n    import fs from 'fs';\n\n    const ext = process.platform === 'win32' ? '.exe' : '';\n\n    const rustInfo = execSync('rustc -vV');\n    const targetTriple = /host: (\\S+)/g.exec(rustInfo)[1];\n    if (!targetTriple) {\n      console.error('Failed to determine platform target triple');\n    }\n    fs.renameSync(\n      `app${ext}`,\n      `../src-tauri/binaries/app-${targetTriple}${ext}`\n    );\n    ```"
        },
        {
          "description": "##### Configure the Sidecar in the Tauri Application\n\n    Now that we have our Node.js application ready, we can connect it to our Tauri application\n    by configuring the [`bundle > externalBin`] arr",
          "details": "##### Configure the Sidecar in the Tauri Application\n\n    Now that we have our Node.js application ready, we can connect it to our Tauri application\n    by configuring the [`bundle > externalBin`] array:\n\n    ```json title=\"src-tauri/tauri.conf.json\"\n    {\n      \"bundle\": {\n        \"externalBin\": [\"binaries/app\"]\n      }\n    }\n    ```\n\n    The Tauri CLI will handle the bundling of the sidecar binary as long as it exists as `src-tauri/binaries/app-<target-triple>`."
        },
        {
          "description": "##### Execute the Sidecar\n\n    We can run the sidecar binary either from Rust code or directly from JavaScript.\n\n    <Tabs syncKey=\"lang\">\n\n      <TabItem label=\"JavaScript\">\n\n        Let's execute th",
          "details": "##### Execute the Sidecar\n\n    We can run the sidecar binary either from Rust code or directly from JavaScript.\n\n    <Tabs syncKey=\"lang\">\n\n      <TabItem label=\"JavaScript\">\n\n        Let's execute the `ping` command in the Node.js sidecar directly:\n\n        ```javascript\n        import { Command } from '@tauri-apps/plugin-shell';\n\n        const message = 'Tauri';\n\n        const command = Command.sidecar('binaries/app', ['ping', message]);\n        const output = await command.execute();\n        const response = output.stdout;\n        ```\n\n      </TabItem>\n\n      <TabItem label=\"Rust\">\n\n        Let's pipe a `ping` Tauri command to the Node.js sidecar:\n\n        ```rust\n        #[tauri::command]\n        async fn ping(app: tauri::AppHandle, message: String) -> String {\n          let sidecar_command = app\n            .shell()\n            .sidecar(\"app\")\n            .unwrap()\n            .arg(\"ping\")\n            .arg(message);\n          let output = sidecar_command.output().unwrap();\n          let response = String::from_utf8(output.stdout).unwrap();\n          response\n        }\n        ```\n\n      </TabItem>\n\n    </Tabs>"
        }
      ],
      "prerequisites": [],
      "code_snippets": [
        {
          "language": "js",
          "code": "const command = process.argv[2];\n\n    switch (command) {\n      case 'ping':\n        const message = process.argv[3];\n        console.log(`pong, ${message}`);\n        break;\n      default:\n        console.error(`unknown command ${command}`);\n        process.exit(1);\n    }",
          "context": "general",
          "file_path": "sidecar-app/index.js",
          "description": "js` file in our `sidecar-app` directory and write a basic Node",
          "dependencies": null
        },
        {
          "language": "js",
          "code": "import { execSync } from 'child_process';\n    import fs from 'fs';\n\n    const ext = process.platform === 'win32' ? '.exe' : '';\n\n    const rustInfo = execSync('rustc -vV');\n    const targetTriple = /host: (\\S+)/g.exec(rustInfo)[1];\n    if (!targetTriple) {\n      console.error('Failed to determine platform target triple');\n    }\n    fs.renameSync(\n      `app${ext}`,\n      `../src-tauri/binaries/app-${targetTriple}${ext}`\n    );",
          "context": "window_management",
          "file_path": null,
          "description": "To rename this file to the expected Tauri sidecar filename, we can use the following Node",
          "dependencies": null
        },
        {
          "language": "json",
          "code": "{\n      \"bundle\": {\n        \"externalBin\": [\"binaries/app\"]\n      }\n    }",
          "context": "general",
          "file_path": "src-tauri/tauri.conf.json",
          "description": "##### Configure the Sidecar in the Tauri Application\n\n    Now that we have our Node",
          "dependencies": null
        },
        {
          "language": "javascript",
          "code": "import { Command } from '@tauri-apps/plugin-shell';\n\n        const message = 'Tauri';\n\n        const command = Command.sidecar('binaries/app', ['ping', message]);\n        const output = await command.execute();\n        const response = output.stdout;",
          "context": "command",
          "file_path": null,
          "description": "<Tabs syncKey=\"lang\">\n\n      <TabItem label=\"JavaScript\">\n\n        Let's execute the `ping` command in the Node",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "#[tauri::command]\n        async fn ping(app: tauri::AppHandle, message: String) -> String {\n          let sidecar_command = app\n            .shell()\n            .sidecar(\"app\")\n            .unwrap()\n            .arg(\"ping\")\n            .arg(message);\n          let output = sidecar_command.output().unwrap();\n          let response = String::from_utf8(output.stdout).unwrap();\n          response\n        }",
          "context": "command",
          "file_path": null,
          "description": "stdout;\n        ```\n\n      </TabItem>\n\n      <TabItem label=\"Rust\">\n\n        Let's pipe a `ping` Tauri command to the Node",
          "dependencies": null
        }
      ],
      "common_errors": [],
      "best_practices": []
    },
    {
      "name": "workflow_sidecar-nodejs.mdx_1",
      "description": "Workflow from sidecar-nodejs.mdx",
      "steps": [
        {
          "number": 1,
          "description": "##### Initialize Sidecar Project"
        },
        {
          "number": 1,
          "description": "##### Write Sidecar Logic"
        },
        {
          "number": 1,
          "description": "##### Package the Sidecar"
        },
        {
          "number": 1,
          "description": "##### Configure the Sidecar in the Tauri Application"
        },
        {
          "number": 1,
          "description": "##### Execute the Sidecar"
        }
      ],
      "prerequisites": [],
      "code_snippets": [
        {
          "language": "js",
          "code": "const command = process.argv[2];\n\n    switch (command) {\n      case 'ping':\n        const message = process.argv[3];\n        console.log(`pong, ${message}`);\n        break;\n      default:\n        console.error(`unknown command ${command}`);\n        process.exit(1);\n    }",
          "context": "general",
          "file_path": "sidecar-app/index.js",
          "description": "js` file in our `sidecar-app` directory and write a basic Node",
          "dependencies": null
        },
        {
          "language": "js",
          "code": "import { execSync } from 'child_process';\n    import fs from 'fs';\n\n    const ext = process.platform === 'win32' ? '.exe' : '';\n\n    const rustInfo = execSync('rustc -vV');\n    const targetTriple = /host: (\\S+)/g.exec(rustInfo)[1];\n    if (!targetTriple) {\n      console.error('Failed to determine platform target triple');\n    }\n    fs.renameSync(\n      `app${ext}`,\n      `../src-tauri/binaries/app-${targetTriple}${ext}`\n    );",
          "context": "window_management",
          "file_path": null,
          "description": "To rename this file to the expected Tauri sidecar filename, we can use the following Node",
          "dependencies": null
        },
        {
          "language": "json",
          "code": "{\n      \"bundle\": {\n        \"externalBin\": [\"binaries/app\"]\n      }\n    }",
          "context": "general",
          "file_path": "src-tauri/tauri.conf.json",
          "description": "##### Configure the Sidecar in the Tauri Application\n\n    Now that we have our Node",
          "dependencies": null
        },
        {
          "language": "javascript",
          "code": "import { Command } from '@tauri-apps/plugin-shell';\n\n        const message = 'Tauri';\n\n        const command = Command.sidecar('binaries/app', ['ping', message]);\n        const output = await command.execute();\n        const response = output.stdout;",
          "context": "command",
          "file_path": null,
          "description": "<Tabs syncKey=\"lang\">\n\n      <TabItem label=\"JavaScript\">\n\n        Let's execute the `ping` command in the Node",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "#[tauri::command]\n        async fn ping(app: tauri::AppHandle, message: String) -> String {\n          let sidecar_command = app\n            .shell()\n            .sidecar(\"app\")\n            .unwrap()\n            .arg(\"ping\")\n            .arg(message);\n          let output = sidecar_command.output().unwrap();\n          let response = String::from_utf8(output.stdout).unwrap();\n          response\n        }",
          "context": "command",
          "file_path": null,
          "description": "stdout;\n        ```\n\n      </TabItem>\n\n      <TabItem label=\"Rust\">\n\n        Let's pipe a `ping` Tauri command to the Node",
          "dependencies": null
        }
      ],
      "common_errors": [],
      "best_practices": []
    },
    {
      "name": "workflow_splashscreen.mdx_d8e5e725",
      "description": "Step-by-step guide from splashscreen.mdx",
      "steps": [
        {
          "description": "##### Install dependencies and run the project\n\n   Before you start developing any project it's important to build and run the initial template, just to validate your setup is working as intended.\n\n  ",
          "details": "##### Install dependencies and run the project\n\n   Before you start developing any project it's important to build and run the initial template, just to validate your setup is working as intended.\n\n    <ShowSolution>\n    ```sh frame=none\n    # Make sure you're in the right directory\n    cd splashscreen-lab\n    # Install dependencies\n    pnpm install\n    # Build and run the app\n    pnpm tauri dev\n    ```\n    <Image src={step_1} alt=\"Successful run of the created template app.\"/>\n    </ShowSolution>"
        },
        {
          "description": "##### Register new windows in `tauri.conf.json`\n\n   The easiest way of adding new windows is by adding them directly to `tauri.conf.json`. You can also create them dynamically at startup,\n   but for t",
          "details": "##### Register new windows in `tauri.conf.json`\n\n   The easiest way of adding new windows is by adding them directly to `tauri.conf.json`. You can also create them dynamically at startup,\n   but for the sake of simplicity lets just register them instead. Make sure you have a window with the label `main` that's being created as a hidden window and a window with the label `splashscreen` that's created as being shown directly. You can leave all other options as their defaults, or tweak them based on preference.\n\n    <ShowSolution>\n    ```json\n    // src-tauri/tauri.conf.json\n    {\n        \"windows\": [\n            {\n                \"label\": \"main\",\n                \"visible\": false\n            },\n            {\n                \"label\": \"splashscreen\",\n                \"url\": \"/splashscreen\"\n            }\n        ]\n    }\n    ```\n    </ShowSolution>"
        },
        {
          "description": "##### Create a new page to host your splashscreen\n\n   Before you begin you'll need to have some content to show. How you develop new pages depend on your chosen framework,\n   most have the concept of ",
          "details": "##### Create a new page to host your splashscreen\n\n   Before you begin you'll need to have some content to show. How you develop new pages depend on your chosen framework,\n   most have the concept of a \"router\" that handles page navigation which should work just like normal in Tauri, in which case\n   you just create a new splashscreen page. Or as we're going to be doing here, create a new `splashscreen.html` file to host the contents.\n\n   What's important here is that you can navigate to a `/splashscreen` URL and be shown the contents you want for your splashscreen. Try running the app again after this step!\n\n    <ShowSolution>\n    ```html\n    // /splashscreen.html\n    <!doctype html>\n    <html lang=\"en\">\n    <head>\n        <meta charset=\"UTF-8\" />\n        <link rel=\"stylesheet\" href=\"/src/styles.css\" />\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n        <title>Tauri App</title>\n    </head>\n    <body>\n        <div class=\"container\">\n            <h1>Tauri used Splash!</h1>\n            <div class=\"row\">\n                <h5>It was super effective!</h5>\n            </div>\n        </div>\n    </body>\n    </html>\n    ```\n    <Image src={step_3} alt=\"The splashscreen we just created.\"/>\n    </ShowSolution>"
        },
        {
          "description": "##### Start some setup tasks\n\n    Since splashscreens are generally intended to be used for the sake of hiding heavy setup related tasks, lets fake giving the app something heavy to do, some in the fr",
          "details": "##### Start some setup tasks\n\n    Since splashscreens are generally intended to be used for the sake of hiding heavy setup related tasks, lets fake giving the app something heavy to do, some in the frontend and some in the backend.\n\n    To fake heavy setup in the frontend we're going to be using a simple `setTimeout` function.\n    \n    The easiest way to fake heavy operations in the backend is by using the Tokio crate, which is the Rust crate that Tauri uses in the backend to provide an asynchronous runtime. While Tauri provides the runtime there are various utilities that Tauri doesn't re-export from it, so we'll need to add the crate to our project in order to access them. This is a perfectly normal practice within the Rust ecosystem.\n\n    Don't use `std::thread::sleep` in async functions, they run cooperatively in a concurrent environment not in parallel, meaning that if you sleep the thread instead of the Tokio task you'll be locking all tasks scheduled to run on that thread from being executed, causing your app to freeze.\n\n    <ShowSolution>\n    ```sh frame=none\n    # Run this command where the `Cargo.toml` file is\n    cd src-tauri\n    # Add the Tokio crate\n    cargo add tokio\n    # Optionally go back to the top folder to keep developing\n    # `tauri dev` can figure out where to run automatically\n    cd ..\n    ```\n\n    ```javascript\n    // src/main.ts\n    // These contents can be copy-pasted below the existing code, don't replace the entire file!!\n\n    // Utility function to implement a sleep function in TypeScript\n    function sleep(seconds: number): Promise<void> {\n        return new Promise(resolve => setTimeout(resolve, seconds * 1000));\n    }\n\n    // Setup function\n    async function setup() {\n        // Fake perform some really heavy setup task\n        console.log('Performing really heavy frontend setup task...')\n        await sleep(3);\n        console.log('Frontend setup task complete!')\n        // Set the frontend task as being completed\n        invoke('set_complete', {task: 'frontend'})\n    }\n\n    // Effectively a JavaScript main function\n    window.addEventListener(\"DOMContentLoaded\", () => {\n        setup()\n    });\n    ```\n\n    ```rust\n    // /src-tauri/src/lib.rs\n    // Import functionalities we'll be using\n    use std::sync::Mutex;\n    use tauri::async_runtime::spawn;\n    use tauri::{AppHandle, Manager, State};\n    use tokio::time::{sleep, Duration};\n\n    // Create a struct we'll use to track the completion of\n    // setup related tasks\n    struct SetupState {\n        frontend_task: bool,\n        backend_task: bool,\n    }\n\n    // Our main entrypoint in a version 2 mobile compatible app\n    #[cfg_attr(mobile, tauri::mobile_entry_point)]\n    pub fn run() {\n        // Don't write code before Tauri starts, write it in the\n        // setup hook instead!\n        tauri::Builder::default()\n            // Register a `State` to be managed by Tauri\n            // We need write access to it so we wrap it in a `Mutex`\n            .manage(Mutex::new(SetupState {\n                frontend_task: false,\n                backend_task: false,\n            }))\n            // Add a command we can use to check\n            .invoke_handler(tauri::generate_handler![greet, set_complete])\n            // Use the setup hook to execute setup related tasks\n            // Runs before the main loop, so no windows are yet created\n            .setup(|app| {\n                // Spawn setup as a non-blocking task so the windows can be\n                // created and ran while it executes\n                spawn(setup(app.handle().clone()));\n                // The hook expects an Ok result\n                Ok(())\n            })\n            // Run the app\n            .run(tauri::generate_context!())\n            .expect(\"error while running tauri application\");\n    }\n\n    #[tauri::command]\n    fn greet(name: String) -> String {\n        format!(\"Hello {name} from Rust!\")\n    }\n\n    // A custom task for setting the state of a setup task\n    #[tauri::command]\n    async fn set_complete(\n        app: AppHandle,\n        state: State<'_, Mutex<SetupState>>,\n        task: String,\n    ) -> Result<(), ()> {\n        // Lock the state without write access\n        let mut state_lock = state.lock().unwrap();\n        match task.as_str() {\n            \"frontend\" => state_lock.frontend_task = true,\n            \"backend\" => state_lock.backend_task = true,\n            _ => panic!(\"invalid task completed!\"),\n        }\n        // Check if both tasks are completed\n        if state_lock.backend_task && state_lock.frontend_task {\n            // Setup is complete, we can close the splashscreen\n            // and unhide the main window!\n            let splash_window = app.get_webview_window(\"splashscreen\").unwrap();\n            let main_window = app.get_webview_window(\"main\").unwrap();\n            splash_window.close().unwrap();\n            main_window.show().unwrap();\n        }\n        Ok(())\n    }\n\n    // An async function that does some heavy setup task\n    async fn setup(app: AppHandle) -> Result<(), ()> {\n        // Fake performing some heavy action for 3 seconds\n        println!(\"Performing really heavy backend setup task...\");\n        sleep(Duration::from_secs(3)).await;\n        println!(\"Backend setup task completed!\");\n        // Set the backend task as being completed\n        // Commands can be ran as regular functions as long as you take\n        // care of the input arguments yourself\n        set_complete(\n            app.clone(),\n            app.state::<Mutex<SetupState>>(),\n            \"backend\".to_string(),\n        )\n        .await?;\n        Ok(())\n    }\n    ```\n    </ShowSolution>"
        },
        {
          "description": "##### Run the application\n\n   You should now see a splashscreen window pop up, both the frontend and backend will perform their respective heavy 3 second setup tasks, after which the splashscreen disa",
          "details": "##### Run the application\n\n   You should now see a splashscreen window pop up, both the frontend and backend will perform their respective heavy 3 second setup tasks, after which the splashscreen disappears and the main window is shown!"
        }
      ],
      "prerequisites": [],
      "code_snippets": [
        {
          "language": "json",
          "code": "// src-tauri/tauri.conf.json\n    {\n        \"windows\": [\n            {\n                \"label\": \"main\",\n                \"visible\": false\n            },\n            {\n                \"label\": \"splashscreen\",\n                \"url\": \"/splashscreen\"\n            }\n        ]\n    }",
          "context": "window_management",
          "file_path": null,
          "description": "You can leave all other options as their defaults, or tweak them based on preference",
          "dependencies": null
        },
        {
          "language": "html",
          "code": "// /splashscreen.html\n    <!doctype html>\n    <html lang=\"en\">\n    <head>\n        <meta charset=\"UTF-8\" />\n        <link rel=\"stylesheet\" href=\"/src/styles.css\" />\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n        <title>Tauri App</title>\n    </head>\n    <body>\n        <div class=\"container\">\n            <h1>Tauri used Splash!</h1>\n            <div class=\"row\">\n                <h5>It was super effective!</h5>\n            </div>\n        </div>\n    </body>\n    </html>",
          "context": "general",
          "file_path": null,
          "description": "What's important here is that you can navigate to a `/splashscreen` URL and be shown the contents you want for your splashscreen",
          "dependencies": null
        },
        {
          "language": "javascript",
          "code": "// src/main.ts\n    // These contents can be copy-pasted below the existing code, don't replace the entire file!!\n\n    // Utility function to implement a sleep function in TypeScript\n    function sleep(seconds: number): Promise<void> {\n        return new Promise(resolve => setTimeout(resolve, seconds * 1000));\n    }\n\n    // Setup function\n    async function setup() {\n        // Fake perform some really heavy setup task\n        console.log('Performing really heavy frontend setup task...')\n        await sleep(3);\n        console.log('Frontend setup task complete!')\n        // Set the frontend task as being completed\n        invoke('set_complete', {task: 'frontend'})\n    }\n\n    // Effectively a JavaScript main function\n    window.addEventListener(\"DOMContentLoaded\", () => {\n        setup()\n    });",
          "context": "general",
          "file_path": null,
          "description": "",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "// /src-tauri/src/lib.rs\n    // Import functionalities we'll be using\n    use std::sync::Mutex;\n    use tauri::async_runtime::spawn;\n    use tauri::{AppHandle, Manager, State};\n    use tokio::time::{sleep, Duration};\n\n    // Create a struct we'll use to track the completion of\n    // setup related tasks\n    struct SetupState {\n        frontend_task: bool,\n        backend_task: bool,\n    }\n\n    // Our main entrypoint in a version 2 mobile compatible app\n    #[cfg_attr(mobile, tauri::mobile_entry_point)]\n    pub fn run() {\n        // Don't write code before Tauri starts, write it in the\n        // setup hook instead!\n        tauri::Builder::default()\n            // Register a `State` to be managed by Tauri\n            // We need write access to it so we wrap it in a `Mutex`\n            .manage(Mutex::new(SetupState {\n                frontend_task: false,\n                backend_task: false,\n            }))\n            // Add a command we can use to check\n            .invoke_handler(tauri::generate_handler![greet, set_complete])\n            // Use the setup hook to execute setup related tasks\n            // Runs before the main loop, so no windows are yet created\n            .setup(|app| {\n                // Spawn setup as a non-blocking task so the windows can be\n                // created and ran while it executes\n                spawn(setup(app.handle().clone()));\n                // The hook expects an Ok result\n                Ok(())\n            })\n            // Run the app\n            .run(tauri::generate_context!())\n            .expect(\"error while running tauri application\");\n    }\n\n    #[tauri::command]\n    fn greet(name: String) -> String {\n        format!(\"Hello {name} from Rust!\")\n    }\n\n    // A custom task for setting the state of a setup task\n    #[tauri::command]\n    async fn set_complete(\n        app: AppHandle,\n        state: State<'_, Mutex<SetupState>>,\n        task: String,\n    ) -> Result<(), ()> {\n        // Lock the state without write access\n        let mut state_lock = state.lock().unwrap();\n        match task.as_str() {\n            \"frontend\" => state_lock.frontend_task = true,\n            \"backend\" => state_lock.backend_task = true,\n            _ => panic!(\"invalid task completed!\"),\n        }\n        // Check if both tasks are completed\n        if state_lock.backend_task && state_lock.frontend_task {\n            // Setup is complete, we can close the splashscreen\n            // and unhide the main window!\n            let splash_window = app.get_webview_window(\"splashscreen\").unwrap();\n            let main_window = app.get_webview_window(\"main\").unwrap();\n            splash_window.close().unwrap();\n            main_window.show().unwrap();\n        }\n        Ok(())\n    }\n\n    // An async function that does some heavy setup task\n    async fn setup(app: AppHandle) -> Result<(), ()> {\n        // Fake performing some heavy action for 3 seconds\n        println!(\"Performing really heavy backend setup task...\");\n        sleep(Duration::from_secs(3)).await;\n        println!(\"Backend setup task completed!\");\n        // Set the backend task as being completed\n        // Commands can be ran as regular functions as long as you take\n        // care of the input arguments yourself\n        set_complete(\n            app.clone(),\n            app.state::<Mutex<SetupState>>(),\n            \"backend\".to_string(),\n        )\n        .await?;\n        Ok(())\n    }",
          "context": "window_management",
          "file_path": null,
          "description": "log('Frontend setup task complete!')\n        // Set the frontend task as being completed\n        invoke('set_complete', {task: 'frontend'})\n    }\n\n    // Effectively a JavaScript main function\n    window",
          "dependencies": null
        }
      ],
      "common_errors": [],
      "best_practices": []
    },
    {
      "name": "workflow_splashscreen.mdx_1",
      "description": "Workflow from splashscreen.mdx",
      "steps": [
        {
          "number": 1,
          "description": "##### Install dependencies and run the project"
        },
        {
          "number": 1,
          "description": "##### Register new windows in `tauri.conf.json`"
        },
        {
          "number": 1,
          "description": "##### Create a new page to host your splashscreen"
        },
        {
          "number": 1,
          "description": "##### Start some setup tasks"
        },
        {
          "number": 1,
          "description": "##### Run the application"
        }
      ],
      "prerequisites": [],
      "code_snippets": [
        {
          "language": "json",
          "code": "// src-tauri/tauri.conf.json\n    {\n        \"windows\": [\n            {\n                \"label\": \"main\",\n                \"visible\": false\n            },\n            {\n                \"label\": \"splashscreen\",\n                \"url\": \"/splashscreen\"\n            }\n        ]\n    }",
          "context": "window_management",
          "file_path": null,
          "description": "You can leave all other options as their defaults, or tweak them based on preference",
          "dependencies": null
        },
        {
          "language": "html",
          "code": "// /splashscreen.html\n    <!doctype html>\n    <html lang=\"en\">\n    <head>\n        <meta charset=\"UTF-8\" />\n        <link rel=\"stylesheet\" href=\"/src/styles.css\" />\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n        <title>Tauri App</title>\n    </head>\n    <body>\n        <div class=\"container\">\n            <h1>Tauri used Splash!</h1>\n            <div class=\"row\">\n                <h5>It was super effective!</h5>\n            </div>\n        </div>\n    </body>\n    </html>",
          "context": "general",
          "file_path": null,
          "description": "What's important here is that you can navigate to a `/splashscreen` URL and be shown the contents you want for your splashscreen",
          "dependencies": null
        },
        {
          "language": "javascript",
          "code": "// src/main.ts\n    // These contents can be copy-pasted below the existing code, don't replace the entire file!!\n\n    // Utility function to implement a sleep function in TypeScript\n    function sleep(seconds: number): Promise<void> {\n        return new Promise(resolve => setTimeout(resolve, seconds * 1000));\n    }\n\n    // Setup function\n    async function setup() {\n        // Fake perform some really heavy setup task\n        console.log('Performing really heavy frontend setup task...')\n        await sleep(3);\n        console.log('Frontend setup task complete!')\n        // Set the frontend task as being completed\n        invoke('set_complete', {task: 'frontend'})\n    }\n\n    // Effectively a JavaScript main function\n    window.addEventListener(\"DOMContentLoaded\", () => {\n        setup()\n    });",
          "context": "general",
          "file_path": null,
          "description": "",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "// /src-tauri/src/lib.rs\n    // Import functionalities we'll be using\n    use std::sync::Mutex;\n    use tauri::async_runtime::spawn;\n    use tauri::{AppHandle, Manager, State};\n    use tokio::time::{sleep, Duration};\n\n    // Create a struct we'll use to track the completion of\n    // setup related tasks\n    struct SetupState {\n        frontend_task: bool,\n        backend_task: bool,\n    }\n\n    // Our main entrypoint in a version 2 mobile compatible app\n    #[cfg_attr(mobile, tauri::mobile_entry_point)]\n    pub fn run() {\n        // Don't write code before Tauri starts, write it in the\n        // setup hook instead!\n        tauri::Builder::default()\n            // Register a `State` to be managed by Tauri\n            // We need write access to it so we wrap it in a `Mutex`\n            .manage(Mutex::new(SetupState {\n                frontend_task: false,\n                backend_task: false,\n            }))\n            // Add a command we can use to check\n            .invoke_handler(tauri::generate_handler![greet, set_complete])\n            // Use the setup hook to execute setup related tasks\n            // Runs before the main loop, so no windows are yet created\n            .setup(|app| {\n                // Spawn setup as a non-blocking task so the windows can be\n                // created and ran while it executes\n                spawn(setup(app.handle().clone()));\n                // The hook expects an Ok result\n                Ok(())\n            })\n            // Run the app\n            .run(tauri::generate_context!())\n            .expect(\"error while running tauri application\");\n    }\n\n    #[tauri::command]\n    fn greet(name: String) -> String {\n        format!(\"Hello {name} from Rust!\")\n    }\n\n    // A custom task for setting the state of a setup task\n    #[tauri::command]\n    async fn set_complete(\n        app: AppHandle,\n        state: State<'_, Mutex<SetupState>>,\n        task: String,\n    ) -> Result<(), ()> {\n        // Lock the state without write access\n        let mut state_lock = state.lock().unwrap();\n        match task.as_str() {\n            \"frontend\" => state_lock.frontend_task = true,\n            \"backend\" => state_lock.backend_task = true,\n            _ => panic!(\"invalid task completed!\"),\n        }\n        // Check if both tasks are completed\n        if state_lock.backend_task && state_lock.frontend_task {\n            // Setup is complete, we can close the splashscreen\n            // and unhide the main window!\n            let splash_window = app.get_webview_window(\"splashscreen\").unwrap();\n            let main_window = app.get_webview_window(\"main\").unwrap();\n            splash_window.close().unwrap();\n            main_window.show().unwrap();\n        }\n        Ok(())\n    }\n\n    // An async function that does some heavy setup task\n    async fn setup(app: AppHandle) -> Result<(), ()> {\n        // Fake performing some heavy action for 3 seconds\n        println!(\"Performing really heavy backend setup task...\");\n        sleep(Duration::from_secs(3)).await;\n        println!(\"Backend setup task completed!\");\n        // Set the backend task as being completed\n        // Commands can be ran as regular functions as long as you take\n        // care of the input arguments yourself\n        set_complete(\n            app.clone(),\n            app.state::<Mutex<SetupState>>(),\n            \"backend\".to_string(),\n        )\n        .await?;\n        Ok(())\n    }",
          "context": "window_management",
          "file_path": null,
          "description": "log('Frontend setup task complete!')\n        // Set the frontend task as being completed\n        invoke('set_complete', {task: 'frontend'})\n    }\n\n    // Effectively a JavaScript main function\n    window",
          "dependencies": null
        }
      ],
      "common_errors": [],
      "best_practices": []
    },
    {
      "name": "workflow_using-plugin-permissions.mdx_5605c687",
      "description": "Step-by-step guide from using-plugin-permissions.mdx",
      "steps": [
        {
          "description": "### Create Tauri Application\n\n    Create your Tauri application.\n    In our example we will facilitate [`create-tauri-app`](https://github.com/tauri-apps/create-tauri-app):\n\n    <Cta />\n\n    We will p",
          "details": "### Create Tauri Application\n\n    Create your Tauri application.\n    In our example we will facilitate [`create-tauri-app`](https://github.com/tauri-apps/create-tauri-app):\n\n    <Cta />\n\n    We will proceed in this step-by-step explanation with `pnpm` but you can choose another\n    package manager and replace it in the commands accordingly.\n\n\n    <ShowSolution>\n    ```\n    pnpm create tauri-app\n    ```\n\n    ```\n    ✔ Project name · plugin-permission-demo\n    ✔ Choose which language to use for your frontend · TypeScript / JavaScript - (pnpm, yarn, npm, bun)\n    ✔ Choose your package manager · pnpm\n    ✔ Choose your UI template · Vanilla\n    ✔ Choose your UI flavor · TypeScript\n\n    Template created! To get started run:\n    cd plugin-permission-demo\n    pnpm install\n    pnpm tauri dev\n    ```\n    </ShowSolution>"
        },
        {
          "description": "### Add the `file-system` Plugin to Your Application\n\n    To search for existing plugins you can use multiple resources.\n\n    The most straight forward way would be to check out if your plugin is alre",
          "details": "### Add the `file-system` Plugin to Your Application\n\n    To search for existing plugins you can use multiple resources.\n\n    The most straight forward way would be to check out if your plugin is already\n    in the [Plugins](/plugin/) section of the documentation and therefore part of Tauri's\n    maintained plugin set.\n    The Filesystem plugin is part of the Tauri plugin workspace and you can add it to\n    your project by following the [instructions](/plugin/file-system/#setup).\n\n    If the plugin is part of the community effort you can most likely find it\n    on [crates.io](https://crates.io/search?q=tauri-plugin-) when searching for `tauri-plugin-<your plugin name>`.\n\n    <ShowSolution>\n    If it is an existing plugin from our workspace you can use the automated way:\n\n    ```\n    pnpm tauri add fs\n    ```\n\n    If you have found it on [crates.io](https://crates.io/crates/tauri-plugin-fs)\n    you need to manually add it as a dependency and modify the Tauri builder\n    to initialize the plugin:\n\n    ```sh\n    cargo add tauri-plugin-fs\n    ```\n\n    Modify `lib.rs` to initialize the plugin:\n\n    ```rust title=\"src-tauri/src/lib.rs\" ins={4}\n    #[cfg_attr(mobile, tauri::mobile_entry_point)]\n    fn run() {\n      tauri::Builder::default()\n        .plugin(tauri_plugin_fs::init())\n        .run(tauri::generate_context!())\n        .expect(\"error while running tauri application\");\n    }\n    ```\n    </ShowSolution>"
        },
        {
          "description": "### Understand the Default Permissions of the `fs` Plugin\n    \n    Each plugin has a `default` permission set, which contains\n    all permissions and scopes to use the plugin out of the box\n    with a",
          "details": "### Understand the Default Permissions of the `fs` Plugin\n    \n    Each plugin has a `default` permission set, which contains\n    all permissions and scopes to use the plugin out of the box\n    with a reasonable minimal feature set.\n    \n    In the case of official maintained plugins you can find a\n    rendered description in the documentation\n    (eg. [fs default](/plugin/file-system/#default-permission)).\n\n    In case you are figuring this out for a community plugin you\n    need to check out the source code of the plugin.\n    This should be defined in `your-plugin/permissions/default.toml`.\n\n    <ShowSolution>\n    ```\n    \"$schema\" = \"schemas/schema.json\"\n\n    [default]\n    description = \"\"\"\n    # Tauri `fs` default permissions\n\n    This configuration file defines the default permissions granted\n    to the filesystem.\n\n    ### Granted Permissions\n\n    This default permission set enables all read-related commands and\n    allows access to the `$APP` folder and sub directories created in it.\n    The location of the `$APP` folder depends on the operating system,\n    where the application is run.\n\n    In general the `$APP` folder needs to be manually created\n    by the application at runtime, before accessing files or folders\n    in it is possible.\n\n    ### Denied Permissions\n\n    This default permission set prevents access to critical components\n    of the Tauri application by default.\n    On Windows the webview data folder access is denied.\n\n    \"\"\"\n    permissions = [\"read-all\", \"scope-app-recursive\", \"deny-default\"]\n\n    ```\n    </ShowSolution>"
        },
        {
          "description": "### Find the Right Permissions\n      \n      This step is all about finding the permissions you need to\n      for your commands to be exposed to the frontend with the minimal\n      access to your syste",
          "details": "### Find the Right Permissions\n      \n      This step is all about finding the permissions you need to\n      for your commands to be exposed to the frontend with the minimal\n      access to your system.\n\n      The `fs` plugin has autogenerated permissions which will disable\n      or enable individual commands and allow or disable global scopes.\n\n      These can be found in the [documentation](/plugin/file-system/#permission-table)\n      or in the source code of the plugin (`fs/permissions/autogenerated`).\n\n      Let us assume we want to enable writing to a text file `test.txt`\n      located in the users `$HOME` folder.\n\n      For this we would search in the autogenerated permissions for a\n      permission to enable writing to text files like `allow-write-text-file`\n      and then for a scope which would allow us to access the `$HOME/test.txt`\n      file.\n\n      We need to add these to our `capabilities` section in our\n      `src-tauri/tauri.conf.json` or in a file in the `src-tauri/capabilities/` folder.\n      By default there is already a capability in `src-tauri/capabilities/default.json` we \n      can modify.\n\n      <ShowSolution>\n\n      ```json title=\"src-tauri/capabilities/default.json\" del={18} ins={19}\n      {\n        \"$schema\": \"../gen/schemas/desktop-schema.json\",\n        \"identifier\": \"default\",\n        \"description\": \"Capability for the main window\",\n        \"windows\": [\n          \"main\"\n        ],\n        \"permissions\": [\n          \"path:default\",\n          \"event:default\",\n          \"window:default\",\n          \"app:default\",\n          \"image:default\",\n          \"resources:default\",\n          \"menu:default\",\n          \"tray:default\",\n          \"shell:allow-open\",\n          \"fs:default\",\n          \"fs:allow-write-text-file\",\n        ]\n      }\n      ```\n\n      </ShowSolution>\n\n      Since there are only autogenerated scopes in the `fs` plugin to\n      access the full `$HOME` folder, we need to configure our own scope.\n      This scope should be only enabled for the `write-text-file` command\n      and should only expose our `test.txt` file.\n\n      <ShowSolution>\n      ```json title=\"src-tauri/capabilities/default.json\" del={18} ins={19-22}\n         {\n        \"$schema\": \"../gen/schemas/desktop-schema.json\",\n        \"identifier\": \"default\",\n        \"description\": \"Capability for the main window\",\n        \"windows\": [\n          \"main\"\n        ],\n        \"permissions\": [\n          \"path:default\",\n          \"event:default\",\n          \"window:default\",\n          \"app:default\",\n          \"image:default\",\n          \"resources:default\",\n          \"menu:default\",\n          \"tray:default\",\n          \"shell:allow-open\",\n          \"fs:allow-write-text-file\",\n          {\n            \"identifier\": \"fs:allow-write-text-file\",\n            \"allow\": [{ \"path\": \"$HOME/test.txt\" }]\n          },\n        ]\n      }\n      ```\n      </ShowSolution>"
        },
        {
          "description": "### Test Permissions in Practice\n\n        After we have added the necessary permission we want to\n        confirm that our application can access the file and write\n        it's content.\n\n        <Sho",
          "details": "### Test Permissions in Practice\n\n        After we have added the necessary permission we want to\n        confirm that our application can access the file and write\n        it's content.\n\n        <ShowSolution>\n        We can use this snippet in our application to write to the file:\n\n        ```ts title=\"src/main.ts\"\n        import { writeTextFile, BaseDirectory } from '@tauri-apps/plugin-fs';\n\n        let greetInputEl: HTMLInputElement | null;\n\n        async function write(message: string) {\n            await writeTextFile('test.txt', message, { baseDir: BaseDirectory.Home });\n        }\n\n        window.addEventListener(\"DOMContentLoaded\", () => {\n          greetInputEl = document.querySelector(\"#greet-input\");\n          document.querySelector(\"#greet-form\")?.addEventListener(\"submit\", (e) => {\n            e.preventDefault();\n            if (!greetInputEl )\n              return;\n\n            write(greetInputEl.value == \"\" ? \"No input provided\": greetInputEl.value);\n\n          });\n        });\n\n        ```\n\n        Replacing the `src/main.ts` with this snippet means we do not need to modify the default `index.html`,\n        when using the plain Vanilla+Typescript app.\n        Entering any input into the input field of the running app will be\n        written to the file on submit.\n\n        Let's test now in practice:\n\n        ```\n        pnpm run tauri dev\n        ```\n\n        After writing into the input and clicking \"Submit\",\n        we can check via our terminal emulator or by manually opening the\n        file in your home folder.\n\n        ```\n        cat $HOME/test.txt\n        ```\n\n        You should be presented with your input and finished learning about using permissions from plugins in Tauri applications.\n        🥳\n\n\n        If you encountered this error:\n\n        ```sh\n        [Error] Unhandled Promise Rejection: fs.write_text_file not allowed. Permissions associated with this command: fs:allow-app-write, fs:allow-app-write-recursive, fs:allow-appcache-write, fs:allow-appcache-write-recursive, fs:allow-appconf...\n        (anonymous function) (main.ts:5)\n        ```\n        Then you very likely did not properly follow the [previous instructions](#find-the-right-permissions).\n        </ShowSolution>"
        }
      ],
      "prerequisites": [],
      "code_snippets": [
        {
          "language": "sh",
          "code": "cargo add tauri-plugin-fs",
          "context": "plugin",
          "file_path": null,
          "description": "io](https://crates",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "#[cfg_attr(mobile, tauri::mobile_entry_point)]\n    fn run() {\n      tauri::Builder::default()\n        .plugin(tauri_plugin_fs::init())\n        .run(tauri::generate_context!())\n        .expect(\"error while running tauri application\");\n    }",
          "context": "plugin",
          "file_path": "src-tauri/src/lib.rs",
          "description": "io/crates/tauri-plugin-fs)\n    you need to manually add it as a dependency and modify the Tauri builder\n    to initialize the plugin:\n\n    ```sh\n    cargo add tauri-plugin-fs\n    ```\n\n    Modify `lib",
          "dependencies": null
        },
        {
          "language": "ts",
          "code": "import { writeTextFile, BaseDirectory } from '@tauri-apps/plugin-fs';\n\n        let greetInputEl: HTMLInputElement | null;\n\n        async function write(message: string) {\n            await writeTextFile('test.txt', message, { baseDir: BaseDirectory.Home });\n        }\n\n        window.addEventListener(\"DOMContentLoaded\", () => {\n          greetInputEl = document.querySelector(\"#greet-input\");\n          document.querySelector(\"#greet-form\")?.addEventListener(\"submit\", (e) => {\n            e.preventDefault();\n            if (!greetInputEl )\n              return;\n\n            write(greetInputEl.value == \"\" ? \"No input provided\": greetInputEl.value);\n\n          });\n        });",
          "context": "general",
          "file_path": "src/main.ts",
          "description": "### Test Permissions in Practice\n\n        After we have added the necessary permission we want to\n        confirm that our application can access the file and write\n        it's content",
          "dependencies": null
        },
        {
          "language": "sh",
          "code": "[Error] Unhandled Promise Rejection: fs.write_text_file not allowed. Permissions associated with this command: fs:allow-app-write, fs:allow-app-write-recursive, fs:allow-appcache-write, fs:allow-appcache-write-recursive, fs:allow-appconf...\n        (anonymous function) (main.ts:5)",
          "context": "permissions",
          "file_path": null,
          "description": "txt\n        ```\n\n        You should be presented with your input and finished learning about using permissions from plugins in Tauri applications",
          "dependencies": null
        }
      ],
      "common_errors": [],
      "best_practices": [
        "You should be presented with your input and finished learning about using permissions from plugins in Tauri applications."
      ]
    },
    {
      "name": "workflow_using-plugin-permissions.mdx_1",
      "description": "Workflow from using-plugin-permissions.mdx",
      "steps": [
        {
          "number": 1,
          "description": "### Create Tauri Application"
        },
        {
          "number": 2,
          "description": "### Add the `file-system` Plugin to Your Application"
        },
        {
          "number": 3,
          "description": "### Understand the Default Permissions of the `fs` Plugin\n    \n    Each plugin has a `default` permission set, which contains\n    all permissions and scopes to use the plugin out of the box\n    with a reasonable minimal feature set.\n    \n    In the case of official maintained plugins you can find a\n    rendered description in the documentation\n    (eg. [fs default](/plugin/file-system/#default-permission))."
        }
      ],
      "prerequisites": [],
      "code_snippets": [
        {
          "language": "sh",
          "code": "cargo add tauri-plugin-fs",
          "context": "plugin",
          "file_path": null,
          "description": "io](https://crates",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "#[cfg_attr(mobile, tauri::mobile_entry_point)]\n    fn run() {\n      tauri::Builder::default()\n        .plugin(tauri_plugin_fs::init())\n        .run(tauri::generate_context!())\n        .expect(\"error while running tauri application\");\n    }",
          "context": "plugin",
          "file_path": "src-tauri/src/lib.rs",
          "description": "io/crates/tauri-plugin-fs)\n    you need to manually add it as a dependency and modify the Tauri builder\n    to initialize the plugin:\n\n    ```sh\n    cargo add tauri-plugin-fs\n    ```\n\n    Modify `lib",
          "dependencies": null
        },
        {
          "language": "ts",
          "code": "import { writeTextFile, BaseDirectory } from '@tauri-apps/plugin-fs';\n\n        let greetInputEl: HTMLInputElement | null;\n\n        async function write(message: string) {\n            await writeTextFile('test.txt', message, { baseDir: BaseDirectory.Home });\n        }\n\n        window.addEventListener(\"DOMContentLoaded\", () => {\n          greetInputEl = document.querySelector(\"#greet-input\");\n          document.querySelector(\"#greet-form\")?.addEventListener(\"submit\", (e) => {\n            e.preventDefault();\n            if (!greetInputEl )\n              return;\n\n            write(greetInputEl.value == \"\" ? \"No input provided\": greetInputEl.value);\n\n          });\n        });",
          "context": "general",
          "file_path": "src/main.ts",
          "description": "### Test Permissions in Practice\n\n        After we have added the necessary permission we want to\n        confirm that our application can access the file and write\n        it's content",
          "dependencies": null
        },
        {
          "language": "sh",
          "code": "[Error] Unhandled Promise Rejection: fs.write_text_file not allowed. Permissions associated with this command: fs:allow-app-write, fs:allow-app-write-recursive, fs:allow-appcache-write, fs:allow-appcache-write-recursive, fs:allow-appconf...\n        (anonymous function) (main.ts:5)",
          "context": "permissions",
          "file_path": null,
          "description": "txt\n        ```\n\n        You should be presented with your input and finished learning about using permissions from plugins in Tauri applications",
          "dependencies": null
        }
      ],
      "common_errors": [],
      "best_practices": []
    },
    {
      "name": "workflow_vite.mdx_0ff966de",
      "description": "Step-by-step guide from vite.mdx",
      "steps": [
        {
          "description": "##### Update Tauri configuration\n\n    Assuming you have the following `dev` and `build` scripts in your `package.json`:\n\n    ```json\n    {\n      \"scripts\": {\n        \"dev\": \"vite\",\n        \"build\": \"t",
          "details": "##### Update Tauri configuration\n\n    Assuming you have the following `dev` and `build` scripts in your `package.json`:\n\n    ```json\n    {\n      \"scripts\": {\n        \"dev\": \"vite\",\n        \"build\": \"tsc && vite build\",\n        \"preview\": \"vite preview\",\n        \"tauri\": \"tauri\"\n      }\n    }\n    ```\n\n    You can configure the Tauri CLI to use your Vite development server and dist folder\n    along with the hooks to automatically run the Vite scripts:\n\n    <Tabs>\n\n    <TabItem label=\"npm\">\n\n    ```json\n    // tauri.conf.json\n    {\n      \"build\": {\n        \"beforeDevCommand\": \"npm run dev\",\n        \"beforeBuildCommand\": \"npm run build\",\n        \"devUrl\": \"http://localhost:5173\",\n        \"frontendDist\": \"../dist\"\n      }\n    }\n    ```\n\n    </TabItem>\n\n    <TabItem label=\"yarn\">\n\n    ```json\n    // tauri.conf.json\n    {\n      \"build\": {\n        \"beforeDevCommand\": \"yarn dev\",\n        \"beforeBuildCommand\": \"yarn build\",\n        \"devUrl\": \"http://localhost:5173\",\n        \"frontendDist\": \"../dist\"\n      }\n    }\n    ```\n\n    </TabItem>\n\n    <TabItem label=\"pnpm\">\n\n    ```json\n    // tauri.conf.json\n    {\n      \"build\": {\n        \"beforeDevCommand\": \"pnpm dev\",\n        \"beforeBuildCommand\": \"pnpm build\",\n        \"devUrl\": \"http://localhost:5173\",\n        \"frontendDist\": \"../dist\"\n      }\n    }\n    ```\n\n    </TabItem>\n\n    <TabItem label=\"deno\">\n\n    ```json\n    // tauri.conf.json\n    {\n      \"build\": {\n        \"beforeDevCommand\": \"deno task dev\",\n        \"beforeBuildCommand\": \"deno task build\",\n        \"devUrl\": \"http://localhost:5173\",\n        \"frontendDist\": \"../dist\"\n      }\n    }\n    ```\n\n    </TabItem>\n\n    </Tabs>"
        },
        {
          "description": "##### Update Vite configuration:\n\n    ```js title=\"vite.config.js\"\n    import { defineConfig } from 'vite';\n\n    const host = process.env.TAURI_DEV_HOST;\n\n    export default defineConfig({\n      // pr",
          "details": "##### Update Vite configuration:\n\n    ```js title=\"vite.config.js\"\n    import { defineConfig } from 'vite';\n\n    const host = process.env.TAURI_DEV_HOST;\n\n    export default defineConfig({\n      // prevent vite from obscuring rust errors\n      clearScreen: false,\n      server: {\n        // make sure this port matches the devUrl port in tauri.conf.json file\n        port: 5173,\n        // Tauri expects a fixed port, fail if that port is not available\n        strictPort: true,\n        // if the host Tauri is expecting is set, use it\n        host: host || false,\n        hmr: host\n          ? {\n              protocol: 'ws',\n              host,\n              port: 1421,\n            }\n          : undefined,\n\n        watch: {\n          // tell vite to ignore watching `src-tauri`\n          ignored: ['**/src-tauri/**'],\n        },\n      },\n      // Env variables starting with the item of `envPrefix` will be exposed in tauri's source code through `import.meta.env`.\n      envPrefix: ['VITE_', 'TAURI_ENV_*'],\n      build: {\n        // Tauri uses Chromium on Windows and WebKit on macOS and Linux\n        target:\n          process.env.TAURI_ENV_PLATFORM == 'windows'\n            ? 'chrome105'\n            : 'safari13',\n        // don't minify for debug builds\n        minify: !process.env.TAURI_ENV_DEBUG ? 'esbuild' : false,\n        // produce sourcemaps for debug builds\n        sourcemap: !!process.env.TAURI_ENV_DEBUG,\n      },\n    });\n    ```"
        }
      ],
      "prerequisites": [],
      "code_snippets": [
        {
          "language": "json",
          "code": "{\n      \"scripts\": {\n        \"dev\": \"vite\",\n        \"build\": \"tsc && vite build\",\n        \"preview\": \"vite preview\",\n        \"tauri\": \"tauri\"\n      }\n    }",
          "context": "general",
          "file_path": null,
          "description": "##### Update Tauri configuration\n\n    Assuming you have the following `dev` and `build` scripts in your `package",
          "dependencies": null
        },
        {
          "language": "json",
          "code": "// tauri.conf.json\n    {\n      \"build\": {\n        \"beforeDevCommand\": \"npm run dev\",\n        \"beforeBuildCommand\": \"npm run build\",\n        \"devUrl\": \"http://localhost:5173\",\n        \"frontendDist\": \"../dist\"\n      }\n    }",
          "context": "general",
          "file_path": null,
          "description": "##### Update Tauri configuration\n\n    Assuming you have the following `dev` and `build` scripts in your `package",
          "dependencies": null
        },
        {
          "language": "json",
          "code": "// tauri.conf.json\n    {\n      \"build\": {\n        \"beforeDevCommand\": \"yarn dev\",\n        \"beforeBuildCommand\": \"yarn build\",\n        \"devUrl\": \"http://localhost:5173\",\n        \"frontendDist\": \"../dist\"\n      }\n    }",
          "context": "command",
          "file_path": null,
          "description": "",
          "dependencies": null
        },
        {
          "language": "json",
          "code": "// tauri.conf.json\n    {\n      \"build\": {\n        \"beforeDevCommand\": \"pnpm dev\",\n        \"beforeBuildCommand\": \"pnpm build\",\n        \"devUrl\": \"http://localhost:5173\",\n        \"frontendDist\": \"../dist\"\n      }\n    }",
          "context": "command",
          "file_path": null,
          "description": "",
          "dependencies": null
        },
        {
          "language": "json",
          "code": "// tauri.conf.json\n    {\n      \"build\": {\n        \"beforeDevCommand\": \"deno task dev\",\n        \"beforeBuildCommand\": \"deno task build\",\n        \"devUrl\": \"http://localhost:5173\",\n        \"frontendDist\": \"../dist\"\n      }\n    }",
          "context": "command",
          "file_path": null,
          "description": "",
          "dependencies": null
        },
        {
          "language": "js",
          "code": "import { defineConfig } from 'vite';\n\n    const host = process.env.TAURI_DEV_HOST;\n\n    export default defineConfig({\n      // prevent vite from obscuring rust errors\n      clearScreen: false,\n      server: {\n        // make sure this port matches the devUrl port in tauri.conf.json file\n        port: 5173,\n        // Tauri expects a fixed port, fail if that port is not available\n        strictPort: true,\n        // if the host Tauri is expecting is set, use it\n        host: host || false,\n        hmr: host\n          ? {\n              protocol: 'ws',\n              host,\n              port: 1421,\n            }\n          : undefined,\n\n        watch: {\n          // tell vite to ignore watching `src-tauri`\n          ignored: ['**/src-tauri/**'],\n        },\n      },\n      // Env variables starting with the item of `envPrefix` will be exposed in tauri's source code through `import.meta.env`.\n      envPrefix: ['VITE_', 'TAURI_ENV_*'],\n      build: {\n        // Tauri uses Chromium on Windows and WebKit on macOS and Linux\n        target:\n          process.env.TAURI_ENV_PLATFORM == 'windows'\n            ? 'chrome105'\n            : 'safari13',\n        // don't minify for debug builds\n        minify: !process.env.TAURI_ENV_DEBUG ? 'esbuild' : false,\n        // produce sourcemaps for debug builds\n        sourcemap: !!process.env.TAURI_ENV_DEBUG,\n      },\n    });",
          "context": "command",
          "file_path": "vite.config.js",
          "description": "/dist\"\n      }\n    }\n    ```\n\n    </TabItem>\n\n    </Tabs>\n\n1",
          "dependencies": null
        }
      ],
      "common_errors": [],
      "best_practices": []
    },
    {
      "name": "workflow_writing-plugin-permissions.mdx_488518b9",
      "description": "Step-by-step guide from writing-plugin-permissions.mdx",
      "steps": [
        {
          "description": "### Create a Tauri Plugin\n\n    In our example we will facilitate the Tauri [`cli`](/reference/cli/)\n    to bootstrap a Tauri plugin source code structure.\n    Make sure you have installed all [Prerequ",
          "details": "### Create a Tauri Plugin\n\n    In our example we will facilitate the Tauri [`cli`](/reference/cli/)\n    to bootstrap a Tauri plugin source code structure.\n    Make sure you have installed all [Prerequisites](/start/prerequisites/)\n    and verify you have the Tauri CLI in the correct version\n    by running `cargo tauri info`.\n\n    The output should indicate the `tauri-cli` version is `2.x`.\n    We will proceed in this step-by-step explanation with `pnpm` but you can choose another\n    package manager and replace it in the commands accordingly.\n\n    Once you have a recent version installed you can go\n    ahead and create the plugin using the Tauri CLI.\n\n    <ShowSolution>\n    ```sh\n    mkdir -p tauri-learning\n    cd tauri-learning\n    cargo tauri plugin new test\n    cd tauri-plugin-test\n    pnpm install\n    pnpm build\n    cargo build\n    ```\n    </ShowSolution>"
        },
        {
          "description": "### Create a New Command\n\n    To showcase something practical and simple let us assume\n    our command writes user input to a file in our temporary folder while\n    adding some custom header to the fi",
          "details": "### Create a New Command\n\n    To showcase something practical and simple let us assume\n    our command writes user input to a file in our temporary folder while\n    adding some custom header to the file.\n\n    Let's name our command `write_custom_file`, implement it in `src/commands.rs`\n    and add it to our plugin builder to be exposed to the frontend.\n\n    Tauri's core utils will autogenerate `allow` and `deny` permissions for this\n    command, so we do not need to care about this.\n\n    <ShowSolution>\n\n    The command implementation:\n\n    ```rust title=\"src/commands.rs\" ins={15-22} ins=\", Manager\"\n    use tauri::{AppHandle, command, Runtime};\n\n    use crate::models::*;\n    use crate::Result;\n    use crate::TestExt;\n\n    #[command]\n    pub(crate) async fn ping<R: Runtime>(\n        app: AppHandle<R>,\n        payload: PingRequest,\n    ) -> Result<PingResponse> {\n        app.test1().ping(payload)\n    }\n\n    #[command]\n    pub(crate) async fn write_custom_file<R: Runtime>(\n        user_input: String,\n        app: AppHandle<R>,\n    ) -> Result<String> {\n        std::fs::write(app.path().temp_dir().unwrap(), user_input)?;\n        Ok(\"success\".to_string())\n    }\n   \n    ```\n\n    Auto-Generate inbuilt permissions for your new command:\n\n    ```rust title=\"src/build.rs\" ins=\"\\\"write_custom_file\\\"\"\n    const COMMANDS: &[&str] = &[\"ping\", \"write_custom_file\"];\n    ```\n\n    These inbuilt permissions will be automatically generated by the Tauri build\n    system and will be visible in the `permissions/autogenerated/commands` folder.\n    By default an `enable-<command>` and `deny-<command>` permission will\n    be created.\n\n    </ShowSolution>"
        },
        {
          "description": "### Expose the New Command\n\n    The previous step was to write the actual command implementation.\n    Next we want to expose it to the frontend so it can be consumed.\n\n    <ShowSolution>\n \n    Configu",
          "details": "### Expose the New Command\n\n    The previous step was to write the actual command implementation.\n    Next we want to expose it to the frontend so it can be consumed.\n\n    <ShowSolution>\n \n    Configure the Tauri builder to generate the invoke handler to pass frontend\n    IPC requests to the newly implemented command:\n\n    ```rust title=\"src/lib.rs\"  ins=\"commands::write_custom_file,\"\n    pub fn init<R: Runtime>() -> TauriPlugin<R> {\n    Builder::new(\"test\")\n        .invoke_handler(tauri::generate_handler![\n            commands::ping,\n            commands::write_custom_file,\n        ])\n        .setup(|app, api| {\n            #[cfg(mobile)]\n            let test = mobile::init(app, api)?;\n            #[cfg(desktop)]\n            let test = desktop::init(app, api)?;\n            app.manage(test);\n\n            // manage state so it is accessible by the commands\n            app.manage(MyState::default());\n            Ok(())\n        })\n        .build()\n    }\n    ```\n\n    Expose the new command in the frontend module.\n\n    This step is essential for the example application to successfully\n    import the frontend module. This is for convenience and has\n    no security impact, as the command handler is already generated\n    and the command can be manually invoked from the frontend.\n\n    ```ts title=\"guest-js/index.ts\" ins={11-13}\n    import { invoke } from '@tauri-apps/api/core'\n\n    export async function ping(value: string): Promise<string | null> {\n      return await invoke<{value?: string}>('plugin:test|ping', {\n        payload: {\n          value,\n        },\n      }).then((r) => (r.value ? r.value : null));\n    }\n\n    export async function writeCustomFile(user_input: string): Promise<string> {\n     return await invoke('plugin:test|write_custom_file',{userInput: user_input});\n    }\n    ```\n\n    :::tip\n    The invoke parameter needs to be CamelCase. In this example it is `userInput` instead of `user_input`. \n    :::\n\n    Make sure your package is built:\n\n    ```\n    pnpm build\n    ```\n\n    </ShowSolution>"
        },
        {
          "description": "### Define Default Plugin Permissions\n\n    As our plugin should expose the `write_custom_file` command by default\n    we should add this to our `default.toml` permission.\n\n    <ShowSolution>\n    Add t",
          "details": "### Define Default Plugin Permissions\n\n    As our plugin should expose the `write_custom_file` command by default\n    we should add this to our `default.toml` permission.\n\n    <ShowSolution>\n    Add this to our default permission set to allow the new command\n    we just exposed.\n\n    ```toml title=\"permissions/default.toml\" ins=\", \\\"allow-write-custom-file\\\"\"\n    \"$schema\" = \"schemas/schema.json\"\n    [default]\n    description = \"Default permissions for the plugin\"\n    permissions = [\"allow-ping\", \"allow-write-custom-file\"]\n    ```\n    </ShowSolution>"
        },
        {
          "description": "### Invoke Test Command from Example Application\n    \n    The created plugin directory structure contains an `examples/tauri-app` folder,\n    which has a ready to use Tauri application to test out the",
          "details": "### Invoke Test Command from Example Application\n    \n    The created plugin directory structure contains an `examples/tauri-app` folder,\n    which has a ready to use Tauri application to test out the plugin.\n\n    Since we added a new command we need to slightly modify the frontend to\n    invoke our new command instead.\n\n    <ShowSolution>\n    ```svelte title=\"src/App.svelte\" del={11-13,42-45} ins={14-16,45-49}\n    <script>\n      import Greet from './lib/Greet.svelte'\n      import { ping, writeCustomFile } from 'tauri-plugin-test-api'\n\n      let response = ''\n\n      function updateResponse(returnValue) {\n        response += `[${new Date().toLocaleTimeString()}]` + (typeof returnValue === 'string' ? returnValue : JSON.stringify(returnValue)) + '<br>'\n      }\n\n      function _ping() {\n        ping(\"Pong!\").then(updateResponse).catch(updateResponse)\n      }\n      function _writeCustomFile() {\n        writeCustomFile(\"HELLO FROM TAURI PLUGIN\").then(updateResponse).catch(updateResponse)\n      }\n    </script>\n\n    <main class=\"container\">\n      <h1>Welcome to Tauri!</h1>\n\n      <div class=\"row\">\n        <a href=\"https://vitejs.dev\" target=\"_blank\">\n          <img src=\"/vite.svg\" class=\"logo vite\" alt=\"Vite Logo\" />\n        </a>\n        <a href=\"https://tauri.app\" target=\"_blank\">\n          <img src=\"/tauri.svg\" class=\"logo tauri\" alt=\"Tauri Logo\" />\n        </a>\n        <a href=\"https://svelte.dev\" target=\"_blank\">\n          <img src=\"/svelte.svg\" class=\"logo svelte\" alt=\"Svelte Logo\" />\n        </a>\n      </div>\n\n      <p>\n        Click on the Tauri, Vite, and Svelte logos to learn more.\n      </p>\n\n      <div class=\"row\">\n        <Greet />\n      </div>\n\n      <div>\n        <button on:click=\"{_ping}\">Ping</button>\n        <div>{@html response}</div>\n      </div>\n      <div>\n        <button on:click=\"{_writeCustomFile}\">Write</button>\n        <div>{@html response}</div>\n      </div>\n\n\n    </main>\n\n    <style>\n      .logo.vite:hover {\n        filter: drop-shadow(0 0 2em #747bff);\n      }\n\n      .logo.svelte:hover {\n        filter: drop-shadow(0 0 2em #ff3e00);\n      }\n    </style>\n    ```\n\n    Running this and pressing the \"Write\" button you should be greeted with this:\n\n    ```\n    success\n    ```\n\n    And you should find a `test.txt` file in your temporary folder containing a message\n    from our new implemented plugin command. \n    🥳\n\n    </ShowSolution>"
        }
      ],
      "prerequisites": [],
      "code_snippets": [
        {
          "language": "sh",
          "code": "mkdir -p tauri-learning\n    cd tauri-learning\n    cargo tauri plugin new test\n    cd tauri-plugin-test\n    pnpm install\n    pnpm build\n    cargo build",
          "context": "command",
          "file_path": null,
          "description": "Once you have a recent version installed you can go\n    ahead and create the plugin using the Tauri CLI",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "pub fn init<R: Runtime>() -> TauriPlugin<R> {\n    Builder::new(\"test\")\n        .invoke_handler(tauri::generate_handler![\n            commands::ping,\n            commands::write_custom_file,\n        ])\n        .setup(|app, api| {\n            #[cfg(mobile)]\n            let test = mobile::init(app, api)?;\n            #[cfg(desktop)]\n            let test = desktop::init(app, api)?;\n            app.manage(test);\n\n            // manage state so it is accessible by the commands\n            app.manage(MyState::default());\n            Ok(())\n        })\n        .build()\n    }",
          "context": "command",
          "file_path": "src/lib.rs",
          "description": "Next we want to expose it to the frontend so it can be consumed",
          "dependencies": null
        },
        {
          "language": "ts",
          "code": "import { invoke } from '@tauri-apps/api/core'\n\n    export async function ping(value: string): Promise<string | null> {\n      return await invoke<{value?: string}>('plugin:test|ping', {\n        payload: {\n          value,\n        },\n      }).then((r) => (r.value ? r.value : null));\n    }\n\n    export async function writeCustomFile(user_input: string): Promise<string> {\n     return await invoke('plugin:test|write_custom_file',{userInput: user_input});\n    }",
          "context": "command",
          "file_path": "guest-js/index.ts",
          "description": "This is for convenience and has\n    no security impact, as the command handler is already generated\n    and the command can be manually invoked from the frontend",
          "dependencies": null
        }
      ],
      "common_errors": [],
      "best_practices": []
    },
    {
      "name": "workflow_writing-plugin-permissions.mdx_1",
      "description": "Workflow from writing-plugin-permissions.mdx",
      "steps": [
        {
          "number": 1,
          "description": "### Create a Tauri Plugin"
        },
        {
          "number": 2,
          "description": "### Create a New Command"
        },
        {
          "number": 3,
          "description": "### Expose the New Command"
        },
        {
          "number": 4,
          "description": "### Define Default Plugin Permissions"
        },
        {
          "number": 5,
          "description": "### Invoke Test Command from Example Application\n    \n    The created plugin directory structure contains an `examples/tauri-app` folder,\n    which has a ready to use Tauri application to test out the plugin."
        }
      ],
      "prerequisites": [],
      "code_snippets": [
        {
          "language": "sh",
          "code": "mkdir -p tauri-learning\n    cd tauri-learning\n    cargo tauri plugin new test\n    cd tauri-plugin-test\n    pnpm install\n    pnpm build\n    cargo build",
          "context": "command",
          "file_path": null,
          "description": "Once you have a recent version installed you can go\n    ahead and create the plugin using the Tauri CLI",
          "dependencies": null
        },
        {
          "language": "rust",
          "code": "pub fn init<R: Runtime>() -> TauriPlugin<R> {\n    Builder::new(\"test\")\n        .invoke_handler(tauri::generate_handler![\n            commands::ping,\n            commands::write_custom_file,\n        ])\n        .setup(|app, api| {\n            #[cfg(mobile)]\n            let test = mobile::init(app, api)?;\n            #[cfg(desktop)]\n            let test = desktop::init(app, api)?;\n            app.manage(test);\n\n            // manage state so it is accessible by the commands\n            app.manage(MyState::default());\n            Ok(())\n        })\n        .build()\n    }",
          "context": "command",
          "file_path": "src/lib.rs",
          "description": "Next we want to expose it to the frontend so it can be consumed",
          "dependencies": null
        },
        {
          "language": "ts",
          "code": "import { invoke } from '@tauri-apps/api/core'\n\n    export async function ping(value: string): Promise<string | null> {\n      return await invoke<{value?: string}>('plugin:test|ping', {\n        payload: {\n          value,\n        },\n      }).then((r) => (r.value ? r.value : null));\n    }\n\n    export async function writeCustomFile(user_input: string): Promise<string> {\n     return await invoke('plugin:test|write_custom_file',{userInput: user_input});\n    }",
          "context": "command",
          "file_path": "guest-js/index.ts",
          "description": "This is for convenience and has\n    no security impact, as the command handler is already generated\n    and the command can be manually invoked from the frontend",
          "dependencies": null
        }
      ],
      "common_errors": [],
      "best_practices": []
    }
  ],
  "code_examples": [
    {
      "language": "rust",
      "code": "use tauri::{AppHandle, Emitter};\n\n#[tauri::command]\nfn download(app: AppHandle, url: String) {\n  app.emit(\"download-started\", &url).unwrap();\n  for progress in [1, 15, 50, 80, 100] {\n    app.emit(\"download-progress\", progress).unwrap();\n  }\n  app.emit(\"download-finished\", &url).unwrap();\n}",
      "context": "general",
      "file_path": "src-tauri/src/lib.rs",
      "description": "Events are either global (delivered to all listeners) or webview-specific (only delivered to the webview matching a given label)",
      "dependencies": null
    },
    {
      "language": "rust",
      "code": "use tauri::{AppHandle, Emitter};\n\n#[tauri::command]\nfn login(app: AppHandle, user: String, password: String) {\n  let authenticated = user == \"tauri-apps\" && password == \"tauri\";\n  let result = if authenticated { \"loggedIn\" } else { \"invalidCredentials\" };\n  app.emit_to(\"login\", \"login-result\", result).unwrap();\n}",
      "context": "general",
      "file_path": "src-tauri/src/lib.rs",
      "description": "emit(\"download-finished\", &url)",
      "dependencies": null
    },
    {
      "language": "rust",
      "code": "use tauri::{AppHandle, Emitter, EventTarget};\n\n#[tauri::command]\nfn open_file(app: AppHandle, path: std::path::PathBuf) {\n  app.emit_filter(\"open-file\", path, |target| match target {\n    EventTarget::WebviewWindow { label } => label == \"main\" || label == \"file-viewer\",\n    _ => false,\n  }).unwrap();\n}",
      "context": "general",
      "file_path": "src-tauri/src/lib.rs",
      "description": "unwrap();\n}\n```\n\nIt is also possible to trigger an event to a list of webviews by calling [Emitter#emit_filter]",
      "dependencies": null
    },
    {
      "language": "rust",
      "code": "use tauri::{AppHandle, Emitter};\nuse serde::Serialize;\n\n#[derive(Clone, Serialize)]\n#[serde(rename_all = \"camelCase\")]\nstruct DownloadStarted<'a> {\n  url: &'a str,\n  download_id: usize,\n  content_length: usize,\n}\n\n#[derive(Clone, Serialize)]\n#[serde(rename_all = \"camelCase\")]\nstruct DownloadProgress {\n  download_id: usize,\n  chunk_length: usize,\n}\n\n#[derive(Clone, Serialize)]\n#[serde(rename_all = \"camelCase\")]\nstruct DownloadFinished {\n  download_id: usize,\n}\n\n#[tauri::command]\nfn download(app: AppHandle, url: String) {\n  let content_length = 1000;\n  let download_id = 1;\n\n  app.emit(\"download-started\", DownloadStarted {\n    url: &url,\n    download_id,\n    content_length\n  }).unwrap();\n\n  for chunk_length in [15, 150, 35, 500, 300] {\n    app.emit(\"download-progress\", DownloadProgress {\n      download_id,\n      chunk_length,\n    }).unwrap();\n  }\n\n  app.emit(\"download-finished\", DownloadFinished { download_id }).unwrap();\n}",
      "context": "general",
      "file_path": "src-tauri/src/lib.rs",
      "description": ":::\n\n### Event Payload\n\nThe event payload can be any [serializable][Serialize] type that also implements [Clone]",
      "dependencies": null
    },
    {
      "language": "rust",
      "code": "use tauri::{AppHandle, ipc::Channel};\nuse serde::Serialize;\n\n#[derive(Clone, Serialize)]\n#[serde(rename_all = \"camelCase\", rename_all_fields = \"camelCase\", tag = \"event\", content = \"data\")]\nenum DownloadEvent<'a> {\n  Started {\n    url: &'a str,\n    download_id: usize,\n    content_length: usize,\n  },\n  Progress {\n    download_id: usize,\n    chunk_length: usize,\n  },\n  Finished {\n    download_id: usize,\n  },\n}\n\n#[tauri::command]\nfn download(app: AppHandle, url: String, on_event: Channel<DownloadEvent>) {\n  let content_length = 1000;\n  let download_id = 1;\n\n  on_event.send(DownloadEvent::Started {\n    url: &url,\n    download_id,\n    content_length,\n  }).unwrap();\n\n  for chunk_length in [15, 150, 35, 500, 300] {\n    on_event.send(DownloadEvent::Progress {\n      download_id,\n      chunk_length,\n    }).unwrap();\n  }\n\n  on_event.send(DownloadEvent::Finished { download_id }).unwrap();\n}",
      "context": "command",
      "file_path": "src-tauri/src/lib.rs",
      "description": "They are used internally for streaming operations\nsuch as download progress, child process output and WebSocket messages",
      "dependencies": null
    },
    {
      "language": "ts",
      "code": "import { invoke, Channel } from '@tauri-apps/api/core';\n\ntype DownloadEvent =\n  | {\n      event: 'started';\n      data: {\n        url: string;\n        downloadId: number;\n        contentLength: number;\n      };\n    }\n  | {\n      event: 'progress';\n      data: {\n        downloadId: number;\n        chunkLength: number;\n      };\n    }\n  | {\n      event: 'finished';\n      data: {\n        downloadId: number;\n      };\n    };\n\nconst onEvent = new Channel<DownloadEvent>();\nonEvent.onmessage = (message) => {\n  console.log(`got download event ${message.event}`);\n};\n\nawait invoke('download', {\n  url: 'https://raw.githubusercontent.com/tauri-apps/tauri/dev/crates/tauri-schema-generator/schemas/config.schema.json',\n  onEvent,\n});",
      "context": "command",
      "file_path": null,
      "description": "send(DownloadEvent::Finished { download_id })",
      "dependencies": null
    },
    {
      "language": "rust",
      "code": "use tauri::Manager;\n\ntauri::Builder::default()\n  .setup(|app| {\n    let webview = app.get_webview_window(\"main\").unwrap();\n    webview.eval(\"console.log('hello from Rust')\")?;\n    Ok(())\n  })",
      "context": "window_management",
      "file_path": "src-tauri/src/lib.rs",
      "description": "schema",
      "dependencies": null
    },
    {
      "language": "rust",
      "code": "#[tauri::command]\nfn my_custom_command() {\n\tprintln!(\"I was invoked from JavaScript!\");\n}",
      "context": "command",
      "file_path": "src-tauri/src/lib.rs",
      "description": "rs` file",
      "dependencies": null
    },
    {
      "language": "rust",
      "code": "#[cfg_attr(mobile, tauri::mobile_entry_point)]\npub fn run() {\n\ttauri::Builder::default()\n\t\t.invoke_handler(tauri::generate_handler![my_custom_command])\n\t\t.run(tauri::generate_context!())\n\t\t.expect(\"error while running tauri application\");\n}",
      "context": "command",
      "file_path": "src-tauri/src/lib.rs",
      "description": "it as a public function:\n\n```\nerror[E0255]: the name `__cmd__command_name` is defined multiple times\n  --> src/lib",
      "dependencies": null
    },
    {
      "language": "javascript",
      "code": "// When using the Tauri API npm package:\nimport { invoke } from '@tauri-apps/api/core';\n\n// When using the Tauri global script (if not using the npm package)\n// Be sure to set `app.withGlobalTauri` in `tauri.conf.json` to true\nconst invoke = window.__TAURI__.core.invoke;\n\n// Invoke the command\ninvoke('my_custom_command');",
      "context": "command",
      "file_path": null,
      "description": "run(tauri::generate_context!())",
      "dependencies": null
    },
    {
      "language": "rust",
      "code": "#[tauri::command]\npub fn my_custom_command() {\n\tprintln!(\"I was invoked from JavaScript!\");\n}",
      "context": "command",
      "file_path": "src-tauri/src/commands.rs",
      "description": "As an example let's define a command in the `src-tauri/src/commands",
      "dependencies": null
    },
    {
      "language": "rust",
      "code": "mod commands;\n\n#[cfg_attr(mobile, tauri::mobile_entry_point)]\npub fn run() {\n\ttauri::Builder::default()\n\t\t.invoke_handler(tauri::generate_handler![commands::my_custom_command])\n\t\t.run(tauri::generate_context!())\n\t\t.expect(\"error while running tauri application\");\n}",
      "context": "command",
      "file_path": "src-tauri/src/lib.rs",
      "description": ":::\n\nIn the `lib",
      "dependencies": null
    },
    {
      "language": "rust",
      "code": "#[wasm_bindgen]\nextern \"C\" {\n    // invoke without arguments\n    #[wasm_bindgen(js_namespace = [\"window\", \"__TAURI__\", \"core\"], js_name = invoke)]\n    async fn invoke_without_args(cmd: &str) -> JsValue;\n\n    // invoke with arguments (default)\n    #[wasm_bindgen(js_namespace = [\"window\", \"__TAURI__\", \"core\"])]\n    async fn invoke(cmd: &str, args: JsValue) -> JsValue;\n\n    // They need to have different names!\n}",
      "context": "frontend_integration",
      "file_path": null,
      "description": "The reason is that Rust doesn't support optional arguments",
      "dependencies": null
    },
    {
      "language": "rust",
      "code": "#[tauri::command]\nfn my_custom_command(invoke_message: String) {\n\tprintln!(\"I was invoked from JavaScript, with this message: {}\", invoke_message);\n}",
      "context": "command",
      "file_path": null,
      "description": "rust ins={4-5}\n#[wasm_bindgen]\nextern \"C\" {\n    // invoke without arguments\n    #[wasm_bindgen(js_namespace = [\"window\", \"__TAURI__\", \"core\"], js_name = invoke)]\n    async fn invoke_without_args(cmd: &str) -> JsValue;\n\n    // invoke with arguments (default)\n    #[wasm_bindgen(js_namespace = [\"window\", \"__TAURI__\", \"core\"])]\n    async fn invoke(cmd: &str, args: JsValue) -> JsValue;\n\n    // They need to have different names!\n}\n```\n\n### Passing Arguments\n\nYour command handlers can take arguments:",
      "dependencies": null
    },
    {
      "language": "javascript",
      "code": "invoke('my_custom_command', { invokeMessage: 'Hello!' });",
      "context": "command",
      "file_path": null,
      "description": "oke with arguments (default)\n    #[wasm_bindgen(js_namespace = [\"window\", \"__TAURI__\", \"core\"])]\n    async fn invoke(cmd: &str, args: JsValue) -> JsValue;\n\n    // They need to have different names!\n}\n```\n\n### Passing Arguments\n\nYour command handlers can take arguments:\n\n```rust\n#[tauri::command]\nfn my_custom_command(invoke_message: String) {\n\tprintln!(\"I was invoked from JavaScript, with this message: {}\", invoke_message);\n}\n```\n\nArguments should be passed as a JSON object with camelCase keys:",
      "dependencies": null
    },
    {
      "language": "rust",
      "code": "#[tauri::command(rename_all = \"snake_case\")]\nfn my_custom_command(invoke_message: String) {}",
      "context": "command",
      "file_path": null,
      "description": "They need to have different names!\n}\n```\n\n### Passing Arguments\n\nYour command handlers can take arguments:\n\n```rust\n#[tauri::command]\nfn my_custom_command(invoke_message: String) {\n\tprintln!(\"I was invoked from JavaScript, with this message: {}\", invoke_message);\n}\n```\n\nArguments should be passed as a JSON object with camelCase keys:\n\n```javascript\ninvoke('my_custom_command', { invokeMessage: 'Hello!' });\n```\n\n:::note\nYou can use `snake_case` for the arguments with the `rename_all` attribute:",
      "dependencies": null
    },
    {
      "language": "javascript",
      "code": "invoke('my_custom_command', { invoke_message: 'Hello!' });",
      "context": "command",
      "file_path": null,
      "description": ":\n\n```rust\n#[tauri::command]\nfn my_custom_command(invoke_message: String) {\n\tprintln!(\"I was invoked from JavaScript, with this message: {}\", invoke_message);\n}\n```\n\nArguments should be passed as a JSON object with camelCase keys:\n\n```javascript\ninvoke('my_custom_command', { invokeMessage: 'Hello!' });\n```\n\n:::note\nYou can use `snake_case` for the arguments with the `rename_all` attribute:\n\n```rust\n#[tauri::command(rename_all = \"snake_case\")]\nfn my_custom_command(invoke_message: String) {}\n```",
      "dependencies": null
    },
    {
      "language": "javascript",
      "code": "invoke('my_custom_command', { invoke_message: 'Hello!' });",
      "context": "command",
      "file_path": null,
      "description": "a JSON object with camelCase keys:\n\n```javascript\ninvoke('my_custom_command', { invokeMessage: 'Hello!' });\n```\n\n:::note\nYou can use `snake_case` for the arguments with the `rename_all` attribute:\n\n```rust\n#[tauri::command(rename_all = \"snake_case\")]\nfn my_custom_command(invoke_message: String) {}\n```\n\n```javascript\ninvoke('my_custom_command', { invoke_message: 'Hello!' });\n```\n\n:::\n\nArguments can be of any type, as long as they implement [`serde::Deserialize`]",
      "dependencies": null
    },
    {
      "language": "rust",
      "code": "#[tauri::command]\nfn my_custom_command() -> String {\n\t\"Hello from Rust!\".into()\n}",
      "context": "command",
      "file_path": null,
      "description": "case` for the arguments with the `rename_all` attribute:\n\n```rust\n#[tauri::command(rename_all = \"snake_case\")]\nfn my_custom_command(invoke_message: String) {}\n```\n\n```javascript\ninvoke('my_custom_command', { invoke_message: 'Hello!' });\n```\n\n:::\n\nArguments can be of any type, as long as they implement [`serde::Deserialize`]",
      "dependencies": null
    },
    {
      "language": "javascript",
      "code": "invoke('my_custom_command').then((message) => console.log(message));",
      "context": "command",
      "file_path": null,
      "description": "The corresponding JavaScript:\n\n```javascript\ninvoke('my_custom_command', { invoke_message: 'Hello!' });\n```\n\n### Returning Data\n\nCommand handlers can return data as well:\n\n```rust\n#[tauri::command]\nfn my_custom_command() -> String {\n\t\"Hello from Rust!\"",
      "dependencies": null
    },
    {
      "language": "rust",
      "code": "use tauri::ipc::Response;\n#[tauri::command]\nfn read_file() -> Response {\n\tlet data = std::fs::read(\"/path/to/file\").unwrap();\n\ttauri::ipc::Response::new(data)\n}",
      "context": "frontend_integration",
      "file_path": null,
      "description": "This can slow down your application if you try to return a large data such as a file or a download HTTP response",
      "dependencies": null
    },
    {
      "language": "rust",
      "code": "#[tauri::command]\nfn login(user: String, password: String) -> Result<String, String> {\n\tif user == \"tauri\" && password == \"tauri\" {\n\t\t// resolve\n\t\tOk(\"logged_in\".to_string())\n\t} else {\n\t\t// reject\n\t\tErr(\"invalid credentials\".to_string())\n\t}\n}",
      "context": "general",
      "file_path": null,
      "description": "To return array buffers in an optimized way, use [`tauri::ipc::Response`]:\n\n```rust\nuse tauri::ipc::Response;\n#[tauri::command]\nfn read_file() -> Response {\n\tlet data = std::fs::read(\"/path/to/file\")",
      "dependencies": null
    },
    {
      "language": "javascript",
      "code": "invoke('login', { user: 'tauri', password: '0j4rijw8=' })\n  .then((message) => console.log(message))\n  .catch((error) => console.error(error));",
      "context": "command",
      "file_path": null,
      "description": "to_string())\n\t} else {\n\t\t// reject\n\t\tErr(\"invalid credentials\"",
      "dependencies": null
    },
    {
      "language": "rust",
      "code": "#[tauri::command]\nfn my_custom_command() -> Result<(), String> {\n\tstd::fs::File::open(\"path/to/file\").map_err(|err| err.to_string())?;\n\t// Return `null` on success\n\tOk(())\n}",
      "context": "rust_backend",
      "file_path": null,
      "description": "This can be problematic if you're working with error types from Rust's std library or external crates as most error types do not implement it",
      "dependencies": null
    },
    {
      "language": "rust",
      "code": "// create the error type that represents all errors possible in our program\n#[derive(Debug, thiserror::Error)]\nenum Error {\n\t#[error(transparent)]\n\tIo(#[from] std::io::Error)\n}\n\n// we must manually implement serde::Serialize\nimpl serde::Serialize for Error {\n\tfn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n\twhere\n\t\tS: serde::ser::Serializer,\n\t{\n\t\tserializer.serialize_str(self.to_string().as_ref())\n\t}\n}\n\n#[tauri::command]\nfn my_custom_command() -> Result<(), Error> {\n\t// This will return an error\n\tstd::fs::File::open(\"path/that/does/not/exist\")?;\n\t// Return `null` on success\n\tOk(())\n}",
      "context": "general",
      "file_path": null,
      "description": "You can consult its documentation for more details",
      "dependencies": null
    },
    {
      "language": "rust",
      "code": "#[derive(Debug, thiserror::Error)]\nenum Error {\n  #[error(transparent)]\n  Io(#[from] std::io::Error),\n  #[error(\"failed to parse as string: {0}\")]\n  Utf8(#[from] std::str::Utf8Error),\n}\n\n#[derive(serde::Serialize)]\n#[serde(tag = \"kind\", content = \"message\")]\n#[serde(rename_all = \"camelCase\")]\nenum ErrorKind {\n  Io(String),\n  Utf8(String),\n}\n\nimpl serde::Serialize for Error {\n  fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n  where\n    S: serde::ser::Serializer,\n  {\n    let error_message = self.to_string();\n    let error_kind = match self {\n      Self::Io(_) => ErrorKind::Io(error_message),\n      Self::Utf8(_) => ErrorKind::Utf8(error_message),\n    };\n    error_kind.serialize(serializer)\n  }\n}\n\n#[tauri::command]\nfn read() -> Result<Vec<u8>, Error> {\n  let data = std::fs::read(\"/path/to/file\")?;\n\tOk(data)\n}",
      "context": "general",
      "file_path": null,
      "description": "<br/>\nIt also gives you full control over the way your error type gets serialized",
      "dependencies": null
    },
    {
      "language": "ts",
      "code": "type ErrorKind = {\n  kind: 'io' | 'utf8';\n  message: string;\n};\n\ninvoke('read').catch((e: ErrorKind) => {});",
      "context": "command",
      "file_path": null,
      "description": "to_string();\n    let error_kind = match self {\n      Self::Io(_) => ErrorKind::Io(error_message),\n      Self::Utf8(_) => ErrorKind::Utf8(error_message),\n    };\n    error_kind",
      "dependencies": null
    },
    {
      "language": "rust",
      "code": "// Declare the async function using String instead of &str, as &str is borrowed and thus unsupported\n#[tauri::command]\nasync fn my_custom_command(value: String) -> String {\n\t// Call another async function and wait for it to finish\n\tsome_async_function().await;\n\tvalue\n}",
      "context": "state_management",
      "file_path": null,
      "description": "This may not work for all types, for example `State<'_, Data>`",
      "dependencies": null
    },
    {
      "language": "rust",
      "code": "// Return a Result<String, ()> to bypass the borrowing issue\n#[tauri::command]\nasync fn my_custom_command(value: &str) -> Result<String, ()> {\n\t// Call another async function and wait for it to finish\n\tsome_async_function().await;\n\t// Note that the return value must be wrapped in `Ok()` now.\n\tOk(format!(value))\n}",
      "context": "general",
      "file_path": null,
      "description": "- `Result<bool, Error>` to return a boolean or an error as shown in the [Error Handling](#error-handling) section above",
      "dependencies": null
    },
    {
      "language": "javascript",
      "code": "invoke('my_custom_command', { value: 'Hello, Async!' }).then(() =>\n  console.log('Completed!')\n);",
      "context": "command",
      "file_path": null,
      "description": "await;\n\t// Note that the return value must be wrapped in `Ok()` now",
      "dependencies": null
    },
    {
      "language": "rust",
      "code": "use tokio::io::AsyncReadExt;\n\n#[tauri::command]\nasync fn load_image(path: std::path::PathBuf, reader: tauri::ipc::Channel<&[u8]>) {\n  // for simplicity this example does not include error handling\n  let mut file = tokio::fs::File::open(path).await.unwrap();\n\n  let mut chunk = vec![0; 4096];\n\n  loop {\n    let len = file.read(&mut chunk).await.unwrap();\n    if len == 0 {\n      // Length of zero means end of file.\n      break;\n    }\n    reader.send(&chunk).unwrap();\n  }\n}",
      "context": "frontend_integration",
      "file_path": null,
      "description": "log('Completed!')\n);\n```\n\n### Channels\n\nThe Tauri channel is the recommended mechanism for streaming data such as streamed HTTP responses to the frontend",
      "dependencies": null
    },
    {
      "language": "rust",
      "code": "#[tauri::command]\nasync fn my_custom_command(webview_window: tauri::WebviewWindow) {\n\tprintln!(\"WebviewWindow: {}\", webview_window.label());\n}",
      "context": "command",
      "file_path": "src-tauri/src/lib.rs",
      "description": "unwrap();\n  }\n}\n```\n\nSee the [channels documentation] for more information",
      "dependencies": null
    },
    {
      "language": "rust",
      "code": "#[tauri::command]\nasync fn my_custom_command(app_handle: tauri::AppHandle) {\n\tlet app_dir = app_handle.path().app_dir();\n\tuse tauri::GlobalShortcutManager;\n\tapp_handle.global_shortcut_manager().register(\"CTRL + U\", move || {});\n}",
      "context": "command",
      "file_path": "src-tauri/src/lib.rs",
      "description": "rs\"\n#[tauri::command]\nasync fn my_custom_command(webview_window: tauri::WebviewWindow) {\n\tprintln!(\"WebviewWindow: {}\", webview_window",
      "dependencies": null
    },
    {
      "language": "rust",
      "code": "struct MyState(String);\n\n#[tauri::command]\nfn my_custom_command(state: tauri::State<MyState>) {\n\tassert_eq!(state.0 == \"some state value\", true);\n}\n\n#[cfg_attr(mobile, tauri::mobile_entry_point)]\npub fn run() {\n\ttauri::Builder::default()\n\t\t.manage(MyState(\"some state value\".into()))\n\t\t.invoke_handler(tauri::generate_handler![my_custom_command])\n\t\t.run(tauri::generate_context!())\n\t\t.expect(\"error while running tauri application\");\n}",
      "context": "command",
      "file_path": "src-tauri/src/lib.rs",
      "description": "label());\n}\n```\n\n:::\n\n### Accessing Managed State\n\nTauri can manage state using the `manage` function on `tauri::Builder`",
      "dependencies": null
    },
    {
      "language": "rust",
      "code": "#[derive(Debug, thiserror::Error)]\nenum Error {\n  #[error(\"unexpected request body\")]\n  RequestBodyMustBeRaw,\n  #[error(\"missing `{0}` header\")]\n  MissingHeader(&'static str),\n}\n\nimpl serde::Serialize for Error {\n  fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n  where\n    S: serde::ser::Serializer,\n  {\n    serializer.serialize_str(self.to_string().as_ref())\n  }\n}\n\n#[tauri::command]\nfn upload(request: tauri::ipc::Request) -> Result<(), Error> {\n  let tauri::ipc::InvokeBody::Raw(upload_data) = request.body() else {\n    return Err(Error::RequestBodyMustBeRaw);\n  };\n  let Some(authorization_header) = request.headers().get(\"Authorization\") else {\n    return Err(Error::MissingHeader(\"Authorization\"));\n  };\n\n  // upload...\n\n  Ok(())\n}",
      "context": "command",
      "file_path": null,
      "description": "expect(\"error while running tauri application\");\n}\n```\n\n### Accessing Raw Request\n\nTauri commands can also access the full [`tauri::ipc::Request`] object which includes the raw body payload and the request headers",
      "dependencies": null
    },
    {
      "language": "js",
      "code": "const data = new Uint8Array([1, 2, 3]);\nawait __TAURI__.core.invoke('upload', data, {\n  headers: {\n    Authorization: 'apikey',\n  },\n});",
      "context": "frontend_integration",
      "file_path": null,
      "description": "",
      "dependencies": null
    },
    {
      "language": "rust",
      "code": "#[tauri::command]\nfn cmd_a() -> String {\n\t\"Command a\"\n}\n#[tauri::command]\nfn cmd_b() -> String {\n\t\"Command b\"\n}\n\n#[cfg_attr(mobile, tauri::mobile_entry_point)]\npub fn run() {\n\ttauri::Builder::default()\n\t\t.invoke_handler(tauri::generate_handler![cmd_a, cmd_b])\n\t\t.run(tauri::generate_context!())\n\t\t.expect(\"error while running tauri application\");\n}",
      "context": "command",
      "file_path": "src-tauri/src/lib.rs",
      "description": "You must pass each command to a single call of\n`tauri::generate_handler!`",
      "dependencies": null
    },
    {
      "language": "rust",
      "code": "struct Database;\n\n#[derive(serde::Serialize)]\nstruct CustomResponse {\n\tmessage: String,\n\tother_val: usize,\n}\n\nasync fn some_other_function() -> Option<String> {\n\tSome(\"response\".into())\n}\n\n#[tauri::command]\nasync fn my_custom_command(\n\twindow: tauri::Window,\n\tnumber: usize,\n\tdatabase: tauri::State<'_, Database>,\n) -> Result<CustomResponse, String> {\n\tprintln!(\"Called from {}\", window.label());\n\tlet result: Option<String> = some_other_function().await;\n\tif let Some(message) = result {\n\t\tOk(CustomResponse {\n\t\t\tmessage,\n\t\t\tother_val: 42 + number,\n\t\t})\n\t} else {\n\t\tErr(\"No result\".into())\n\t}\n}\n\n#[cfg_attr(mobile, tauri::mobile_entry_point)]\npub fn run() {\n\ttauri::Builder::default()\n\t\t.manage(Database {})\n\t\t.invoke_handler(tauri::generate_handler![my_custom_command])\n\t\t.run(tauri::generate_context!())\n\t\t.expect(\"error while running tauri application\");\n}",
      "context": "general",
      "file_path": "src-tauri/src/lib.rs",
      "description": "run(tauri::generate_context!())",
      "dependencies": null
    },
    {
      "language": "javascript",
      "code": "import { invoke } from '@tauri-apps/api/core';\n\n// Invocation from JavaScript\ninvoke('my_custom_command', {\n  number: 42,\n})\n  .then((res) =>\n    console.log(`Message: ${res.message}, Other Val: ${res.other_val}`)\n  )\n  .catch((e) => console.error(e));",
      "context": "command",
      "file_path": null,
      "description": "run(tauri::generate_context!())",
      "dependencies": null
    },
    {
      "language": "js",
      "code": "import { emit } from '@tauri-apps/api/event';\nimport { getCurrentWebviewWindow } from '@tauri-apps/api/webviewWindow';\n\n// emit(eventName, payload)\nemit('file-selected', '/path/to/file');\n\nconst appWebview = getCurrentWebviewWindow();\nappWebview.emit('route-changed', { url: window.location.href });",
      "context": "window_management",
      "file_path": null,
      "description": "### Global Events\n\nTo trigger a global event you can use the [event",
      "dependencies": null
    },
    {
      "language": "js",
      "code": "import { emitTo } from '@tauri-apps/api/event';\nimport { getCurrentWebviewWindow } from '@tauri-apps/api/webviewWindow';\n\n// emitTo(webviewLabel, eventName, payload)\nemitTo('settings', 'settings-update-requested', {\n  key: 'notification',\n  value: 'all',\n});\n\nconst appWebview = getCurrentWebviewWindow();\nappWebview.emitTo('editor', 'file-changed', {\n  path: '/path/to/file',\n  contents: 'file contents',\n});",
      "context": "window_management",
      "file_path": null,
      "description": "href });\n```\n\n:::note\nGlobal events are delivered to **all** listeners\n:::\n\n### Webview Event\n\nTo trigger an event to a listener registered by a specific webview you can use the [event",
      "dependencies": null
    },
    {
      "language": "js",
      "code": "import { listen } from '@tauri-apps/api/event';\nlisten(\n  'state-changed',\n  (event) => {\n    console.log('got state changed event', event);\n  },\n  {\n    target: { kind: 'Any' },\n  }\n);",
      "context": "general",
      "file_path": null,
      "description": "To listen to **any** event you must provide the `{ target: { kind: 'Any' } }` option to the [event",
      "dependencies": null
    },
    {
      "language": "javascript",
      "code": "\"productName\": \"multiwindow\",\n      ...\n      \"app\": {\n        \"windows\": [\n          {\n            \"label\": \"first\",\n            \"title\": \"First\",\n            \"width\": 800,\n            \"height\": 600\n          },\n          {\n            \"label\": \"second\",\n            \"title\": \"Second\",\n            \"width\": 800,\n            \"height\": 600\n          }\n        ],\n      },\n      ...\n    }",
      "context": "window_management",
      "file_path": null,
      "description": "conf",
      "dependencies": null
    },
    {
      "language": "rust",
      "code": "tauri::Builder::default()\n        .invoke_handler(tauri::generate_handler![greet])\n        .setup(|app| {\n            let webview_url = tauri::WebviewUrl::App(\"index.html\".into());\n            // First window\n            tauri::WebviewWindowBuilder::new(app, \"first\", webview_url.clone())\n                .title(\"First\")\n                .build()?;\n            // Second window\n            tauri::WebviewWindowBuilder::new(app, \"second\", webview_url)\n                .title(\"Second\")\n                .build()?;\n            Ok(())\n        })\n        .run(context)\n        .expect(\"error while running tauri application\");",
      "context": "window_management",
      "file_path": null,
      "description": "",
      "dependencies": null
    },
    {
      "language": "json",
      "code": "{\n      \"identifier\": \"fs-read-home\",\n      \"description\": \"Allow access file access to home directory\",\n      \"local\": true,\n      \"windows\": [\"first\"],\n      \"permissions\": [\n        \"fs:allow-home-read\",\n      ]\n    }",
      "context": "window_management",
      "file_path": "filesystem.json",
      "description": "<ShowSolution>\n    Use the `windows` field in a capability file with one or multiple window labels",
      "dependencies": null
    },
    {
      "language": "json",
      "code": "{\n      \"identifier\": \"dialog\",\n      \"description\": \"Allow to open a dialog\",\n      \"local\": true,\n      \"windows\": [\"first\", \"second\"],\n      \"permissions\": [\"dialog:allow-ask\"]\n    }",
      "context": "window_management",
      "file_path": "dialog.json",
      "description": "er\": \"fs-read-home\",\n      \"description\": \"Allow access file access to home directory\",\n      \"local\": true,\n      \"windows\": [\"first\"],\n      \"permissions\": [\n        \"fs:allow-home-read\",\n      ]\n    }\n    ```\n    </ShowSolution>\n\n    #### Give dialog capabilities to the `first` and `second` window\n\n    We give to `first` and `second` windows the capability to create a \"Yes/No\" dialog\n\n    <ShowSolution>\n    Use the `windows` field in a capability file with one or multiple window labels",
      "dependencies": null
    },
    {
      "language": "json",
      "code": "{\n      \"identifier\": \"fs-read-home\",\n      \"description\": \"Allow access file access to home directory\",\n      \"local\": true,\n      \"windows\": [\"first\"],\n      \"permissions\": [\n        \"fs:allow-home-read\",\n      ],\n      \"platforms\": [\"linux\", \"windows\"]\n    }",
      "context": "window_management",
      "file_path": "filesystem.json",
      "description": "<ShowSolution>\n    Use the `platforms` field in a capability file to make it platform-specific",
      "dependencies": null
    },
    {
      "language": "toml",
      "code": "[build-dependencies]\ntauri-build = { version = \"2.0.0\", features = [ \"config-json5\" ] }\n\n[dependencies]\ntauri = { version = \"2.0.0\", features = [  \"config-json5\" ] }",
      "context": "general",
      "file_path": "Cargo.toml",
      "description": "toml`",
      "dependencies": null
    },
    {
      "language": "json5",
      "code": "{\n  build: {\n    devUrl: 'http://localhost:3000',\n    // start the dev server\n    beforeDevCommand: 'npm run dev',\n  },\n  bundle: {\n    active: true,\n    icon: ['icons/app.png'],\n  },\n  app: {\n    windows: [\n      {\n        title: 'MyApp',\n      },\n    ],\n  },\n  plugins: {\n    updater: {\n      pubkey: 'updater pub key',\n      endpoints: ['https://my.app.updater/{{target}}/{{current_version}}'],\n    },\n  },\n}",
      "context": "general",
      "file_path": "tauri.conf.json or tauri.conf.json5",
      "description": "0",
      "dependencies": null
    },
    {
      "language": "toml",
      "code": "[build]\ndev-url = \"http://localhost:3000\"\n# start the dev server\nbefore-dev-command = \"npm run dev\"\n\n[bundle]\nactive = true\nicon = [\"icons/app.png\"]\n\n[[app.windows]]\ntitle = \"MyApp\"\n\n[plugins.updater]\npubkey = \"updater pub key\"\nendpoints = [\"https://my.app.updater/{{target}}/{{current_version}}\"]",
      "context": "plugin",
      "file_path": "Tauri.toml",
      "description": "app",
      "dependencies": null
    },
    {
      "language": "json",
      "code": "{\n  \"productName\": \"MyApp\",\n  \"bundle\": {\n    \"resources\": [\"./resources\"]\n  },\n  \"plugins\": {\n    \"deep-link\": {}\n  }\n}",
      "context": "general",
      "file_path": "tauri.conf.json",
      "description": "conf",
      "dependencies": null
    },
    {
      "language": "json",
      "code": "{\n  \"productName\": \"my-app\",\n  \"bundle\": {\n    \"resources\": [\"./linux-assets\"]\n  },\n  \"plugins\": {\n    \"cli\": {\n      \"description\": \"My app\",\n      \"subcommands\": {\n        \"update\": {}\n      }\n    },\n    \"deep-link\": {}\n  }\n}",
      "context": "plugin",
      "file_path": "tauri.linux.conf.json",
      "description": "conf",
      "dependencies": null
    },
    {
      "language": "json",
      "code": "{\n  \"productName\": \"my-app\",\n  \"bundle\": {\n    \"resources\": [\"./linux-assets\"]\n  },\n  \"plugins\": {\n    \"cli\": {\n      \"description\": \"My app\",\n      \"subcommands\": {\n        \"update\": {}\n      }\n    },\n    \"deep-link\": {}\n  }\n}",
      "context": "command",
      "file_path": null,
      "description": "json\n{\n  \"productName\": \"my-app\",\n  \"bundle\": {\n    \"resources\": [\"",
      "dependencies": null
    },
    {
      "language": "json",
      "code": "{\n  \"productName\": \"My App Beta\",\n  \"identifier\": \"com.myorg.myappbeta\"\n}",
      "context": "general",
      "file_path": "src-tauri/tauri.beta.conf.json",
      "description": "This mechanism can be used to define multiple flavours of your application or have more flexibility when configuring your application bundles",
      "dependencies": null
    },
    {
      "language": "toml",
      "code": "[package]\nname = \"app\"\nversion = \"0.1.0\"\ndescription = \"A Tauri App\"\nauthors = [\"you\"]\nlicense = \"\"\nrepository = \"\"\ndefault-run = \"app\"\nedition = \"2021\"\nrust-version = \"1.57\"\n\n[build-dependencies]\ntauri-build = { version = \"2.0.0\" }\n\n[dependencies]\nserde_json = \"1.0\"\nserde = { version = \"1.0\", features = [\"derive\"] }\ntauri = { version = \"2.0.0\", features = [ ] }",
      "context": "rust_backend",
      "file_path": "Cargo.toml",
      "description": "Below is an example of a barebones `Cargo",
      "dependencies": null
    },
    {
      "language": "json",
      "code": "{\n  \"scripts\": {\n    \"dev\": \"command to start your app development mode\",\n    \"build\": \"command to build your app frontend\",\n    \"tauri\": \"tauri\"\n  },\n  \"dependencies\": {\n    \"@tauri-apps/api\": \"^2.0.0.0\",\n    \"@tauri-apps/cli\": \"^2.0.0.0\"\n  }\n}",
      "context": "frontend_integration",
      "file_path": "package.json",
      "description": "An example of a barebones `package",
      "dependencies": null
    },
    {
      "language": "json",
      "code": "{\n  \"build\": {\n    \"beforeDevCommand\": \"yarn dev\",\n    \"beforeBuildCommand\": \"yarn build\"\n  }\n}",
      "context": "command",
      "file_path": "tauri.conf.json",
      "description": "json` file specifies the `dev` command that you can run using `yarn dev` or `npm run dev` to start the frontend framework and the `build` command that you can run using `yarn build` or `npm run build` to build your frontend's Web assets to be added by Tauri in production",
      "dependencies": null
    },
    {
      "language": "json",
      "code": "{\n  // Use IntelliSense to learn about possible attributes.\n  // Hover to view descriptions of existing attributes.\n  // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387\n  \"version\": \"0.2.0\",\n  \"configurations\": [\n    {\n      \"type\": \"lldb\",\n      \"request\": \"launch\",\n      \"name\": \"Tauri Development Debug\",\n      \"cargo\": {\n        \"args\": [\n          \"build\",\n          \"--manifest-path=./src-tauri/Cargo.toml\",\n          \"--no-default-features\"\n        ]\n      },\n      // task for the `beforeDevCommand` if used, must be configured in `.vscode/tasks.json`\n      \"preLaunchTask\": \"ui:dev\"\n    },\n    {\n      \"type\": \"lldb\",\n      \"request\": \"launch\",\n      \"name\": \"Tauri Production Debug\",\n      \"cargo\": {\n        \"args\": [\"build\", \"--release\", \"--manifest-path=./src-tauri/Cargo.toml\"]\n      },\n      // task for the `beforeBuildCommand` if used, must be configured in `.vscode/tasks.json`\n      \"preLaunchTask\": \"ui:build\"\n    }\n  ]\n}",
      "context": "general",
      "file_path": ".vscode/launch.json",
      "description": "vscode/launch",
      "dependencies": null
    },
    {
      "language": "json",
      "code": "{\n  // See https://go.microsoft.com/fwlink/?LinkId=733558\n  // for the documentation about the tasks.json format\n  \"version\": \"2.0.0\",\n  \"tasks\": [\n    {\n      \"label\": \"ui:dev\",\n      \"type\": \"shell\",\n      // `dev` keeps running in the background\n      // ideally you should also configure a `problemMatcher`\n      // see https://code.visualstudio.com/docs/editor/tasks#_can-a-background-task-be-used-as-a-prelaunchtask-in-launchjson\n      \"isBackground\": true,\n      // change this to your `beforeDevCommand`:\n      \"command\": \"yarn\",\n      \"args\": [\"dev\"]\n    },\n    {\n      \"label\": \"ui:build\",\n      \"type\": \"shell\",\n      // change this to your `beforeBuildCommand`:\n      \"command\": \"yarn\",\n      \"args\": [\"build\"]\n    }\n  ]\n}",
      "context": "command",
      "file_path": ".vscode/tasks.json",
      "description": "vscode/tasks",
      "dependencies": null
    },
    {
      "language": "json",
      "code": "{\n  // Use IntelliSense to learn about possible attributes.\n  // Hover to view descriptions of existing attributes.\n  // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387\n  \"version\": \"0.2.0\",\n  \"configurations\": [\n    {\n      \"name\": \"Launch App Debug\",\n      \"type\": \"cppvsdbg\",\n      \"request\": \"launch\",\n      // change the exe name to your actual exe name\n      // (to debug release builds, change `target/debug` to `release/debug`)\n      \"program\": \"${workspaceRoot}/src-tauri/target/debug/your-app-name-here.exe\",\n      \"cwd\": \"${workspaceRoot}\",\n      \"preLaunchTask\": \"ui:dev\"\n    }\n  ]\n}",
      "context": "window_management",
      "file_path": ".vscode/launch.json",
      "description": "json and tasks",
      "dependencies": null
    },
    {
      "language": "json",
      "code": "{\n  // See https://go.microsoft.com/fwlink/?LinkId=733558\n  // for the documentation about the tasks.json format\n  \"version\": \"2.0.0\",\n  \"tasks\": [\n    {\n      \"label\": \"build:debug\",\n      \"type\": \"cargo\",\n      \"command\": \"build\",\n      \"options\": {\n        \"cwd\": \"${workspaceRoot}/src-tauri\"\n      }\n    },\n    {\n      \"label\": \"ui:dev\",\n      \"type\": \"shell\",\n      // `dev` keeps running in the background\n      // ideally you should also configure a `problemMatcher`\n      // see https://code.visualstudio.com/docs/editor/tasks#_can-a-background-task-be-used-as-a-prelaunchtask-in-launchjson\n      \"isBackground\": true,\n      // change this to your `beforeDevCommand`:\n      \"command\": \"yarn\",\n      \"args\": [\"dev\"]\n    },\n    {\n      \"label\": \"dev\",\n      \"dependsOn\": [\"build:debug\", \"ui:dev\"],\n      \"group\": {\n        \"kind\": \"build\"\n      }\n    }\n  ]\n}",
      "context": "command",
      "file_path": ".vscode/tasks.json",
      "description": "json` to `dev` (or anything you named your group)",
      "dependencies": null
    },
    {
      "language": "json",
      "code": "{\n  \"build\": {\n    \"devUrl\": \"http://localhost:3000\",\n    \"beforeDevCommand\": \"npm run dev\"\n  }\n}",
      "context": "command",
      "file_path": "tauri.conf.json",
      "description": "astro';\n\nNow that you have [everything set up](/start/), you are ready to run your application using Tauri",
      "dependencies": null
    },
    {
      "language": "json",
      "code": "{\n  \"build\": {\n    \"frontendDist\": \"./src\"\n  }\n}",
      "context": "frontend_integration",
      "file_path": "tauri.conf.json",
      "description": "Please refer to your framework's documentation to learn more and determine the correct values to be configured",
      "dependencies": null
    },
    {
      "language": "js",
      "code": "import { defineConfig } from 'vite';\n\nconst host = process.env.TAURI_DEV_HOST;\n\n// https://vitejs.dev/config/\nexport default defineConfig({\n  clearScreen: false,\n  server: {\n    host: host || false,\n    port: 1420,\n    strictPort: true,\n    hmr: host\n      ? {\n          protocol: 'ws',\n          host,\n          port: 1421,\n        }\n      : undefined,\n  },\n});",
      "context": "general",
      "file_path": null,
      "description": "To make your development server listen on the correct host to be accessible by the iOS device you must tweak its configuration\nto use the `TAURI_DEV_HOST` value if it has been provided",
      "dependencies": null
    },
    {
      "language": "ts",
      "code": "import { listen } from '@tauri-apps/api/event';\n\n  type DownloadStarted = {\n    url: string;\n    downloadId: number;\n    contentLength: number;\n  };\n\n  listen<DownloadStarted>('download-started', (event) => {\n    console.log(\n      `downloading ${event.payload.contentLength} bytes from ${event.payload.url}`\n    );\n  });",
      "context": "frontend_integration",
      "file_path": null,
      "description": "---\ntitle: Calling the Frontend from Rust\n---\n\nThe `@tauri-apps/api` NPM package offers APIs to listen to both global and webview-specific events",
      "dependencies": null
    },
    {
      "language": "ts",
      "code": "import { getCurrentWebviewWindow } from '@tauri-apps/api/webviewWindow';\n\n  const appWebview = getCurrentWebviewWindow();\n  appWebview.listen<string>('logged-in', (event) => {\n    localStorage.setItem('session-token', event.payload);\n  });",
      "context": "general",
      "file_path": null,
      "description": "payload",
      "dependencies": null
    },
    {
      "language": "js",
      "code": "import { listen } from '@tauri-apps/api/event';\n\nconst unlisten = await listen('download-started', (event) => {});\nunlisten();",
      "context": "general",
      "file_path": null,
      "description": "payload);\n  });\n  ```\n\nThe `listen` function keeps the event listener registered for the entire lifetime of the application",
      "dependencies": null
    },
    {
      "language": "js",
      "code": "import { once } from '@tauri-apps/api/event';\nimport { getCurrentWebviewWindow } from '@tauri-apps/api/webviewWindow';\n\nonce('ready', (event) => {});\n\nconst appWebview = getCurrentWebviewWindow();\nappWebview.once('ready', () => {});",
      "context": "general",
      "file_path": null,
      "description": "This does not apply to a Single Page Application (SPA) router though",
      "dependencies": null
    },
    {
      "language": "rust",
      "code": "use tauri::Listener;\n\n  #[cfg_attr(mobile, tauri::mobile_entry_point)]\n  pub fn run() {\n    tauri::Builder::default()\n      .setup(|app| {\n        app.listen(\"download-started\", |event| {\n          if let Ok(payload) = serde_json::from_str::<DownloadStarted>(&event.payload()) {\n            println!(\"downloading {}\", payload.url);\n          }\n        });\n        Ok(())\n      })\n      .run(tauri::generate_context!())\n      .expect(\"error while running tauri application\");\n  }",
      "context": "frontend_integration",
      "file_path": "src-tauri/src/lib.rs",
      "description": ":::\n\n#### Listening to Events on Rust\n\nGlobal and webview-specific events are also delivered to listeners registered in Rust",
      "dependencies": null
    },
    {
      "language": "rust",
      "code": "use tauri::{Listener, Manager};\n\n  #[cfg_attr(mobile, tauri::mobile_entry_point)]\n  pub fn run() {\n    tauri::Builder::default()\n      .setup(|app| {\n        let webview = app.get_webview_window(\"main\").unwrap();\n        webview.listen(\"logged-in\", |event| {\n          let session_token = event.data;\n          // save token..\n        });\n        Ok(())\n      })\n      .run(tauri::generate_context!())\n      .expect(\"error while running tauri application\");\n  }",
      "context": "general",
      "file_path": "src-tauri/src/lib.rs",
      "description": "run(tauri::generate_context!())",
      "dependencies": null
    },
    {
      "language": "rust",
      "code": "// unlisten outside of the event handler scope:\nlet event_id = app.listen(\"download-started\", |event| {});\napp.unlisten(event_id);\n\n// unlisten when some event criteria is matched\nlet handle = app.handle().clone();\napp.listen(\"status-changed\", |event| {\n  if event.data == \"ready\" {\n    handle.unlisten(event.id);\n  }\n});",
      "context": "general",
      "file_path": null,
      "description": "expect(\"error while running tauri application\");\n  }\n  ```\n\nThe `listen` function keeps the event listener registered for the entire lifetime of the application",
      "dependencies": null
    },
    {
      "language": "rust",
      "code": "app.once(\"ready\", |event| {\n  println!(\"app is ready\");\n});",
      "context": "general",
      "file_path": null,
      "description": "unlisten(event",
      "dependencies": null
    },
    {
      "language": "console",
      "code": "> pnpm tauri icon --help\n\nGenerate various icons for all major platforms\n\nUsage: pnpm run tauri icon [OPTIONS] [INPUT]\n\nArguments:\n  [INPUT]  Path to the source icon (squared PNG or SVG file with transparency) [default: ./app-icon.png]\n\nOptions:\n  -o, --output <OUTPUT>        Output directory. Default: 'icons' directory next to the tauri.conf.json file\n  -v, --verbose...             Enables verbose logging\n  -p, --png <PNG>              Custom PNG icon sizes to generate. When set, the default icons are not generated\n      --ios-color <IOS_COLOR>  The background color of the iOS icon - string as defined in the W3C's CSS Color Module Level 4 <https://www.w3.org/TR/css-color-4/> [default: #fff]\n  -h, --help                   Print help\n  -V, --version                Print version",
      "context": "command",
      "file_path": null,
      "description": "Therefore we recommend including all icons even if you intend to only build for a subset of platforms",
      "dependencies": null
    },
    {
      "language": "json",
      "code": "{\n  \"bundle\": {\n    \"icon\": [\n      \"icons/32x32.png\",\n      \"icons/128x128.png\",\n      \"icons/128x128@2x.png\",\n      \"icons/icon.icns\",\n      \"icons/icon.ico\"\n    ]\n  }\n}",
      "context": "general",
      "file_path": null,
      "description": "conf",
      "dependencies": null
    },
    {
      "language": "console",
      "code": "> pnpm tauri icon --help\n\nGenerate various icons for all major platforms\n\nUsage: pnpm run tauri icon [OPTIONS] [INPUT]\n\nArguments:\n  [INPUT]  Path to the source icon (squared PNG or SVG file with transparency) [default: ./app-icon.png]\n\nOptions:\n  -o, --output <OUTPUT>        Output directory. Default: 'icons' directory next to the tauri.conf.json file\n  -v, --verbose...             Enables verbose logging\n  -p, --png <PNG>              Custom PNG icon sizes to generate. When set, the default icons are not generated\n      --ios-color <IOS_COLOR>  The background color of the iOS icon - string as defined in the W3C's CSS Color Module Level 4 <https://www.w3.org/TR/css-color-4/> [default: #fff]\n  -h, --help                   Print help\n  -V, --version                Print version",
      "context": "command",
      "file_path": null,
      "description": "Therefore we recommend including all icons even if you intend to only build for a subset of platforms",
      "dependencies": null
    },
    {
      "language": "json",
      "code": "{\n  \"bundle\": {\n    \"icon\": [\n      \"icons/32x32.png\",\n      \"icons/128x128.png\",\n      \"icons/128x128@2x.png\",\n      \"icons/icon.icns\",\n      \"icons/icon.ico\"\n    ]\n  }\n}",
      "context": "general",
      "file_path": null,
      "description": "conf",
      "dependencies": null
    },
    {
      "language": "toml",
      "code": "// src-tauri/Cargo.toml\n[lib]\nname = \"app_lib\"\ncrate-type = [\"staticlib\", \"cdylib\", \"rlib\"]",
      "context": "general",
      "file_path": null,
      "description": "Change the Cargo manifest to produce the library",
      "dependencies": null
    },
    {
      "language": "rust",
      "code": "// src-tauri/src/lib.rs\n#[cfg_attr(mobile, tauri::mobile_entry_point)]\npub fn run() {\n    // your code here\n}",
      "context": "general",
      "file_path": null,
      "description": "Rename the `main` function header in `lib",
      "dependencies": null
    },
    {
      "language": "rust",
      "code": "// src-tauri/src/main.rs\n#![cfg_attr(not(debug_assertions), windows_subsystem = \"windows\")]\n\nfn main() {\n  app_lib::run();\n}",
      "context": "general",
      "file_path": null,
      "description": "Recreate the `main",
      "dependencies": null
    },
    {
      "language": "diff",
      "code": "- import { invoke } from \"@tauri-apps/api/tauri\"\n+ import { invoke } from \"@tauri-apps/api/core\"",
      "context": "general",
      "file_path": null,
      "description": "### Migrate to Core Module\n\nThe `@tauri-apps/api/tauri` module was renamed to `@tauri-apps/api/core`",
      "dependencies": null
    },
    {
      "language": "toml",
      "code": "# Cargo.toml\n[dependencies]\ntauri-plugin-cli = \"2\"",
      "context": "plugin",
      "file_path": null,
      "description": "Use the `@tauri-apps/plugin-cli` plugin instead:\n\n1",
      "dependencies": null
    },
    {
      "language": "rust",
      "code": "fn main() {\n    tauri::Builder::default()\n        .plugin(tauri_plugin_cli::init())\n}",
      "context": "plugin",
      "file_path": null,
      "description": "toml\n[dependencies]\ntauri-plugin-cli = \"2\"\n```\n\n2",
      "dependencies": null
    },
    {
      "language": "json",
      "code": "// package.json\n{\n  \"dependencies\": {\n    \"@tauri-apps/plugin-cli\": \"^2.0.0\"\n  }\n}",
      "context": "plugin",
      "file_path": null,
      "description": "Use in JavaScript or Rust project:\n\n<Tabs syncKey=\"lang\">\n<TabItem label=\"JavaScript\">\n\n```rust\nfn main() {\n    tauri::Builder::default()",
      "dependencies": null
    },
    {
      "language": "javascript",
      "code": "import { getMatches } from '@tauri-apps/plugin-cli';\nconst matches = await getMatches();",
      "context": "plugin",
      "file_path": null,
      "description": "0",
      "dependencies": null
    },
    {
      "language": "rust",
      "code": "fn main() {\n    use tauri_plugin_cli::CliExt;\n    tauri::Builder::default()\n        .plugin(tauri_plugin_cli::init())\n        .setup(|app| {\n            let cli_matches = app.cli().matches()?;\n            Ok(())\n        })\n}",
      "context": "plugin",
      "file_path": null,
      "description": "0",
      "dependencies": null
    },
    {
      "language": "toml",
      "code": "[dependencies]\ntauri-plugin-clipboard-manager = \"2\"",
      "context": "plugin",
      "file_path": null,
      "description": "matches()?;\n            Ok(())\n        })\n}\n```\n\n</TabItem>\n</Tabs>\n\n### Migrate to Clipboard Plugin\n\nThe Rust `App::clipboard_manager` and `AppHandle::clipboard_manager` and JavaScript `@tauri-apps/api/clipboard` APIs have been removed",
      "dependencies": null
    },
    {
      "language": "rust",
      "code": "fn main() {\n    tauri::Builder::default()\n        .plugin(tauri_plugin_clipboard_manager::init())\n}",
      "context": "plugin",
      "file_path": null,
      "description": "matches()?;\n            Ok(())\n        })\n}\n```\n\n</TabItem>\n</Tabs>\n\n### Migrate to Clipboard Plugin\n\nThe Rust `App::clipboard_manager` and `AppHandle::clipboard_manager` and JavaScript `@tauri-apps/api/clipboard` APIs have been removed",
      "dependencies": null
    },
    {
      "language": "json",
      "code": "// package.json\n{\n  \"dependencies\": {\n    \"@tauri-apps/plugin-clipboard-manager\": \"^2.0.0\"\n  }\n}",
      "context": "plugin",
      "file_path": null,
      "description": "Use the `@tauri-apps/plugin-clipboard-manager` plugin instead:\n\n```toml\n[dependencies]\ntauri-plugin-clipboard-manager = \"2\"\n```\n\n<Tabs syncKey=\"lang\">\n<TabItem label=\"JavaScript\">\n\n```rust\nfn main() {\n    tauri::Builder::default()",
      "dependencies": null
    },
    {
      "language": "javascript",
      "code": "import { writeText, readText } from '@tauri-apps/plugin-clipboard-manager';\nawait writeText('Tauri is awesome!');\nassert(await readText(), 'Tauri is awesome!');",
      "context": "plugin",
      "file_path": null,
      "description": "0",
      "dependencies": null
    },
    {
      "language": "rust",
      "code": "use tauri_plugin_clipboard::{ClipboardExt, ClipKind};\ntauri::Builder::default()\n    .plugin(tauri_plugin_clipboard::init())\n    .setup(|app| {\n        app.clipboard().write(ClipKind::PlainText {\n            label: None,\n            text: \"Tauri is awesome!\".into(),\n        })?;\n        Ok(())\n    })",
      "context": "plugin",
      "file_path": null,
      "description": "0",
      "dependencies": null
    },
    {
      "language": "toml",
      "code": "# Cargo.toml\n[dependencies]\ntauri-plugin-dialog = \"2\"",
      "context": "plugin",
      "file_path": null,
      "description": "Use the `@tauri-apps/plugin-dialog` plugin instead:\n\n1",
      "dependencies": null
    },
    {
      "language": "rust",
      "code": "fn main() {\n    tauri::Builder::default()\n        .plugin(tauri_plugin_dialog::init())\n}",
      "context": "plugin",
      "file_path": null,
      "description": "toml\n[dependencies]\ntauri-plugin-dialog = \"2\"\n```\n\n2",
      "dependencies": null
    },
    {
      "language": "json",
      "code": "// package.json\n{\n  \"dependencies\": {\n    \"@tauri-apps/plugin-dialog\": \"^2.0.0\"\n  }\n}",
      "context": "plugin",
      "file_path": null,
      "description": "Use in JavaScript or Rust project:\n\n<Tabs syncKey=\"lang\">\n<TabItem label=\"JavaScript\">\n\n```rust\nfn main() {\n    tauri::Builder::default()",
      "dependencies": null
    },
    {
      "language": "javascript",
      "code": "import { save } from '@tauri-apps/plugin-dialog';\nconst filePath = await save({\n  filters: [\n    {\n      name: 'Image',\n      extensions: ['png', 'jpeg'],\n    },\n  ],\n});",
      "context": "plugin",
      "file_path": null,
      "description": "0",
      "dependencies": null
    },
    {
      "language": "rust",
      "code": "use tauri_plugin_dialog::DialogExt;\ntauri::Builder::default()\n    .plugin(tauri_plugin_dialog::init())\n    .setup(|app| {\n        app.dialog().file().pick_file(|file_path| {\n            // do something with the optional file path here\n            // the file path is `None` if the user closed the dialog\n        });\n\n        app.dialog().message(\"Tauri is Awesome!\").show();\n        Ok(())\n     })",
      "context": "plugin",
      "file_path": null,
      "description": "0",
      "dependencies": null
    },
    {
      "language": "toml",
      "code": "# Cargo.toml\n[dependencies]\ntauri-plugin-fs = \"2\"",
      "context": "plugin",
      "file_path": null,
      "description": "org/std/fs/) for Rust and `@tauri-apps/plugin-fs` plugin for JavaScript instead:\n\n1",
      "dependencies": null
    },
    {
      "language": "rust",
      "code": "fn main() {\n    tauri::Builder::default()\n        .plugin(tauri_plugin_fs::init())\n}",
      "context": "plugin",
      "file_path": null,
      "description": "toml\n[dependencies]\ntauri-plugin-fs = \"2\"\n```\n\n2",
      "dependencies": null
    },
    {
      "language": "json",
      "code": "// package.json\n{\n  \"dependencies\": {\n    \"@tauri-apps/plugin-fs\": \"^2.0.0\"\n  }\n}",
      "context": "plugin",
      "file_path": null,
      "description": "Use in JavaScript or Rust project:\n\n<Tabs syncKey=\"lang\">\n<TabItem label=\"JavaScript\">\n\n```rust\nfn main() {\n    tauri::Builder::default()",
      "dependencies": null
    },
    {
      "language": "javascript",
      "code": "import { mkdir, BaseDirectory } from '@tauri-apps/plugin-fs';\nawait mkdir('db', { baseDir: BaseDirectory.AppLocalData });",
      "context": "plugin",
      "file_path": null,
      "description": "0",
      "dependencies": null
    },
    {
      "language": "toml",
      "code": "# Cargo.toml\n[dependencies]\n[target.\"cfg(not(any(target_os = \\\"android\\\", target_os = \\\"ios\\\")))\".dependencies]\ntauri-plugin-global-shortcut = \"2\"",
      "context": "plugin",
      "file_path": null,
      "description": "Use the `@tauri-apps/plugin-global-shortcut` plugin instead:\n\n1",
      "dependencies": null
    },
    {
      "language": "rust",
      "code": "fn main() {\n    tauri::Builder::default()\n        .plugin(tauri_plugin_global_shortcut::Builder::default().build())\n}",
      "context": "plugin",
      "file_path": null,
      "description": "dependencies]\ntauri-plugin-global-shortcut = \"2\"\n```\n\n2",
      "dependencies": null
    },
    {
      "language": "json",
      "code": "// package.json\n{\n  \"dependencies\": {\n    \"@tauri-apps/plugin-global-shortcut\": \"^2.0.0\"\n  }\n}",
      "context": "plugin",
      "file_path": null,
      "description": "plugin(tauri_plugin_global_shortcut::Builder::default()",
      "dependencies": null
    },
    {
      "language": "javascript",
      "code": "import { register } from '@tauri-apps/plugin-global-shortcut';\nawait register('CommandOrControl+Shift+C', () => {\n  console.log('Shortcut triggered');\n});",
      "context": "plugin",
      "file_path": null,
      "description": "0",
      "dependencies": null
    },
    {
      "language": "rust",
      "code": "use tauri_plugin_global_shortcut::GlobalShortcutExt;\n\ntauri::Builder::default()\n    .plugin(\n        tauri_plugin_global_shortcut::Builder::new().with_handler(|app, shortcut| {\n            println!(\"Shortcut triggered: {:?}\", shortcut);\n        })\n        .build(),\n    )\n    .setup(|app| {\n        // register a global shortcut\n        // on macOS, the Cmd key is used\n        // on Windows and Linux, the Ctrl key is used\n        app.global_shortcut().register(\"CmdOrCtrl+Y\")?;\n        Ok(())\n    })",
      "context": "command",
      "file_path": null,
      "description": "0\"\n  }\n}\n```\n\n```javascript\nimport { register } from '@tauri-apps/plugin-global-shortcut';\nawait register('CommandOrControl+Shift+C', () => {\n  console",
      "dependencies": null
    },
    {
      "language": "toml",
      "code": "# Cargo.toml\n[dependencies]\ntauri-plugin-http = \"2\"",
      "context": "plugin",
      "file_path": null,
      "description": "Use the `@tauri-apps/plugin-http` plugin instead:\n\n1",
      "dependencies": null
    },
    {
      "language": "rust",
      "code": "fn main() {\n    tauri::Builder::default()\n        .plugin(tauri_plugin_http::init())\n}",
      "context": "plugin",
      "file_path": null,
      "description": "toml\n[dependencies]\ntauri-plugin-http = \"2\"\n```\n\n2",
      "dependencies": null
    },
    {
      "language": "json",
      "code": "// package.json\n{\n  \"dependencies\": {\n    \"@tauri-apps/plugin-http\": \"^2.0.0\"\n  }\n}",
      "context": "plugin",
      "file_path": null,
      "description": "Use in JavaScript or Rust project:\n\n<Tabs syncKey=\"lang\">\n<TabItem label=\"JavaScript\">\n\n```rust\nfn main() {\n    tauri::Builder::default()",
      "dependencies": null
    },
    {
      "language": "javascript",
      "code": "import { fetch } from '@tauri-apps/plugin-http';\nconst response = await fetch(\n  'https://raw.githubusercontent.com/tauri-apps/tauri/dev/package.json'\n);",
      "context": "plugin",
      "file_path": null,
      "description": "0",
      "dependencies": null
    },
    {
      "language": "rust",
      "code": "use tauri_plugin_http::reqwest;\n\ntauri::Builder::default()\n    .plugin(tauri_plugin_http::init())\n    .setup(|app| {\n        let response_data = tauri::async_runtime::block_on(async {\n            let response = reqwest::get(\n                \"https://raw.githubusercontent.com/tauri-apps/tauri/dev/package.json\",\n            )\n            .await\n            .unwrap();\n            response.text().await\n        })?;\n        Ok(())\n    })",
      "context": "plugin",
      "file_path": null,
      "description": "com/tauri-apps/tauri/dev/package",
      "dependencies": null
    },
    {
      "language": "toml",
      "code": "# Cargo.toml\n[dependencies]\ntauri-plugin-notification = \"2\"",
      "context": "plugin",
      "file_path": null,
      "description": "Use the `@tauri-apps/plugin-notification` plugin instead:\n\n1",
      "dependencies": null
    },
    {
      "language": "rust",
      "code": "fn main() {\n    tauri::Builder::default()\n        .plugin(tauri_plugin_notification::init())\n}",
      "context": "plugin",
      "file_path": null,
      "description": "toml\n[dependencies]\ntauri-plugin-notification = \"2\"\n```\n\n2",
      "dependencies": null
    },
    {
      "language": "json",
      "code": "// package.json\n{\n  \"dependencies\": {\n    \"@tauri-apps/plugin-notification\": \"^2.0.0\"\n  }\n}",
      "context": "plugin",
      "file_path": null,
      "description": "Use in JavaScript or Rust project:\n\n<Tabs syncKey=\"lang\">\n<TabItem label=\"JavaScript\">\n\n```rust\nfn main() {\n    tauri::Builder::default()",
      "dependencies": null
    },
    {
      "language": "javascript",
      "code": "import { sendNotification } from '@tauri-apps/plugin-notification';\nsendNotification('Tauri is awesome!');",
      "context": "plugin",
      "file_path": null,
      "description": "0",
      "dependencies": null
    },
    {
      "language": "rust",
      "code": "use tauri_plugin_notification::NotificationExt;\nuse tauri::plugin::PermissionState;\n\nfn main() {\n    tauri::Builder::default()\n        .plugin(tauri_plugin_notification::init())\n        .setup(|app| {\n            if app.notification().permission_state()? == PermissionState::Unknown {\n                app.notification().request_permission()?;\n            }\n            if app.notification().permission_state()? == PermissionState::Granted {\n                app.notification()\n                    .builder()\n                    .body(\"Tauri is awesome!\")\n                    .show()?;\n            }\n            Ok(())\n        })\n}",
      "context": "plugin",
      "file_path": null,
      "description": "0",
      "dependencies": null
    },
    {
      "language": "rust",
      "code": "use tauri::menu::MenuBuilder;\n\ntauri::Builder::default()\n    .setup(|app| {\n        let menu = MenuBuilder::new(app)\n            .copy()\n            .paste()\n            .separator()\n            .undo()\n            .redo()\n            .text(\"open-url\", \"Open URL\")\n            .check(\"toggle\", \"Toggle\")\n            .icon(\"show-app\", \"Show App\", app.default_window_icon().cloned().unwrap())\n            .build()?;\n        Ok(())\n    })",
      "context": "window_management",
      "file_path": null,
      "description": "#### Use `tauri::menu::MenuBuilder`\n\nUse `tauri::menu::MenuBuilder` instead of `tauri::Menu`",
      "dependencies": null
    },
    {
      "language": "rust",
      "code": "use tauri::menu::{MenuBuilder, PredefinedMenuItem};\n\ntauri::Builder::default()\n    .setup(|app| {\n        let menu = MenuBuilder::new(app).item(&PredefinedMenuItem::copy(app)?).build()?;\n        Ok(())\n    })",
      "context": "window_management",
      "file_path": null,
      "description": "unwrap())",
      "dependencies": null
    },
    {
      "language": "rust",
      "code": "use tauri::menu::MenuItemBuilder;\n\ntauri::Builder::default()\n    .setup(|app| {\n        let toggle = MenuItemBuilder::new(\"Toggle\").accelerator(\"Ctrl+Shift+T\").build(app)?;\n        Ok(())\n    })",
      "context": "general",
      "file_path": null,
      "description": "item(&PredefinedMenuItem::copy(app, None)?)`",
      "dependencies": null
    },
    {
      "language": "rust",
      "code": "use tauri::menu::{MenuBuilder, SubmenuBuilder};\n\ntauri::Builder::default()\n    .setup(|app| {\n        let submenu = SubmenuBuilder::new(app, \"Sub\")\n            .text(\"Tauri\")\n            .separator()\n            .check(\"Is Awesome\")\n            .build()?;\n        let menu = MenuBuilder::new(app).item(&submenu).build()?;\n        Ok(())\n    })",
      "context": "general",
      "file_path": null,
      "description": "accelerator(\"Ctrl+Shift+T\")",
      "dependencies": null
    },
    {
      "language": "rust",
      "code": "use tauri::menu::{CheckMenuItemBuilder, MenuBuilder, MenuItemBuilder};\n\ntauri::Builder::default()\n    .setup(|app| {\n        let toggle = MenuItemBuilder::with_id(\"toggle\", \"Toggle\").build(app)?;\n        let check = CheckMenuItemBuilder::new(\"Mark\").build(app)?;\n        let menu = MenuBuilder::new(app).items(&[&toggle, &check]).build()?;\n\n        app.set_menu(menu)?;\n\n        app.on_menu_event(move |app, event| {\n            if event.id() == check.id() {\n                println!(\"`check` triggered, do something! is checked? {}\", check.is_checked().unwrap());\n            } else if event.id() == \"toggle\" {\n                println!(\"toggle triggered!\");\n            }\n        });\n        Ok(())\n    })",
      "context": "rust_backend",
      "file_path": null,
      "description": "#### Menu Events\n\nThe Rust `tauri::Builder::on_menu_event` API was removed",
      "dependencies": null
    },
    {
      "language": "toml",
      "code": "# Cargo.toml\n[dependencies]\ntauri-plugin-os = \"2\"",
      "context": "plugin",
      "file_path": null,
      "description": "Use the `@tauri-apps/plugin-os` plugin instead:\n\n1",
      "dependencies": null
    },
    {
      "language": "rust",
      "code": "fn main() {\n    tauri::Builder::default()\n        .plugin(tauri_plugin_os::init())\n}",
      "context": "plugin",
      "file_path": null,
      "description": "toml\n[dependencies]\ntauri-plugin-os = \"2\"\n```\n\n2",
      "dependencies": null
    },
    {
      "language": "json",
      "code": "// package.json\n{\n  \"dependencies\": {\n    \"@tauri-apps/plugin-os\": \"^2.0.0\"\n  }\n}",
      "context": "plugin",
      "file_path": null,
      "description": "Use in JavaScript or Rust project:\n\n<Tabs syncKey=\"lang\">\n<TabItem label=\"JavaScript\">\n\n```rust\nfn main() {\n    tauri::Builder::default()",
      "dependencies": null
    },
    {
      "language": "javascript",
      "code": "import { arch } from '@tauri-apps/plugin-os';\nconst architecture = await arch();",
      "context": "plugin",
      "file_path": null,
      "description": "0",
      "dependencies": null
    },
    {
      "language": "rust",
      "code": "fn main() {\n    tauri::Builder::default()\n        .plugin(tauri_plugin_os::init())\n        .setup(|app| {\n            let os_arch = tauri_plugin_os::arch();\n            Ok(())\n        })\n}",
      "context": "plugin",
      "file_path": null,
      "description": "0",
      "dependencies": null
    },
    {
      "language": "toml",
      "code": "# Cargo.toml\n[dependencies]\ntauri-plugin-process = \"2\"",
      "context": "plugin",
      "file_path": null,
      "description": "Use the `@tauri-apps/plugin-process` plugin instead:\n\n1",
      "dependencies": null
    },
    {
      "language": "rust",
      "code": "fn main() {\n    tauri::Builder::default()\n        .plugin(tauri_plugin_process::init())\n}",
      "context": "plugin",
      "file_path": null,
      "description": "toml\n[dependencies]\ntauri-plugin-process = \"2\"\n```\n\n2",
      "dependencies": null
    },
    {
      "language": "json",
      "code": "// package.json\n{\n  \"dependencies\": {\n    \"@tauri-apps/plugin-process\": \"^2.0.0\"\n  }\n}",
      "context": "plugin",
      "file_path": null,
      "description": "Use in JavaScript or Rust project:\n\n<Tabs syncKey=\"lang\">\n<TabItem label=\"JavaScript\">\n\n```rust\nfn main() {\n    tauri::Builder::default()",
      "dependencies": null
    },
    {
      "language": "javascript",
      "code": "import { exit, relaunch } from '@tauri-apps/plugin-process';\nawait exit(0);\nawait relaunch();",
      "context": "plugin",
      "file_path": null,
      "description": "0",
      "dependencies": null
    },
    {
      "language": "rust",
      "code": "fn main() {\n    tauri::Builder::default()\n        .plugin(tauri_plugin_process::init())\n        .setup(|app| {\n            // exit the app with a status code\n            app.handle().exit(1);\n            // restart the app\n            app.handle().restart();\n            Ok(())\n        })\n}",
      "context": "plugin",
      "file_path": null,
      "description": "0",
      "dependencies": null
    },
    {
      "language": "toml",
      "code": "# Cargo.toml\n[dependencies]\ntauri-plugin-shell = \"2\"",
      "context": "plugin",
      "file_path": null,
      "description": "Use the `@tauri-apps/plugin-shell` plugin instead:\n\n1",
      "dependencies": null
    },
    {
      "language": "rust",
      "code": "fn main() {\n    tauri::Builder::default()\n        .plugin(tauri_plugin_shell::init())\n}",
      "context": "plugin",
      "file_path": null,
      "description": "toml\n[dependencies]\ntauri-plugin-shell = \"2\"\n```\n\n2",
      "dependencies": null
    },
    {
      "language": "json",
      "code": "// package.json\n{\n  \"dependencies\": {\n    \"@tauri-apps/plugin-shell\": \"^2.0.0\"\n  }\n}",
      "context": "plugin",
      "file_path": null,
      "description": "Use in JavaScript or Rust project:\n\n<Tabs syncKey=\"lang\">\n<TabItem label=\"JavaScript\">\n\n```rust\nfn main() {\n    tauri::Builder::default()",
      "dependencies": null
    },
    {
      "language": "javascript",
      "code": "import { Command, open } from '@tauri-apps/plugin-shell';\nconst output = await Command.create('echo', 'message').execute();\n\nawait open('https://github.com/tauri-apps/tauri');",
      "context": "plugin",
      "file_path": null,
      "description": "0",
      "dependencies": null
    },
    {
      "language": "rust",
      "code": "use tauri_plugin_shell::ShellExt;\n\nfn main() {\n    tauri::Builder::default()\n        .plugin(tauri_plugin_shell::init())\n        .setup(|app| {\n            app.shell().open(\"https://github.com/tauri-apps/tauri\", None)?;\n            Ok(())\n        })\n}",
      "context": "command",
      "file_path": null,
      "description": "execute();\n\nawait open('https://github",
      "dependencies": null
    },
    {
      "language": "rust",
      "code": "use tauri_plugin_shell::ShellExt;\n\nfn main() {\n    tauri::Builder::default()\n        .plugin(tauri_plugin_shell::init())\n        .setup(|app| {\n            let status = tauri::async_runtime::block_on(async move { app.shell().command(\"which\").args([\"ls\"]).status().await.unwrap() });\n            println!(\"`which` finished with status: {:?}\", status.code());\n            Ok(())\n        })\n}",
      "context": "general",
      "file_path": null,
      "description": "open(\"https://github",
      "dependencies": null
    },
    {
      "language": "rust",
      "code": "use tauri_plugin_shell::ShellExt;\n\nfn main() {\n    tauri::Builder::default()\n        .plugin(tauri_plugin_shell::init())\n        .setup(|app| {\n            let output = tauri::async_runtime::block_on(async move { app.shell().command(\"echo\").args([\"TAURI\"]).output().await.unwrap() });\n            assert!(output.status.success());\n            assert_eq!(String::from_utf8(output.stdout).unwrap(), \"TAURI\");\n            Ok(())\n        })\n}",
      "context": "general",
      "file_path": null,
      "description": "unwrap() });\n            println!(\"`which` finished with status: {:?}\", status",
      "dependencies": null
    },
    {
      "language": "rust",
      "code": "use tauri_plugin_shell::{ShellExt, process::CommandEvent};\n\nfn main() {\n    tauri::Builder::default()\n        .plugin(tauri_plugin_shell::init())\n        .setup(|app| {\n            let handle = app.handle().clone();\n            tauri::async_runtime::spawn(async move {\n                let (mut rx, mut child) = handle.shell().command(\"cargo\")\n                    .args([\"tauri\", \"dev\"])\n                    .spawn()\n                    .expect(\"Failed to spawn cargo\");\n\n                let mut i = 0;\n                while let Some(event) = rx.recv().await {\n                    if let CommandEvent::Stdout(line) = event {\n                        println!(\"got: {}\", String::from_utf8(line).unwrap());\n                       i += 1;\n                       if i == 4 {\n                           child.write(\"message from Rust\\n\".as_bytes()).unwrap();\n                           i = 0;\n                       }\n                   }\n                }\n            });\n            Ok(())\n        })\n}",
      "context": "general",
      "file_path": null,
      "description": "stdout)",
      "dependencies": null
    },
    {
      "language": "rust",
      "code": "let tray = tauri::tray::TrayIconBuilder::with_id(\"my-tray\").build(app)?;",
      "context": "rust_backend",
      "file_path": null,
      "description": "The new APIs can be found in the Rust `tray` module",
      "dependencies": null
    },
    {
      "language": "rust",
      "code": "use tauri::{\n    menu::{MenuBuilder, MenuItemBuilder},\n    tray::{MouseButton, MouseButtonState, TrayIconBuilder, TrayIconEvent},\n};\n\ntauri::Builder::default()\n    .setup(|app| {\n        let toggle = MenuItemBuilder::with_id(\"toggle\", \"Toggle\").build(app)?;\n        let menu = MenuBuilder::new(app).items(&[&toggle]).build()?;\n        let tray = TrayIconBuilder::new()\n            .menu(&menu)\n            .on_menu_event(move |app, event| match event.id().as_ref() {\n                \"toggle\" => {\n                    println!(\"toggle clicked\");\n                }\n                _ => (),\n            })\n            .on_tray_icon_event(|tray, event| {\n                if let TrayIconEvent::Click {\n                        button: MouseButton::Left,\n                        button_state: MouseButtonState::Up,\n                        ..\n                } = event\n                {\n                    let app = tray.app_handle();\n                    if let Some(webview_window) = app.get_webview_window(\"main\") {\n                       let _ = webview_window.unminimize();\n                       let _ = webview_window.show();\n                       let _ = webview_window.set_focus();\n                    }\n                }\n            })\n            .build(app)?;\n\n        Ok(())\n    })",
      "context": "general",
      "file_path": null,
      "description": "#### Migrate to Menu\n\nUse `tauri::menu::Menu` instead of `tauri::SystemTrayMenu`, `tauri::menu::Submenu` instead of `tauri::SystemTraySubmenu` and `tauri::menu::PredefinedMenuItem` instead of `tauri::SystemTrayMenuItem`",
      "dependencies": null
    },
    {
      "language": "toml",
      "code": "[dependencies]\ntauri-plugin-updater = \"2\"",
      "context": "plugin",
      "file_path": null,
      "description": "To set a custom updater target with the `@tauri-apps/plugin-updater`:\n\n1",
      "dependencies": null
    },
    {
      "language": "rust",
      "code": "fn main() {\n    tauri::Builder::default()\n        .plugin(tauri_plugin_updater::Builder::new().build())\n}",
      "context": "plugin",
      "file_path": null,
      "description": "Add to cargo dependencies:\n\n```toml\n[dependencies]\ntauri-plugin-updater = \"2\"\n```\n\n2",
      "dependencies": null
    },
    {
      "language": "json",
      "code": "// package.json\n{\n  \"dependencies\": {\n    \"@tauri-apps/plugin-updater\": \"^2.0.0\"\n  }\n}",
      "context": "plugin",
      "file_path": null,
      "description": "plugin(tauri_plugin_updater::Builder::new()",
      "dependencies": null
    },
    {
      "language": "javascript",
      "code": "import { check } from '@tauri-apps/plugin-updater';\nimport { relaunch } from '@tauri-apps/plugin-process';\n\nconst update = await check();\nif (update?.available) {\n  console.log(`Update to ${update.version} available! Date: ${update.date}`);\n  console.log(`Release notes: ${update.body}`);\n  await update.downloadAndInstall();\n  // requires the `process` plugin\n  await relaunch();\n}",
      "context": "plugin",
      "file_path": null,
      "description": "0",
      "dependencies": null
    },
    {
      "language": "rust",
      "code": "use tauri_plugin_updater::UpdaterExt;\n\nfn main() {\n    tauri::Builder::default()\n        .plugin(tauri_plugin_updater::Builder::new().build())\n        .setup(|app| {\n            let handle = app.handle();\n            tauri::async_runtime::spawn(async move {\n                let response = handle.updater().check().await;\n            });\n            Ok(())\n        })\n}",
      "context": "plugin",
      "file_path": null,
      "description": "body}`);\n  await update",
      "dependencies": null
    },
    {
      "language": "rust",
      "code": "fn main() {\n    let mut updater = tauri_plugin_updater::Builder::new();\n    #[cfg(target_os = \"macos\")]\n    {\n        updater = updater.target(\"darwin-universal\");\n    }\n    tauri::Builder::default()\n        .plugin(updater.build())\n}",
      "context": "general",
      "file_path": null,
      "description": "check()",
      "dependencies": null
    },
    {
      "language": "rust",
      "code": "use tauri::{path::BaseDirectory, Manager};\n\ntauri::Builder::default()\n    .setup(|app| {\n        let home_dir_path = app.path().home_dir().expect(\"failed to get home dir\");\n\n        let path = app.path().resolve(\"path/to/something\", BaseDirectory::Config)?;\n\n        Ok(())\n  })",
      "context": "rust_backend",
      "file_path": null,
      "description": "plugin(updater",
      "dependencies": null
    },
    {
      "language": "json",
      "code": "...\n\"permissions\": [\n    \"path:default\",\n    \"event:default\",\n    \"window:default\",\n    \"app:default\",\n    \"image:default\",\n    \"resources:default\",\n    \"menu:default\",\n    \"tray:default\",\n]\n...",
      "context": "permissions",
      "file_path": null,
      "description": "To migrate from the latest beta version you need to prepend all core permission identifiers in your capabilities with `core:` or switch to the `core:default` permission and remove old core plugin identifiers",
      "dependencies": null
    },
    {
      "language": "json",
      "code": "...\n\"permissions\": [\n    \"core:path:default\",\n    \"core:event:default\",\n    \"core:window:default\",\n    \"core:app:default\",\n    \"core:image:default\",\n    \"core:resources:default\",\n    \"core:menu:default\",\n    \"core:tray:default\",\n]\n...",
      "context": "window_management",
      "file_path": null,
      "description": "",
      "dependencies": null
    },
    {
      "language": "json",
      "code": "...\n\"permissions\": [\n    \"core:default\"\n]\n...",
      "context": "permissions",
      "file_path": null,
      "description": "```\n\nWe also added a new special `core:default` permission set which will contain all default permissions of all core plugins, so you can simplify the permissions boilerplate in your capabilities config",
      "dependencies": null
    },
    {
      "language": "js",
      "code": "import { defineConfig } from 'vite';\nimport { svelte } from '@sveltejs/vite-plugin-svelte';\nimport { internalIpV4Sync } from 'internal-ip';\n\nconst mobile = !!/android|ios/.exec(process.env.TAURI_ENV_PLATFORM);\n\nexport default defineConfig({\n  plugins: [svelte()],\n  clearScreen: false,\n  server: {\n    host: mobile ? '0.0.0.0' : false,\n    port: 1420,\n    strictPort: true,\n    hmr: mobile\n      ? {\n          protocol: 'ws',\n          host: internalIpV4Sync(),\n          port: 1421,\n        }\n      : undefined,\n  },\n});",
      "context": "general",
      "file_path": null,
      "description": "0",
      "dependencies": null
    },
    {
      "language": "js",
      "code": "import { defineConfig } from 'vite';\nimport Unocss from 'unocss/vite';\nimport { svelte } from '@sveltejs/vite-plugin-svelte';\n\nconst host = process.env.TAURI_DEV_HOST;\n\nexport default defineConfig({\n  plugins: [svelte()],\n  clearScreen: false,\n  server: {\n    host: host || false,\n    port: 1420,\n    strictPort: true,\n    hmr: host\n      ? {\n          protocol: 'ws',\n          host: host,\n          port: 1430,\n        }\n      : undefined,\n  },\n});",
      "context": "general",
      "file_path": null,
      "description": "0",
      "dependencies": null
    },
    {
      "language": "sh",
      "code": "sudo apt update\nsudo apt install libwebkit2gtk-4.1-dev \\\n  build-essential \\\n  curl \\\n  wget \\\n  file \\\n  libxdo-dev \\\n  libssl-dev \\\n  libayatana-appindicator3-dev \\\n  librsvg2-dev",
      "context": "general",
      "file_path": null,
      "description": "These may be different depending on your distribution but we've included some popular distributions below to help you get setup",
      "dependencies": null
    },
    {
      "language": "sh",
      "code": "sudo pacman -Syu\nsudo pacman -S --needed \\\n  webkit2gtk-4.1 \\\n  base-devel \\\n  curl \\\n  wget \\\n  file \\\n  openssl \\\n  appmenu-gtk-module \\\n  libappindicator-gtk3 \\\n  librsvg \\\n  xdotool",
      "context": "general",
      "file_path": null,
      "description": "<Tabs syncKey=\"distro\">\n  <TabItem label=\"Debian\">\n\n```sh\nsudo apt update\nsudo apt install libwebkit2gtk-4",
      "dependencies": null
    },
    {
      "language": "sh",
      "code": "sudo dnf check-update\nsudo dnf install webkit2gtk4.1-devel \\\n  openssl-devel \\\n  curl \\\n  wget \\\n  file \\\n  libappindicator-gtk3-devel \\\n  librsvg2-devel \\\n  libxdo-devel\nsudo dnf group install \"c-development\"",
      "context": "general",
      "file_path": null,
      "description": "1-dev \\\n  build-essential \\\n  curl \\\n  wget \\\n  file \\\n  libxdo-dev \\\n  libssl-dev \\\n  libayatana-appindicator3-dev \\\n  librsvg2-dev\n```\n\n  </TabItem>\n  <TabItem label=\"Arch\">\n\n```sh\nsudo pacman -Syu\nsudo pacman -S --needed \\\n  webkit2gtk-4",
      "dependencies": null
    },
    {
      "language": "sh",
      "code": "sudo emerge --ask \\\n  net-libs/webkit-gtk:4.1 \\\n  dev-libs/libappindicator \\\n  net-misc/curl \\\n  net-misc/wget \\\n  sys-apps/file",
      "context": "general",
      "file_path": null,
      "description": "1 \\\n  base-devel \\\n  curl \\\n  wget \\\n  file \\\n  openssl \\\n  appmenu-gtk-module \\\n  libappindicator-gtk3 \\\n  librsvg \\\n  xdotool\n```\n\n  </TabItem>\n  <TabItem label=\"Fedora\">\n\n```sh\nsudo dnf check-update\nsudo dnf install webkit2gtk4",
      "dependencies": null
    },
    {
      "language": "sh",
      "code": "sudo zypper up\nsudo zypper in webkit2gtk3-devel \\\n  libopenssl-devel \\\n  curl \\\n  wget \\\n  file \\\n  libappindicator3-1 \\\n  librsvg-devel\nsudo zypper in -t pattern devel_basis",
      "context": "general",
      "file_path": null,
      "description": "1-devel \\\n  openssl-devel \\\n  curl \\\n  wget \\\n  file \\\n  libappindicator-gtk3-devel \\\n  librsvg2-devel \\\n  libxdo-devel\nsudo dnf group install \"c-development\"\n```\n\n  </TabItem>\n  <TabItem label=\"Gentoo\">\n\n```sh\nsudo emerge --ask \\\n  net-libs/webkit-gtk:4",
      "dependencies": null
    },
    {
      "language": "sh",
      "code": "sudo apk add \\\n  build-base \\\n  webkit2gtk \\\n  curl \\\n  wget \\\n  file \\\n  openssl \\\n  libayatana-appindicator-dev \\\n  librsvg",
      "context": "general",
      "file_path": null,
      "description": "devel\nsudo dnf group install \"c-development\"\n```\n\n  </TabItem>\n  <TabItem label=\"Gentoo\">\n\n```sh\nsudo emerge --ask \\\n  net-libs/webkit-gtk:4",
      "dependencies": null
    },
    {
      "language": "sh",
      "code": "xcode-select --install",
      "context": "command",
      "file_path": null,
      "description": "Be sure to launch Xcode after installing so that it can finish setting up",
      "dependencies": null
    },
    {
      "language": "sh",
      "code": "curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh",
      "context": "command",
      "file_path": null,
      "description": "<Tabs syncKey=\"OS\">\n  <TabItem label=\"Linux and macOS\" class=\"content\">\n\nInstall via [`rustup`](https://github",
      "dependencies": null
    },
    {
      "language": "powershell",
      "code": "winget install --id Rustlang.Rustup",
      "context": "command",
      "file_path": null,
      "description": "org/tools/install to install `rustup`",
      "dependencies": null
    },
    {
      "language": "powershell",
      "code": "rustup default stable-msvc",
      "context": "command",
      "file_path": null,
      "description": "Depending on your system it should be either `x86_64-pc-windows-msvc`, `i686-pc-windows-msvc`, or `aarch64-pc-windows-msvc`",
      "dependencies": null
    },
    {
      "language": "sh",
      "code": "node -v\n# v20.10.0\nnpm -v\n# 10.2.3",
      "context": "frontend_integration",
      "file_path": null,
      "description": "2",
      "dependencies": null
    },
    {
      "language": "sh",
      "code": "export JAVA_HOME=/opt/android-studio/jbr",
      "context": "general",
      "file_path": null,
      "description": "com/studio)\n2",
      "dependencies": null
    },
    {
      "language": "sh",
      "code": "export JAVA_HOME=\"/Applications/Android Studio.app/Contents/jbr/Contents/Home\"",
      "context": "general",
      "file_path": null,
      "description": "com/studio)\n2",
      "dependencies": null
    },
    {
      "language": "ps",
      "code": "[System.Environment]::SetEnvironmentVariable(\"JAVA_HOME\", \"C:\\Program Files\\Android\\Android Studio\\jbr\", \"User\")",
      "context": "window_management",
      "file_path": null,
      "description": "Set the `JAVA_HOME` environment variable:\n\n{/* TODO: Can this be done in the 4th step? */}\n\n<Tabs syncKey=\"prereqs\">\n<TabItem label=\"Linux\">\n\n```sh\nexport JAVA_HOME=/opt/android-studio/jbr\n```\n\n</TabItem>\n<TabItem label=\"macOS\">\n\n```sh\nexport JAVA_HOME=\"/Applications/Android Studio",
      "dependencies": null
    },
    {
      "language": "sh",
      "code": "export ANDROID_HOME=\"$HOME/Android/Sdk\"\nexport NDK_HOME=\"$ANDROID_HOME/ndk/$(ls -1 $ANDROID_HOME/ndk)\"",
      "context": "general",
      "file_path": null,
      "description": "Set `ANDROID_HOME` and `NDK_HOME` environment variables",
      "dependencies": null
    },
    {
      "language": "sh",
      "code": "export ANDROID_HOME=\"$HOME/Library/Android/sdk\"\nexport NDK_HOME=\"$ANDROID_HOME/ndk/$(ls -1 $ANDROID_HOME/ndk)\"",
      "context": "general",
      "file_path": null,
      "description": "Set `ANDROID_HOME` and `NDK_HOME` environment variables",
      "dependencies": null
    },
    {
      "language": "ps",
      "code": "[System.Environment]::SetEnvironmentVariable(\"ANDROID_HOME\", \"$env:LocalAppData\\Android\\Sdk\", \"User\")\n$VERSION = Get-ChildItem -Name \"$env:LocalAppData\\Android\\Sdk\\ndk\" | Select-Object -Last 1\n[System.Environment]::SetEnvironmentVariable(\"NDK_HOME\", \"$env:LocalAppData\\Android\\Sdk\\ndk\\$VERSION\", \"User\")",
      "context": "window_management",
      "file_path": null,
      "description": "Set `ANDROID_HOME` and `NDK_HOME` environment variables",
      "dependencies": null
    },
    {
      "language": "ps",
      "code": "[System.Environment]::GetEnvironmentVariables(\"User\").GetEnumerator() | % { Set-Item -Path \"Env:\\$($_.key)\" -Value $_.value }",
      "context": "general",
      "file_path": null,
      "description": "ironmentVariable(\"ANDROID_HOME\", \"$env:LocalAppData\\Android\\Sdk\", \"User\")\n$VERSION = Get-ChildItem -Name \"$env:LocalAppData\\Android\\Sdk\\ndk\" | Select-Object -Last 1\n[System",
      "dependencies": null
    },
    {
      "language": "sh",
      "code": "rustup target add aarch64-linux-android armv7-linux-androideabi i686-linux-android x86_64-linux-android",
      "context": "rust_backend",
      "file_path": null,
      "description": "value }\n```\n\n:::\n\n</TabItem>\n\n</Tabs>\n\n5",
      "dependencies": null
    },
    {
      "language": "sh",
      "code": "rustup target add aarch64-apple-ios x86_64-apple-ios aarch64-apple-ios-sim",
      "context": "command",
      "file_path": null,
      "description": ":::\n\n1",
      "dependencies": null
    },
    {
      "language": "sh",
      "code": "/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"",
      "context": "rust_backend",
      "file_path": null,
      "description": "Install [Homebrew](https://brew",
      "dependencies": null
    },
    {
      "language": "sh",
      "code": "brew install cocoapods",
      "context": "general",
      "file_path": null,
      "description": "Install [Cocoapods](https://cocoapods",
      "dependencies": null
    },
    {
      "language": "json",
      "code": "{\n  \"bundle\": {\n    \"resources\": [\n      \"/absolute/path/to/textfile.txt\",\n      \"relative/path/to/jsonfile.json\",\n      \"resources/**/*\"\n    ]\n  }\n}",
      "context": "general",
      "file_path": "tauri.conf.json",
      "description": "conf",
      "dependencies": null
    },
    {
      "language": "json",
      "code": "{\n  \"bundle\": {\n    \"resources\": {\n      \"/absolute/path/to/textfile.txt\": \"resources/textfile.txt\",\n      \"relative/path/to/jsonfile.json\": \"resources/jsonfile.json\",\n      \"resources/**/*\": \"resources/\"\n    }\n  }\n}",
      "context": "general",
      "file_path": "tauri.conf.json",
      "description": "json\",\n      \"resources/**/*\"\n    ]\n  }\n}\n```\n\nAlternatively the `resources` config also accepts a map object if you want to change where the files will be copied to",
      "dependencies": null
    },
    {
      "language": "json",
      "code": "{\n  \"hello\": \"Guten Tag!\",\n  \"bye\": \"Auf Wiedersehen!\"\n}",
      "context": "rust_backend",
      "file_path": "de.json",
      "description": "- `\"dir/**/**`: throws an error because `**` only matches directories and therefore no files can be found",
      "dependencies": null
    },
    {
      "language": "rust",
      "code": "tauri::Builder::default()\n  .setup(|app| {\n    // The path specified must follow the same syntax as defined in\n    // `tauri.conf.json > bundle > resources`\n    let resource_path = app.path().resolve(\"lang/de.json\", BaseDirectory::Resource)?;\n\n    let file = std::fs::File::open(&resource_path).unwrap();\n    let lang_de: serde_json::Value = serde_json::from_reader(file).unwrap();\n\n    // This will print 'Guten Tag!' to the terminal\n    println!(\"{}\", lang_de.get(\"hello\").unwrap());\n\n    Ok(())\n  })",
      "context": "rust_backend",
      "file_path": null,
      "description": "For this we add `\"lang/*\"` to `resources` as shown above",
      "dependencies": null
    },
    {
      "language": "rust",
      "code": "#[tauri::command]\nfn hello(handle: tauri::AppHandle) -> String {\n    let resource_path = handle.path().resolve(\"lang/de.json\", BaseDirectory::Resource)?;\n\n    let file = std::fs::File::open(&resource_path).unwrap();\n    let lang_de: serde_json::Value = serde_json::from_reader(file).unwrap();\n\n    lang_de.get(\"hello\").unwrap()\n}",
      "context": "general",
      "file_path": null,
      "description": "get(\"hello\")",
      "dependencies": null
    },
    {
      "language": "json",
      "code": "{\n  \"$schema\": \"../gen/schemas/desktop-schema.json\",\n  \"identifier\": \"main-capability\",\n  \"description\": \"Capability for the main window\",\n  \"windows\": [\"main\"],\n  \"permissions\": [\n    \"core:default\",\n    \"fs:allow-read-text-file\",\n    \"fs:allow-resource-read-recursive\"\n  ]\n}",
      "context": "permissions",
      "file_path": "src-tauri/capabilities/default.json ins={8-9}",
      "description": "get(\"hello\")",
      "dependencies": null
    },
    {
      "language": "javascript",
      "code": "import { resolveResource } from '@tauri-apps/api/path';\nimport { readTextFile } from '@tauri-apps/plugin-fs';\n\nconst resourcePath = await resolveResource('lang/de.json');\nconst langDe = JSON.parse(await readTextFile(resourcePath));\nconsole.log(langDe.hello); // This will print 'Guten Tag!' to the devtools console",
      "context": "permissions",
      "file_path": null,
      "description": "For more information, read [Scope Permissions] for other options, or [Scopes] for more fine-grained control",
      "dependencies": null
    },
    {
      "language": "js",
      "code": "const command = process.argv[2];\n\n    switch (command) {\n      case 'ping':\n        const message = process.argv[3];\n        console.log(`pong, ${message}`);\n        break;\n      default:\n        console.error(`unknown command ${command}`);\n        process.exit(1);\n    }",
      "context": "general",
      "file_path": "sidecar-app/index.js",
      "description": "js` file in our `sidecar-app` directory and write a basic Node",
      "dependencies": null
    },
    {
      "language": "js",
      "code": "import { execSync } from 'child_process';\n    import fs from 'fs';\n\n    const ext = process.platform === 'win32' ? '.exe' : '';\n\n    const rustInfo = execSync('rustc -vV');\n    const targetTriple = /host: (\\S+)/g.exec(rustInfo)[1];\n    if (!targetTriple) {\n      console.error('Failed to determine platform target triple');\n    }\n    fs.renameSync(\n      `app${ext}`,\n      `../src-tauri/binaries/app-${targetTriple}${ext}`\n    );",
      "context": "window_management",
      "file_path": null,
      "description": "To rename this file to the expected Tauri sidecar filename, we can use the following Node",
      "dependencies": null
    },
    {
      "language": "json",
      "code": "{\n      \"bundle\": {\n        \"externalBin\": [\"binaries/app\"]\n      }\n    }",
      "context": "general",
      "file_path": "src-tauri/tauri.conf.json",
      "description": "##### Configure the Sidecar in the Tauri Application\n\n    Now that we have our Node",
      "dependencies": null
    },
    {
      "language": "javascript",
      "code": "import { Command } from '@tauri-apps/plugin-shell';\n\n        const message = 'Tauri';\n\n        const command = Command.sidecar('binaries/app', ['ping', message]);\n        const output = await command.execute();\n        const response = output.stdout;",
      "context": "command",
      "file_path": null,
      "description": "<Tabs syncKey=\"lang\">\n\n      <TabItem label=\"JavaScript\">\n\n        Let's execute the `ping` command in the Node",
      "dependencies": null
    },
    {
      "language": "rust",
      "code": "#[tauri::command]\n        async fn ping(app: tauri::AppHandle, message: String) -> String {\n          let sidecar_command = app\n            .shell()\n            .sidecar(\"app\")\n            .unwrap()\n            .arg(\"ping\")\n            .arg(message);\n          let output = sidecar_command.output().unwrap();\n          let response = String::from_utf8(output.stdout).unwrap();\n          response\n        }",
      "context": "command",
      "file_path": null,
      "description": "stdout;\n        ```\n\n      </TabItem>\n\n      <TabItem label=\"Rust\">\n\n        Let's pipe a `ping` Tauri command to the Node",
      "dependencies": null
    },
    {
      "language": "json",
      "code": "{\n  \"bundle\": {\n    \"externalBin\": [\n      \"/absolute/path/to/sidecar\",\n      \"../relative/path/to/binary\",\n      \"binaries/my-sidecar\"\n    ]\n  }\n}",
      "context": "general",
      "file_path": "src-tauri/tauri.conf.json",
      "description": "The `externalBin` configuration expects a list of strings targeting binaries either with absolute or relative paths",
      "dependencies": null
    },
    {
      "language": "sh",
      "code": "rustc -Vv",
      "context": "command",
      "file_path": null,
      "description": "For instance, `\"externalBin\": [\"binaries/my-sidecar\"]` requires a `src-tauri/binaries/my-sidecar-x86_64-unknown-linux-gnu` executable on Linux or `src-tauri/binaries/my-sidecar-aarch64-apple-darwin` on Mac OS with Apple Silicon",
      "dependencies": null
    },
    {
      "language": "shell",
      "code": "rustc -Vv | grep host | cut -f2 -d' '",
      "context": "command",
      "file_path": null,
      "description": "idecar\"]` requires a `src-tauri/binaries/my-sidecar-x86_64-unknown-linux-gnu` executable on Linux or `src-tauri/binaries/my-sidecar-aarch64-apple-darwin` on Mac OS with Apple Silicon",
      "dependencies": null
    },
    {
      "language": "powershell",
      "code": "rustc -Vv | Select-String \"host:\" | ForEach-Object {$_.Line.split(\" \")[1]}",
      "context": "command",
      "file_path": null,
      "description": "x or `src-tauri/binaries/my-sidecar-aarch64-apple-darwin` on Mac OS with Apple Silicon",
      "dependencies": null
    },
    {
      "language": "javascript",
      "code": "import { execSync } from 'child_process';\nimport fs from 'fs';\n\nconst extension = process.platform === 'win32' ? '.exe' : '';\n\nconst rustInfo = execSync('rustc -vV');\nconst targetTriple = /host: (\\S+)/g.exec(rustInfo)[1];\nif (!targetTriple) {\n  console.error('Failed to determine platform target triple');\n}\nfs.renameSync(\n  `src-tauri/binaries/sidecar${extension}`,\n  `src-tauri/binaries/sidecar-${targetTriple}${extension}`\n);",
      "context": "rust_backend",
      "file_path": null,
      "description": "split(\" \")[1]}\n```\n\nHere's a Node",
      "dependencies": null
    },
    {
      "language": "rust",
      "code": "use tauri_plugin_shell::ShellExt;\nuse tauri_plugin_shell::process::CommandEvent;\n\nlet sidecar_command = app.shell().sidecar(\"my-sidecar\").unwrap();\nlet (mut rx, mut _child) = sidecar_command\n  .spawn()\n  .expect(\"Failed to spawn sidecar\");\n\ntauri::async_runtime::spawn(async move {\n  // read events such as stdout\n  while let Some(event) = rx.recv().await {\n    if let CommandEvent::Stdout(line_bytes) = event {\n      let line = String::from_utf8_lossy(&line_bytes);\n      window\n        .emit(\"message\", Some(format!(\"'{}'\", line)))\n        .expect(\"failed to emit event\");\n      // write to stdin\n      child.write(\"message from Rust\\n\".as_bytes()).unwrap();\n    }\n  }\n});",
      "context": "plugin",
      "file_path": null,
      "description": ":::\n\nOn the Rust side, import the `tauri_plugin_shell::ShellExt` trait and call the `shell()",
      "dependencies": null
    },
    {
      "language": "json",
      "code": "{\n  \"bundle\": {\n    \"externalBin\": [\"binaries/app\", \"my-sidecar\", \"../scripts/sidecar\"]\n  }\n}",
      "context": "general",
      "file_path": "src-tauri/tauri.conf.json",
      "description": "unwrap();\n    }\n  }\n});\n```\n\n:::note\nThe `sidecar()` function expects just the filename, NOT the whole path configured in the `externalBin` array",
      "dependencies": null
    },
    {
      "language": "json",
      "code": "{\n  \"permissions\": [\n    \"core:default\",\n    {\n      \"identifier\": \"shell:allow-execute\",\n      \"allow\": [\n        {\n          \"name\": \"binaries/app\",\n          \"sidecar\": true\n        }\n      ]\n    }\n  ]\n}",
      "context": "permissions",
      "file_path": "src-tauri/capabilities/default.json",
      "description": "Don't forget to name your sidecar according to the relative path mentioned earlier",
      "dependencies": null
    },
    {
      "language": "javascript",
      "code": "import { Command } from '@tauri-apps/plugin-shell';\nconst command = Command.sidecar('binaries/my-sidecar');\nconst output = await command.execute();",
      "context": "command",
      "file_path": null,
      "description": ":::\n\nIn the JavaScript code, import the `Command` class from the `@tauri-apps/plugin-shell` module and use the `sidecar` static method",
      "dependencies": null
    },
    {
      "language": "json",
      "code": "{\n  \"$schema\": \"../gen/schemas/desktop-schema.json\",\n  \"identifier\": \"default\",\n  \"description\": \"Capability for the main window\",\n  \"windows\": [\"main\"],\n  \"permissions\": [\n    \"core:default\",\n    {\n      \"identifier\": \"shell:allow-execute\",\n      \"allow\": [\n        {\n          \"args\": [\n            \"arg1\",\n            \"-a\",\n            \"--arg2\",\n            {\n              \"validator\": \"\\\\S+\"\n            }\n          ],\n          \"name\": \"binaries/my-sidecar\",\n          \"sidecar\": true\n        }\n      ]\n    }\n  ]\n}",
      "context": "command",
      "file_path": "src-tauri/capabilities/default.json",
      "description": "First, define the arguments that need to be passed to the sidecar command in `src-tauri/capabilities/default",
      "dependencies": null
    },
    {
      "language": "rust",
      "code": "use tauri_plugin_shell::ShellExt;\n#[tauri::command]\nasync fn call_my_sidecar(app: tauri::AppHandle) {\n  let sidecar_command = app\n    .shell()\n    .sidecar(\"my-sidecar\")\n    .unwrap()\n    .args([\"arg1\", \"-a\", \"--arg2\", \"any-string-that-matches-the-validator\"]);\n  let (mut _rx, mut _child) = sidecar_command.spawn().unwrap();\n}",
      "context": "command",
      "file_path": null,
      "description": ":::\n\nThen, to call the sidecar command, simply pass in **all** the arguments as an array",
      "dependencies": null
    },
    {
      "language": "javascript",
      "code": "import { Command } from '@tauri-apps/plugin-shell';\n// notice that the args array matches EXACTLY what is specified in `capabilities/default.json`.\nconst command = Command.sidecar('binaries/my-sidecar', [\n  'arg1',\n  '-a',\n  '--arg2',\n  'any-string-that-matches-the-validator',\n]);\nconst output = await command.execute();",
      "context": "command",
      "file_path": null,
      "description": "spawn()",
      "dependencies": null
    },
    {
      "language": "json",
      "code": "// src-tauri/tauri.conf.json\n    {\n        \"windows\": [\n            {\n                \"label\": \"main\",\n                \"visible\": false\n            },\n            {\n                \"label\": \"splashscreen\",\n                \"url\": \"/splashscreen\"\n            }\n        ]\n    }",
      "context": "window_management",
      "file_path": null,
      "description": "You can leave all other options as their defaults, or tweak them based on preference",
      "dependencies": null
    },
    {
      "language": "html",
      "code": "// /splashscreen.html\n    <!doctype html>\n    <html lang=\"en\">\n    <head>\n        <meta charset=\"UTF-8\" />\n        <link rel=\"stylesheet\" href=\"/src/styles.css\" />\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n        <title>Tauri App</title>\n    </head>\n    <body>\n        <div class=\"container\">\n            <h1>Tauri used Splash!</h1>\n            <div class=\"row\">\n                <h5>It was super effective!</h5>\n            </div>\n        </div>\n    </body>\n    </html>",
      "context": "general",
      "file_path": null,
      "description": "What's important here is that you can navigate to a `/splashscreen` URL and be shown the contents you want for your splashscreen",
      "dependencies": null
    },
    {
      "language": "javascript",
      "code": "// src/main.ts\n    // These contents can be copy-pasted below the existing code, don't replace the entire file!!\n\n    // Utility function to implement a sleep function in TypeScript\n    function sleep(seconds: number): Promise<void> {\n        return new Promise(resolve => setTimeout(resolve, seconds * 1000));\n    }\n\n    // Setup function\n    async function setup() {\n        // Fake perform some really heavy setup task\n        console.log('Performing really heavy frontend setup task...')\n        await sleep(3);\n        console.log('Frontend setup task complete!')\n        // Set the frontend task as being completed\n        invoke('set_complete', {task: 'frontend'})\n    }\n\n    // Effectively a JavaScript main function\n    window.addEventListener(\"DOMContentLoaded\", () => {\n        setup()\n    });",
      "context": "general",
      "file_path": null,
      "description": "",
      "dependencies": null
    },
    {
      "language": "rust",
      "code": "// /src-tauri/src/lib.rs\n    // Import functionalities we'll be using\n    use std::sync::Mutex;\n    use tauri::async_runtime::spawn;\n    use tauri::{AppHandle, Manager, State};\n    use tokio::time::{sleep, Duration};\n\n    // Create a struct we'll use to track the completion of\n    // setup related tasks\n    struct SetupState {\n        frontend_task: bool,\n        backend_task: bool,\n    }\n\n    // Our main entrypoint in a version 2 mobile compatible app\n    #[cfg_attr(mobile, tauri::mobile_entry_point)]\n    pub fn run() {\n        // Don't write code before Tauri starts, write it in the\n        // setup hook instead!\n        tauri::Builder::default()\n            // Register a `State` to be managed by Tauri\n            // We need write access to it so we wrap it in a `Mutex`\n            .manage(Mutex::new(SetupState {\n                frontend_task: false,\n                backend_task: false,\n            }))\n            // Add a command we can use to check\n            .invoke_handler(tauri::generate_handler![greet, set_complete])\n            // Use the setup hook to execute setup related tasks\n            // Runs before the main loop, so no windows are yet created\n            .setup(|app| {\n                // Spawn setup as a non-blocking task so the windows can be\n                // created and ran while it executes\n                spawn(setup(app.handle().clone()));\n                // The hook expects an Ok result\n                Ok(())\n            })\n            // Run the app\n            .run(tauri::generate_context!())\n            .expect(\"error while running tauri application\");\n    }\n\n    #[tauri::command]\n    fn greet(name: String) -> String {\n        format!(\"Hello {name} from Rust!\")\n    }\n\n    // A custom task for setting the state of a setup task\n    #[tauri::command]\n    async fn set_complete(\n        app: AppHandle,\n        state: State<'_, Mutex<SetupState>>,\n        task: String,\n    ) -> Result<(), ()> {\n        // Lock the state without write access\n        let mut state_lock = state.lock().unwrap();\n        match task.as_str() {\n            \"frontend\" => state_lock.frontend_task = true,\n            \"backend\" => state_lock.backend_task = true,\n            _ => panic!(\"invalid task completed!\"),\n        }\n        // Check if both tasks are completed\n        if state_lock.backend_task && state_lock.frontend_task {\n            // Setup is complete, we can close the splashscreen\n            // and unhide the main window!\n            let splash_window = app.get_webview_window(\"splashscreen\").unwrap();\n            let main_window = app.get_webview_window(\"main\").unwrap();\n            splash_window.close().unwrap();\n            main_window.show().unwrap();\n        }\n        Ok(())\n    }\n\n    // An async function that does some heavy setup task\n    async fn setup(app: AppHandle) -> Result<(), ()> {\n        // Fake performing some heavy action for 3 seconds\n        println!(\"Performing really heavy backend setup task...\");\n        sleep(Duration::from_secs(3)).await;\n        println!(\"Backend setup task completed!\");\n        // Set the backend task as being completed\n        // Commands can be ran as regular functions as long as you take\n        // care of the input arguments yourself\n        set_complete(\n            app.clone(),\n            app.state::<Mutex<SetupState>>(),\n            \"backend\".to_string(),\n        )\n        .await?;\n        Ok(())\n    }",
      "context": "window_management",
      "file_path": null,
      "description": "log('Frontend setup task complete!')\n        // Set the frontend task as being completed\n        invoke('set_complete', {task: 'frontend'})\n    }\n\n    // Effectively a JavaScript main function\n    window",
      "dependencies": null
    },
    {
      "language": "rust",
      "code": "use tauri::{Builder, Manager};\n\nstruct AppData {\n  welcome_message: &'static str,\n}\n\nfn main() {\n  Builder::default()\n    .setup(|app| {\n      app.manage(AppData {\n        welcome_message: \"Welcome to Tauri!\",\n      });\n      Ok(())\n    })\n    .run(tauri::generate_context!())\n    .unwrap();\n}",
      "context": "command",
      "file_path": null,
      "description": "Tauri provides an easy way to manage the state of your application using the [`Manager`] API, and read it when commands are called",
      "dependencies": null
    },
    {
      "language": "rust",
      "code": "let data = app.state::<AppData>();",
      "context": "state_management",
      "file_path": null,
      "description": "run(tauri::generate_context!())",
      "dependencies": null
    },
    {
      "language": "rust",
      "code": "use std::sync::Mutex;\n\nuse tauri::{Builder, Manager};\n\n#[derive(Default)]\nstruct AppState {\n  counter: u32,\n}\n\nfn main() {\n  Builder::default()\n    .setup(|app| {\n      app.manage(Mutex::new(AppState::default()));\n      Ok(())\n    })\n    .run(tauri::generate_context!())\n    .unwrap();\n}",
      "context": "state_management",
      "file_path": null,
      "description": "This allows you to lock the value when you need to modify it, and unlock it when you are done",
      "dependencies": null
    },
    {
      "language": "rust",
      "code": "let state = app.state::<Mutex<AppState>>();\n\n// Lock the mutex to get mutable access:\nlet mut state = state.lock().unwrap();\n\n// Modify the state:\nstate.counter += 1;",
      "context": "state_management",
      "file_path": null,
      "description": "run(tauri::generate_context!())",
      "dependencies": null
    },
    {
      "language": "rust",
      "code": "#[tauri::command]\nfn increase_counter(state: State<'_, Mutex<AppState>>) -> u32 {\n  let mut state = state.lock().unwrap();\n  state.counter += 1;\n  state.counter\n}",
      "context": "command",
      "file_path": null,
      "description": "`AppHandle`s are deliberately cheap to clone for use-cases like this",
      "dependencies": null
    },
    {
      "language": "rust",
      "code": "#[tauri::command]\nasync fn increase_counter(state: State<'_, Mutex<AppState>>) -> Result<u32, ()> {\n  let mut state = state.lock().await;\n  state.counter += 1;\n  Ok(state.counter)\n}",
      "context": "command",
      "file_path": null,
      "description": "Mutex",
      "dependencies": null
    },
    {
      "language": "rust",
      "code": "use std::sync::Mutex;\nuse tauri::{Builder, Window, WindowEvent, Manager};\n\n#[derive(Default)]\nstruct AppState {\n  counter: u32,\n}\n\n// In an event handler:\nfn on_window_event(window: &Window, _event: &WindowEvent) {\n    // Get a handle to the app so we can get the global state.\n    let app_handle = window.app_handle();\n    let state = app_handle.state::<Mutex<AppState>>();\n\n    // Lock the mutex to mutably access the state.\n    let mut state = state.lock().unwrap();\n    state.counter += 1;\n}\n\nfn main() {\n  Builder::default()\n    .setup(|app| {\n      app.manage(Mutex::new(AppState::default()));\n      Ok(())\n    })\n    .on_window_event(on_window_event)\n    .run(tauri::generate_context!())\n    .unwrap();\n}",
      "context": "state_management",
      "file_path": null,
      "description": "### Access state with the [`Manager`] trait\n\nSometimes you may need to access the state outside of commands, such as in a different thread or in an event handler like `on_window_event`",
      "dependencies": null
    },
    {
      "language": "rust",
      "code": "use std::sync::Mutex;\n\n#[derive(Default)]\nstruct AppStateInner {\n  counter: u32,\n}\n\ntype AppState = Mutex<AppStateInner>;",
      "context": "state_management",
      "file_path": null,
      "description": "For example, if you use `State<'_, AppState>` instead of `State<'_, Mutex<AppState>>`, there won't be any state managed with that type",
      "dependencies": null
    },
    {
      "language": "toml",
      "code": "tauri = { version = \"2.0.0\", features = [ \"tray-icon\" ] }",
      "context": "general",
      "file_path": "src-tauri/Cargo.toml",
      "description": "toml` to include the necessary feature for the system tray",
      "dependencies": null
    },
    {
      "language": "javascript",
      "code": "import { TrayIcon } from '@tauri-apps/api/tray';\n\nconst options = {\n  // here you can add a tray menu, title, tooltip, event handler, etc\n};\n\nconst tray = await TrayIcon.new(options);",
      "context": "frontend_integration",
      "file_path": null,
      "description": "### Create a Tray Icon\n\n<Tabs synckey=\"language\">\n<TabItem label=\"JavaScript\">\nUse the [`TrayIcon",
      "dependencies": null
    },
    {
      "language": "rust",
      "code": "use tauri::tray::TrayIconBuilder;\n\ntauri::Builder::default()\n    .setup(|app| {\n        let tray = TrayIconBuilder::new().build(app)?;\n        Ok(())\n    })",
      "context": "rust_backend",
      "file_path": null,
      "description": "new(options);\n```\n\nSee [`TrayIconOptions`] for more information on the customization options",
      "dependencies": null
    },
    {
      "language": "javascript",
      "code": "import { TrayIcon } from '@tauri-apps/api/tray';\nimport { defaultWindowIcon } from '@tauri-apps/api/app';\n\nconst options = {\n  icon: await defaultWindowIcon(),\n};\n\nconst tray = await TrayIcon.new(options);",
      "context": "frontend_integration",
      "file_path": null,
      "description": "build(app)?;\n        Ok(())\n    })\n\n```\n\nSee [`TrayIconBuilder`] for more information on customization options",
      "dependencies": null
    },
    {
      "language": "rust",
      "code": "let tray = TrayIconBuilder::new()\n  .icon(app.default_window_icon().unwrap().clone())\n  .build(app)?;",
      "context": "window_management",
      "file_path": null,
      "description": "</TabItem>\n</Tabs>\n\n### Change the Tray Icon\n\nWhen creating the tray you can use the application icon as the tray icon:\n\n<Tabs syncKey=\"lang\">\n<TabItem label=\"JavaScript\">\n\n```javascript\nimport { TrayIcon } from '@tauri-apps/api/tray';\nimport { defaultWindowIcon } from '@tauri-apps/api/app';\n\nconst options = {\n  icon: await defaultWindowIcon(),\n};\n\nconst tray = await TrayIcon",
      "dependencies": null
    },
    {
      "language": "javascript",
      "code": "import { TrayIcon } from '@tauri-apps/api/tray';\nimport { Menu } from '@tauri-apps/api/menu';\n\nconst menu = await Menu.new({\n  items: [\n    {\n      id: 'quit',\n      text: 'Quit',\n    },\n  ],\n});\n\nconst options = {\n  menu,\n  menuOnLeftClick: true,\n};\n\nconst tray = await TrayIcon.new(options);",
      "context": "plugin",
      "file_path": null,
      "description": "To prevent the menu from popping up on left click, call the [`menu_on_left_click(false)`][TrayIconBuilder::menu_on_left_click] Rust function\nor set the [`menuOnLeftClick`] JavaScript option to `false`",
      "dependencies": null
    },
    {
      "language": "rust",
      "code": "use tauri::{\n  menu::{Menu, MenuItem},\n  tray::TrayIconBuilder,\n};\n\nlet quit_i = MenuItem::with_id(app, \"quit\", \"Quit\", true, None::<&str>)?;\nlet menu = Menu::with_items(app, &[&quit_i])?;\n\nlet tray = TrayIconBuilder::new()\n  .menu(&menu)\n  .menu_on_left_click(true)\n  .build(app)?;",
      "context": "rust_backend",
      "file_path": null,
      "description": "new({\n  items: [\n    {\n      id: 'quit',\n      text: 'Quit',\n    },\n  ],\n});\n\nconst options = {\n  menu,\n  menuOnLeftClick: true,\n};\n\nconst tray = await TrayIcon",
      "dependencies": null
    },
    {
      "language": "javascript",
      "code": "import { Menu } from '@tauri-apps/api/menu';\n\n  function onTrayMenuClick(itemId) {\n    // itemId === 'quit'\n  }\n\n  const menu = await Menu.new({\n    items: [\n      {\n        id: 'quit',\n        text: 'Quit',\n        action: onTrayMenuClick,\n      },\n    ],\n  });",
      "context": "frontend_integration",
      "file_path": null,
      "description": "menu_on_left_click(true)",
      "dependencies": null
    },
    {
      "language": "javascript",
      "code": "import { Menu } from '@tauri-apps/api/menu';\n\n  const menu = await Menu.new({\n    items: [\n      {\n        id: 'quit',\n        text: 'Quit',\n        action: () => {\n          console.log('quit pressed');\n        },\n      },\n    ],\n  });",
      "context": "general",
      "file_path": null,
      "description": "bs syncKey=\"lang\">\n<TabItem label=\"JavaScript\">\nOn JavaScript you can attach a menu click event listener directly to the menu item:\n\n- Using a shared menu click handler\n\n  ```javascript\n  import { Menu } from '@tauri-apps/api/menu';\n\n  function onTrayMenuClick(itemId) {\n    // itemId === 'quit'\n  }\n\n  const menu = await Menu",
      "dependencies": null
    },
    {
      "language": "rust",
      "code": "use tauri::tray::TrayIconBuilder;\n\nTrayIconBuilder::new()\n  .on_menu_event(|app, event| match event.id.as_ref() {\n    \"quit\" => {\n      println!(\"quit menu item was clicked\");\n      app.exit(0);\n    }\n    _ => {\n      println!(\"menu item {:?} not handled\", event.id);\n    }\n  })",
      "context": "rust_backend",
      "file_path": null,
      "description": "new({\n    items: [\n      {\n        id: 'quit',\n        text: 'Quit',\n        action: () => {\n          console",
      "dependencies": null
    },
    {
      "language": "javascript",
      "code": "import { TrayIcon } from '@tauri-apps/api/tray';\n\nconst options = {\n  action: (event) => {\n    switch (event.type) {\n      case 'Click':\n        console.log(\n          `mouse ${event.button} button pressed, state: ${event.buttonState}`\n        );\n        break;\n      case 'DoubleClick':\n        console.log(`mouse ${event.button} button pressed`);\n        break;\n      case 'Enter':\n        console.log(\n          `mouse hovered tray at ${event.rect.position.x}, ${event.rect.position.y}`\n        );\n        break;\n      case 'Move':\n        console.log(\n          `mouse moved on tray at ${event.rect.position.x}, ${event.rect.position.y}`\n        );\n        break;\n      case 'Leave':\n        console.log(\n          `mouse left tray at ${event.rect.position.x}, ${event.rect.position.y}`\n        );\n        break;\n    }\n  },\n};\n\nconst tray = await TrayIcon.new(options);",
      "context": "frontend_integration",
      "file_path": null,
      "description": "s for the following mouse events:\n\n- click: triggered when the cursor receives a single left, right or middle click, including information on whether the mouse press was released or not\n- Double click: triggered when the cursor receives a double left, right or middle click\n- Enter: triggered when the cursor enters the tray icon area\n- Move: triggered when the cursor moves around the tray icon area\n- Leave: triggered when the cursor leaves the tray icon area\n\n<Tabs>\n<TabItem label=\"JavaScript\">",
      "dependencies": null
    },
    {
      "language": "rust",
      "code": "use tauri::{\n    Manager,\n    tray::{MouseButton, MouseButtonState, TrayIconBuilder, TrayIconEvent}\n};\n\nTrayIconBuilder::new()\n  .on_tray_icon_event(|tray, event| match event {\n    TrayIconEvent::Click {\n      button: MouseButton::Left,\n      button_state: MouseButtonState::Up,\n      ..\n    } => {\n      println!(\"left click pressed and released\");\n      // in this example, let's show and focus the main window when the tray is clicked\n      let app = tray.app_handle();\n      if let Some(window) = app.get_webview_window(\"main\") {\n        let _ = window.unminimize();\n        let _ = window.show();\n        let _ = window.set_focus();\n      }\n    }\n    _ => {\n      println!(\"unhandled event {event:?}\");\n    }\n  })",
      "context": "rust_backend",
      "file_path": null,
      "description": "new(options);\n```\n\nSee [`TrayIconEvent`][js TrayIconEvent] for more information on the event payload",
      "dependencies": null
    },
    {
      "language": "toml",
      "code": "[build-dependencies]\ntauri-build = \"%version%\"\n\n[dependencies]\ntauri = { version = \"%version%\" }",
      "context": "general",
      "file_path": null,
      "description": "Go to `src-tauri/Cargo",
      "dependencies": null
    },
    {
      "language": "shell",
      "code": "cd src-tauri\ncargo update",
      "context": "general",
      "file_path": null,
      "description": "toml` and change `tauri` and `tauri-build` to\n\n```toml\n[build-dependencies]\ntauri-build = \"%version%\"\n\n[dependencies]\ntauri = { version = \"%version%\" }\n```\n\nwhere `%version%` is the corresponding version number from above",
      "dependencies": null
    },
    {
      "language": "sh",
      "code": "cargo add tauri-plugin-fs",
      "context": "plugin",
      "file_path": null,
      "description": "io](https://crates",
      "dependencies": null
    },
    {
      "language": "rust",
      "code": "#[cfg_attr(mobile, tauri::mobile_entry_point)]\n    fn run() {\n      tauri::Builder::default()\n        .plugin(tauri_plugin_fs::init())\n        .run(tauri::generate_context!())\n        .expect(\"error while running tauri application\");\n    }",
      "context": "plugin",
      "file_path": "src-tauri/src/lib.rs",
      "description": "io/crates/tauri-plugin-fs)\n    you need to manually add it as a dependency and modify the Tauri builder\n    to initialize the plugin:\n\n    ```sh\n    cargo add tauri-plugin-fs\n    ```\n\n    Modify `lib",
      "dependencies": null
    },
    {
      "language": "ts",
      "code": "import { writeTextFile, BaseDirectory } from '@tauri-apps/plugin-fs';\n\n        let greetInputEl: HTMLInputElement | null;\n\n        async function write(message: string) {\n            await writeTextFile('test.txt', message, { baseDir: BaseDirectory.Home });\n        }\n\n        window.addEventListener(\"DOMContentLoaded\", () => {\n          greetInputEl = document.querySelector(\"#greet-input\");\n          document.querySelector(\"#greet-form\")?.addEventListener(\"submit\", (e) => {\n            e.preventDefault();\n            if (!greetInputEl )\n              return;\n\n            write(greetInputEl.value == \"\" ? \"No input provided\": greetInputEl.value);\n\n          });\n        });",
      "context": "general",
      "file_path": "src/main.ts",
      "description": "### Test Permissions in Practice\n\n        After we have added the necessary permission we want to\n        confirm that our application can access the file and write\n        it's content",
      "dependencies": null
    },
    {
      "language": "sh",
      "code": "[Error] Unhandled Promise Rejection: fs.write_text_file not allowed. Permissions associated with this command: fs:allow-app-write, fs:allow-app-write-recursive, fs:allow-appcache-write, fs:allow-appcache-write-recursive, fs:allow-appconf...\n        (anonymous function) (main.ts:5)",
      "context": "permissions",
      "file_path": null,
      "description": "txt\n        ```\n\n        You should be presented with your input and finished learning about using permissions from plugins in Tauri applications",
      "dependencies": null
    },
    {
      "language": "json",
      "code": "{\n      \"scripts\": {\n        \"dev\": \"vite\",\n        \"build\": \"tsc && vite build\",\n        \"preview\": \"vite preview\",\n        \"tauri\": \"tauri\"\n      }\n    }",
      "context": "general",
      "file_path": null,
      "description": "##### Update Tauri configuration\n\n    Assuming you have the following `dev` and `build` scripts in your `package",
      "dependencies": null
    },
    {
      "language": "json",
      "code": "// tauri.conf.json\n    {\n      \"build\": {\n        \"beforeDevCommand\": \"npm run dev\",\n        \"beforeBuildCommand\": \"npm run build\",\n        \"devUrl\": \"http://localhost:5173\",\n        \"frontendDist\": \"../dist\"\n      }\n    }",
      "context": "general",
      "file_path": null,
      "description": "##### Update Tauri configuration\n\n    Assuming you have the following `dev` and `build` scripts in your `package",
      "dependencies": null
    },
    {
      "language": "json",
      "code": "// tauri.conf.json\n    {\n      \"build\": {\n        \"beforeDevCommand\": \"yarn dev\",\n        \"beforeBuildCommand\": \"yarn build\",\n        \"devUrl\": \"http://localhost:5173\",\n        \"frontendDist\": \"../dist\"\n      }\n    }",
      "context": "command",
      "file_path": null,
      "description": "",
      "dependencies": null
    },
    {
      "language": "json",
      "code": "// tauri.conf.json\n    {\n      \"build\": {\n        \"beforeDevCommand\": \"pnpm dev\",\n        \"beforeBuildCommand\": \"pnpm build\",\n        \"devUrl\": \"http://localhost:5173\",\n        \"frontendDist\": \"../dist\"\n      }\n    }",
      "context": "command",
      "file_path": null,
      "description": "",
      "dependencies": null
    },
    {
      "language": "json",
      "code": "// tauri.conf.json\n    {\n      \"build\": {\n        \"beforeDevCommand\": \"deno task dev\",\n        \"beforeBuildCommand\": \"deno task build\",\n        \"devUrl\": \"http://localhost:5173\",\n        \"frontendDist\": \"../dist\"\n      }\n    }",
      "context": "command",
      "file_path": null,
      "description": "",
      "dependencies": null
    },
    {
      "language": "js",
      "code": "import { defineConfig } from 'vite';\n\n    const host = process.env.TAURI_DEV_HOST;\n\n    export default defineConfig({\n      // prevent vite from obscuring rust errors\n      clearScreen: false,\n      server: {\n        // make sure this port matches the devUrl port in tauri.conf.json file\n        port: 5173,\n        // Tauri expects a fixed port, fail if that port is not available\n        strictPort: true,\n        // if the host Tauri is expecting is set, use it\n        host: host || false,\n        hmr: host\n          ? {\n              protocol: 'ws',\n              host,\n              port: 1421,\n            }\n          : undefined,\n\n        watch: {\n          // tell vite to ignore watching `src-tauri`\n          ignored: ['**/src-tauri/**'],\n        },\n      },\n      // Env variables starting with the item of `envPrefix` will be exposed in tauri's source code through `import.meta.env`.\n      envPrefix: ['VITE_', 'TAURI_ENV_*'],\n      build: {\n        // Tauri uses Chromium on Windows and WebKit on macOS and Linux\n        target:\n          process.env.TAURI_ENV_PLATFORM == 'windows'\n            ? 'chrome105'\n            : 'safari13',\n        // don't minify for debug builds\n        minify: !process.env.TAURI_ENV_DEBUG ? 'esbuild' : false,\n        // produce sourcemaps for debug builds\n        sourcemap: !!process.env.TAURI_ENV_DEBUG,\n      },\n    });",
      "context": "command",
      "file_path": "vite.config.js",
      "description": "/dist\"\n      }\n    }\n    ```\n\n    </TabItem>\n\n    </Tabs>\n\n1",
      "dependencies": null
    },
    {
      "language": "json",
      "code": "{\n  \"$schema\": \"../gen/schemas/desktop-schema.json\",\n  \"identifier\": \"main-capability\",\n  \"description\": \"Capability for the main window\",\n  \"windows\": [\"main\"],\n  \"permissions\": [\"core:window:default\", \"core:window:allow-start-dragging\"]\n}",
      "context": "permissions",
      "file_path": "src-tauri/capabilities/default.json",
      "description": "See the [Capabilities Overview](/security/capabilities/) for more information and the [step by step guide](/learn/security/using-plugin-permissions/) to use plugin permissions",
      "dependencies": null
    },
    {
      "language": "css",
      "code": ".titlebar {\n  height: 30px;\n  background: #329ea3;\n  user-select: none;\n  display: grid;\n  grid-template-columns: auto max-content;\n  position: fixed;\n  top: 0;\n  left: 0;\n  right: 0;\n}\n.titlebar > .controls {\n  display: flex;\n}\n.titlebar button {\n  appearance: none;\n  padding: 0;\n  margin: 0;\n  border: none;\n  display: inline-flex;\n  justify-content: center;\n  align-items: center;\n  width: 30px;\n  background-color: transparent;\n}\n.titlebar button:hover {\n  background: #5bbec3;\n}",
      "context": "command",
      "file_path": null,
      "description": "|\n| `core:window:allow-internal-toggle-maximize` | Enables the internal_toggle_maximize command without any pre-configured scope",
      "dependencies": null
    },
    {
      "language": "html",
      "code": "<div class=\"titlebar\">\n  <div data-tauri-drag-region></div>\n  <div class=\"controls\">\n    <button id=\"titlebar-minimize\" title=\"minimize\">\n      <!-- https://api.iconify.design/mdi:window-minimize.svg -->\n      <svg\n        xmlns=\"http://www.w3.org/2000/svg\"\n        width=\"24\"\n        height=\"24\"\n        viewBox=\"0 0 24 24\"\n      >\n        <path fill=\"currentColor\" d=\"M19 13H5v-2h14z\" />\n      </svg>\n    </button>\n    <button id=\"titlebar-maximize\" title=\"maximize\">\n      <!-- https://api.iconify.design/mdi:window-maximize.svg -->\n      <svg\n        xmlns=\"http://www.w3.org/2000/svg\"\n        width=\"24\"\n        height=\"24\"\n        viewBox=\"0 0 24 24\"\n      >\n        <path fill=\"currentColor\" d=\"M4 4h16v16H4zm2 4v10h12V8z\" />\n      </svg>\n    </button>\n    <button id=\"titlebar-close\" title=\"close\">\n      <!-- https://api.iconify.design/mdi:close.svg -->\n      <svg\n        xmlns=\"http://www.w3.org/2000/svg\"\n        width=\"24\"\n        height=\"24\"\n        viewBox=\"0 0 24 24\"\n      >\n        <path\n          fill=\"currentColor\"\n          d=\"M13.46 12L19 17.54V19h-1.46L12 13.46L6.46 19H5v-1.46L10.54 12L5 6.46V5h1.46L12 10.54L17.54 5H19v1.46z\"\n        />\n      </svg>\n    </button>\n  </div>\n</div>",
      "context": "general",
      "file_path": null,
      "description": "titlebar button {\n  appearance: none;\n  padding: 0;\n  margin: 0;\n  border: none;\n  display: inline-flex;\n  justify-content: center;\n  align-items: center;\n  width: 30px;\n  background-color: transparent;\n}",
      "dependencies": null
    },
    {
      "language": "css",
      "code": "*[data-tauri-drag-region] {\n  app-region: drag;\n}",
      "context": "window_management",
      "file_path": null,
      "description": "46z\"\n        />\n      </svg>\n    </button>\n  </div>\n</div>\n```\n\nNote that you may need to move the rest of your content down so that the titlebar doesn't cover it",
      "dependencies": null
    },
    {
      "language": "javascript",
      "code": "import { getCurrentWindow } from '@tauri-apps/api/window';\n\n// when using `\"withGlobalTauri\": true`, you may use\n// const { getCurrentWindow } = window.__TAURI__.window;\n\nconst appWindow = getCurrentWindow();\n\ndocument\n  .getElementById('titlebar-minimize')\n  ?.addEventListener('click', () => appWindow.minimize());\ndocument\n  .getElementById('titlebar-maximize')\n  ?.addEventListener('click', () => appWindow.toggleMaximize());\ndocument\n  .getElementById('titlebar-close')\n  ?.addEventListener('click', () => appWindow.close());",
      "context": "frontend_integration",
      "file_path": null,
      "description": "46z\"\n        />\n      </svg>\n    </button>\n  </div>\n</div>\n```\n\nNote that you may need to move the rest of your content down so that the titlebar doesn't cover it",
      "dependencies": null
    },
    {
      "language": "json",
      "code": "\"tauri\": {\n    \t\"windows\": [\n    \t\t{\n    \t\t\t\"title\": \"Transparent Titlebar Window\",\n    \t\t\t\"width\": 800,\n    \t\t\t\"height\": 600\n    \t\t}\n    \t],\n    }",
      "context": "window_management",
      "file_path": "tauri.conf.json",
      "description": "conf",
      "dependencies": null
    },
    {
      "language": "toml",
      "code": "[target.\"cfg(target_os = \\\"macos\\\")\".dependencies]\n    cocoa = \"0.26\"",
      "context": "window_management",
      "file_path": "src-tauri/Cargo.toml",
      "description": "conf",
      "dependencies": null
    },
    {
      "language": "rust",
      "code": "use tauri::{TitleBarStyle, WebviewUrl, WebviewWindowBuilder};\n\n    pub fn run() {\n    \ttauri::Builder::default()\n    \t\t.setup(|app| {\n    \t\t\tlet win_builder =\n    \t\t\t\tWebviewWindowBuilder::new(app, \"main\", WebviewUrl::default())\n    \t\t\t\t\t.title(\"Transparent Titlebar Window\")\n    \t\t\t\t\t.inner_size(800.0, 600.0);\n\n    \t\t\t// set transparent title bar only when building for macOS\n    \t\t\t#[cfg(target_os = \"macos\")]\n    \t\t\tlet win_builder = win_builder.title_bar_style(TitleBarStyle::Transparent);\n\n    \t\t\tlet window = win_builder.build().unwrap();\n\n    \t\t\t// set background color only when building for macOS\n    \t\t\t#[cfg(target_os = \"macos\")]\n    \t\t\t{\n    \t\t\t\tuse cocoa::appkit::{NSColor, NSWindow};\n    \t\t\t\tuse cocoa::base::{id, nil};\n\n    \t\t\t\tlet ns_window = window.ns_window().unwrap() as id;\n    \t\t\t\tunsafe {\n    \t\t\t\t\tlet bg_color = NSColor::colorWithRed_green_blue_alpha_(\n    \t\t\t\t\t\t\tnil,\n    \t\t\t\t\t\t\t50.0 / 255.0,\n    \t\t\t\t\t\t\t158.0 / 255.0,\n    \t\t\t\t\t\t\t163.5 / 255.0,\n    \t\t\t\t\t\t\t1.0,\n    \t\t\t\t\t);\n    \t\t\t\t\tns_window.setBackgroundColor_(bg_color);\n    \t\t\t\t}\n    \t\t\t}\n\n    \t\t\tOk(())\n    \t\t})\n    \t\t.run(tauri::generate_context!())\n    \t\t.expect(\"error while running tauri application\");\n    }",
      "context": "window_management",
      "file_path": "src-tauri/src/lib.rs",
      "description": "dependencies]\n    cocoa = \"0",
      "dependencies": null
    },
    {
      "language": "javascript",
      "code": "import { Menu } from '@tauri-apps/api/menu';\n\nconst menu = await Menu.new({\n  items: [\n    {\n      id: 'quit',\n      text: 'Quit',\n      action: () => {\n        console.log('quit pressed');\n      },\n    },\n    {\n      id: 'check_item',\n      text: 'Check Item',\n      checked: true,\n    },\n    {\n      type: 'Separator',\n    },\n    {\n      id: 'disabled_item',\n      text: 'Disabled Item',\n      enabled: false,\n    },\n    {\n      id: 'status',\n      text: 'Status: Processing...',\n    },\n  ],\n});\n\n// If a window was not created with an explicit menu or had one set explicitly,\n// this menu will be assigned to it.\nmenu.setAsAppMenu().then(async (res) => {\n  console.log('menu set success', res);\n\n  // Update individual menu item text\n  const statusItem = await menu.get('status');\n  if (statusItem) {\n    await statusItem.setText('Status: Ready');\n  }\n});",
      "context": "window_management",
      "file_path": null,
      "description": "You can create various types of menu items including basic items, check items, and separators:\n\n<Tabs>\n<TabItem label=\"JavaScript\">\n\nUse the [`Menu",
      "dependencies": null
    },
    {
      "language": "rust",
      "code": "use tauri::menu::MenuBuilder;\n\nfn main() {\n    tauri::Builder::default()\n        .setup(|app| {\n            let menu = MenuBuilder::new(app)\n                .text(\"open\", \"Open\")\n                .text(\"close\", \"Close\")\n                .check(\"check_item\", \"Check Item\")\n                .separator()\n                .text(\"disabled_item\", \"Disabled Item\")\n                .text(\"status\", \"Status: Processing...\")\n                .build()?;\n\n            app.set_menu(menu.clone())?;\n\n            // Update individual menu item text\n            menu\n                .get(\"status\")\n                .unwrap()\n                .as_menuitem_unchecked()\n                .set_text(\"Status: Ready\")?;\n\n            Ok(())\n        })\n        .run(tauri::generate_context!());\n}",
      "context": "rust_backend",
      "file_path": null,
      "description": "get('status');\n  if (statusItem) {\n    await statusItem",
      "dependencies": null
    },
    {
      "language": "javascript",
      "code": "import { Menu } from '@tauri-apps/api/menu';\n\nconst menu = await Menu.new({\n  items: [\n    {\n      id: 'Open',\n      text: 'open',\n      action: () => {\n        console.log('open pressed');\n      },\n    },\n    {\n      id: 'Close',\n      text: 'close',\n      action: () => {\n        console.log('close pressed');\n      },\n    },\n  ],\n});\n\nawait menu.setAsAppMenu();",
      "context": "frontend_integration",
      "file_path": null,
      "description": "Use the `on_menu_event` API to handle them",
      "dependencies": null
    },
    {
      "language": "rust",
      "code": "#![cfg_attr(not(debug_assertions), windows_subsystem = \"windows\")]\nuse tauri::menu::{MenuBuilder};\n\nfn main() {\n  tauri::Builder::default()\n        .setup(|app| {\n            let menu = MenuBuilder::new(app)\n                .text(\"open\", \"Open\")\n                .text(\"close\", \"Close\")\n                .build()?;\n\n            app.set_menu(menu)?;\n\n            app.on_menu_event(move |app_handle: &tauri::AppHandle, event| {\n\n                println!(\"menu event: {:?}\", event.id());\n\n                match event.id().0.as_str() {\n                    \"open\" => {\n                        println!(\"open event\");\n                    }\n                    \"close\" => {\n                        println!(\"close event\");\n                    }\n                    _ => {\n                        println!(\"unexpected menu event\");\n                    }\n                }\n            });\n\n            Ok(())\n        })\n}",
      "context": "rust_backend",
      "file_path": null,
      "description": "log('close pressed');\n      },\n    },\n  ],\n});\n\nawait menu",
      "dependencies": null
    },
    {
      "language": "javascript",
      "code": "import { Menu, MenuItem, Submenu } from '@tauri-apps/api/menu';\n\n// Will become the application submenu on MacOS\nconst aboutSubmenu = await Submenu.new({\n  text: 'About',\n  items: [\n    await MenuItem.new({\n      id: 'quit',\n      text: 'Quit',\n      action: () => {\n        console.log('Quit pressed');\n      },\n    }),\n  ],\n});\n\nconst fileSubmenu = await Submenu.new({\n  text: 'File',\n  icon: 'folder', // Optional: Add an icon to the submenu\n  items: [\n    await MenuItem.new({\n      id: 'new',\n      text: 'New',\n      action: () => {\n        console.log('New clicked');\n      },\n    }),\n    await MenuItem.new({\n      id: 'open',\n      text: 'Open',\n      action: () => {\n        console.log('Open clicked');\n      },\n    }),\n    await MenuItem.new({\n      id: 'save_as',\n      text: 'Save As...',\n      action: () => {\n        console.log('Save As clicked');\n      },\n    }),\n  ],\n});\n\nconst editSubmenu = await Submenu.new({\n  text: 'Edit',\n  items: [\n    await MenuItem.new({\n      id: 'undo',\n      text: 'Undo',\n      action: () => {\n        console.log('Undo clicked');\n      },\n    }),\n    await MenuItem.new({\n      id: 'redo',\n      text: 'Redo',\n      action: () => {\n        console.log('Redo clicked');\n      },\n    }),\n  ],\n});\n\nconst menu = await Menu.new({\n  items: [aboutSubmenu, fileSubmenu, editSubmenu],\n});\n\nmenu.setAsAppMenu();\n\n// You can also update the submenu icon dynamically\nfileSubmenu.setIcon('document');\n// Or set a native icon (only one type applies per platform)\nfileSubmenu.setNativeIcon('NSFolder');",
      "context": "frontend_integration",
      "file_path": null,
      "description": "0",
      "dependencies": null
    },
    {
      "language": "rust",
      "code": "use tauri::{\n    image::Image,\n    menu::{CheckMenuItemBuilder, IconMenuItemBuilder, MenuBuilder, SubmenuBuilder},\n};\n\nfn main() {\n    tauri::Builder::default()\n        .setup(|app| {\n            let menu_image = Image::from_bytes(include_bytes!(\"../icons/menu.png\")).unwrap();\n            let file_menu = SubmenuBuilder::new(app, \"File\")\n                .submenu_icon(menu_image)) // Optional: Add an icon to the submenu\n                .text(\"open\", \"Open\")\n                .text(\"quit\", \"Quit\")\n                .build()?;\n\n            let lang_str = \"en\";\n            let check_sub_item_1 = CheckMenuItemBuilder::new(\"English\")\n                .id(\"en\")\n                .checked(lang_str == \"en\")\n                .build(app)?;\n\n            let check_sub_item_2 = CheckMenuItemBuilder::new(\"Chinese\")\n                .id(\"en\")\n                .checked(lang_str == \"en\")\n                .enabled(false)\n                .build(app)?;\n\n            // Load icon from path\n            let icon_image = Image::from_bytes(include_bytes!(\"../icons/icon.png\")).unwrap();\n\n            let icon_item = IconMenuItemBuilder::new(\"icon\")\n                .icon(icon_image)\n                .build(app)?;\n\n            let other_item = SubmenuBuilder::new(app, \"language\")\n                .item(&check_sub_item_1)\n                .item(&check_sub_item_2)\n                .build()?;\n\n            let menu = MenuBuilder::new(app)\n                .items(&[&file_menu, &other_item, &icon_item])\n                .build()?;\n\n            app.set_menu(menu)?;\n\n            let menu_image_update =\n                Image::from_bytes(include_bytes!(\"../icons/menu_update.png\")).unwrap();\n            // You can also update the submenu icon dynamically\n            file_menu.set_icon(Some(menu_image_update))?;\n            // Or set a native icon (only one type applies per platform)\n            file_menu.set_native_icon(Some(tauri::menu::NativeIcon::Folder))?;\n\n            Ok(())\n        })\n        .run(tauri::generate_context!());\n}",
      "context": "rust_backend",
      "file_path": null,
      "description": "setIcon('document');\n// Or set a native icon (only one type applies per platform)\nfileSubmenu",
      "dependencies": null
    },
    {
      "language": "toml",
      "code": "[dependencies]\ntauri = { version = \"...\", features = [\"...\", \"image-png\"] }",
      "context": "general",
      "file_path": "src-tauri/Cargo.toml",
      "description": "set_native_icon(Some(tauri::menu::NativeIcon::Folder))?;\n\n            Ok(())\n        })",
      "dependencies": null
    },
    {
      "language": "javascript",
      "code": "import { Menu, PredefinedMenuItem } from '@tauri-apps/api/menu';\n\nconst copy = await PredefinedMenuItem.new({\n  text: 'copy-text',\n  item: 'Copy',\n});\n\nconst separator = await PredefinedMenuItem.new({\n  text: 'separator-text',\n  item: 'Separator',\n});\n\nconst undo = await PredefinedMenuItem.new({\n  text: 'undo-text',\n  item: 'Undo',\n});\n\nconst redo = await PredefinedMenuItem.new({\n  text: 'redo-text',\n  item: 'Redo',\n});\n\nconst cut = await PredefinedMenuItem.new({\n  text: 'cut-text',\n  item: 'Cut',\n});\n\nconst paste = await PredefinedMenuItem.new({\n  text: 'paste-text',\n  item: 'Paste',\n});\n\nconst select_all = await PredefinedMenuItem.new({\n  text: 'select_all-text',\n  item: 'SelectAll',\n});\n\nconst menu = await Menu.new({\n  items: [copy, separator, undo, redo, cut, paste, select_all],\n});\n\nawait menu.setAsAppMenu();",
      "context": "frontend_integration",
      "file_path": null,
      "description": "",
      "dependencies": null
    },
    {
      "language": "rust",
      "code": "#![cfg_attr(not(debug_assertions), windows_subsystem = \"windows\")]\nuse tauri::menu::{MenuBuilder, PredefinedMenuItem};\n\nfn main() {\n  tauri::Builder::default()\n        .setup(|app| {\n      let menu = MenuBuilder::new(app)\n                .copy()\n                .separator()\n                .undo()\n                .redo()\n                .cut()\n                .paste()\n                .select_all()\n                .item(&PredefinedMenuItem::copy(app, Some(\"custom text\"))?)\n                .build()?;\n            app.set_menu(menu)?;\n\n            Ok(())\n        })\n}",
      "context": "rust_backend",
      "file_path": null,
      "description": "new({\n  items: [copy, separator, undo, redo, cut, paste, select_all],\n});\n\nawait menu",
      "dependencies": null
    },
    {
      "language": "javascript",
      "code": "import {\n  Menu,\n  CheckMenuItem,\n  IconMenuItem,\n  MenuItem,\n} from '@tauri-apps/api/menu';\nimport { Image } from '@tauri-apps/api/image';\n\nlet currentLanguage = 'en';\n\nconst check_sub_item_en = await CheckMenuItem.new({\n  id: 'en',\n  text: 'English',\n  checked: currentLanguage === 'en',\n  action: () => {\n    currentLanguage = 'en';\n    check_sub_item_en.setChecked(currentLanguage === 'en');\n    check_sub_item_zh.setChecked(currentLanguage === 'cn');\n    console.log('English pressed');\n  },\n});\n\nconst check_sub_item_zh = await CheckMenuItem.new({\n  id: 'zh',\n  text: 'Chinese',\n  checked: currentLanguage === 'zh',\n  action: () => {\n    currentLanguage = 'zh';\n    check_sub_item_en.setChecked(currentLanguage === 'en');\n    check_sub_item_zh.setChecked(currentLanguage === 'zh');\n    check_sub_item_zh.setAccelerator('Ctrl+L');\n    console.log('Chinese pressed');\n  },\n});\n\n// Load icon from path\nconst icon = await Image.fromPath('../src/icon.png');\nconst icon2 = await Image.fromPath('../src/icon-2.png');\n\nconst icon_item = await IconMenuItem.new({\n  id: 'icon_item',\n  text: 'Icon Item',\n  icon: icon,\n  action: () => {\n    icon_item.setIcon(icon2);\n    console.log('icon pressed');\n  },\n});\n\nconst text_item = await MenuItem.new({\n  id: 'text_item',\n  text: 'Text Item',\n  action: () => {\n    text_item.setText('Text Item Changed');\n    console.log('text pressed');\n  },\n});\n\nconst menu = await Menu.new({\n  items: [\n    {\n      id: 'change menu',\n      text: 'change_menu',\n      items: [text_item, check_sub_item_en, check_sub_item_zh, icon_item],\n    },\n  ],\n});\n\nawait menu.setAsAppMenu();",
      "context": "frontend_integration",
      "file_path": null,
      "description": "item(&PredefinedMenuItem::copy(app, None)?)`",
      "dependencies": null
    },
    {
      "language": "rust",
      "code": "// change-menu-status\n#![cfg_attr(not(debug_assertions), windows_subsystem = \"windows\")]\n\nuse tauri::{\n    image::Image,\n    menu::{CheckMenuItemBuilder, IconMenuItem, MenuBuilder, MenuItem, SubmenuBuilder},\n};\n\nfn main() {\n    tauri::Builder::default()\n        .setup(|app| {\n            let check_sub_item_en = CheckMenuItemBuilder::with_id(\"en\", \"EN\")\n                .checked(true)\n                .build(app)?;\n\n            let check_sub_item_zh = CheckMenuItemBuilder::with_id(\"zh\", \"ZH\")\n                .checked(false)\n                .build(app)?;\n\n            let text_menu = MenuItem::with_id(\n                app,\n                \"change_text\",\n                &\"Change menu\".to_string(),\n                true,\n                Some(\"Ctrl+Z\"),\n            )\n            .unwrap();\n\n            let icon_menu = IconMenuItem::with_id(\n                app,\n                \"change_icon\",\n                &\"Change icon menu\",\n                true,\n                Some(Image::from_bytes(include_bytes!(\"../icons/icon.png\")).unwrap()),\n                Some(\"Ctrl+F\"),\n            )\n            .unwrap();\n\n            let menu_item = SubmenuBuilder::new(app, \"Change menu\")\n                .item(&text_menu)\n                .item(&icon_menu)\n                .items(&[&check_sub_item_en, &check_sub_item_zh])\n                .build()?;\n            let menu = MenuBuilder::new(app).items(&[&menu_item]).build()?;\n            app.set_menu(menu)?;\n            app.on_menu_event(move |_app_handle: &tauri::AppHandle, event| {\n                match event.id().0.as_str() {\n                    \"change_text\" => {\n                        text_menu\n                            .set_text(\"changed menu text\")\n                            .expect(\"Change text error\");\n\n                        text_menu\n                            .set_text(\"changed menu text\")\n                            .expect(\"Change text error\");\n                    }\n                    \"change_icon\" => {\n                        icon_menu\n                            .set_text(\"changed menu-icon text\")\n                            .expect(\"Change text error\");\n                        icon_menu\n                            .set_icon(Some(\n                                Image::from_bytes(include_bytes!(\"../icons/icon-2.png\")).unwrap(),\n                            ))\n                            .expect(\"Change icon error\");\n                    }\n\n                    \"en\" | \"zh\" => {\n                        check_sub_item_en\n                            .set_checked(event.id().0.as_str() == \"en\")\n                            .expect(\"Change check error\");\n                        check_sub_item_zh\n                            .set_checked(event.id().0.as_str() == \"zh\")\n                            .expect(\"Change check error\");\n                        check_sub_item_zh.set_accelerator(Some(\"Ctrl+L\"))\n                        .expect(\"Change accelerator error\");\n                    }\n                    _ => {\n                        println!(\"unexpected menu event\");\n                    }\n                }\n            });\n\n            Ok(())\n        })\n        .run(tauri::generate_context!())\n        .expect(\"error while running tauri application\");\n}",
      "context": "rust_backend",
      "file_path": null,
      "description": "new({\n  items: [\n    {\n      id: 'change menu',\n      text: 'change_menu',\n      items: [text_item, check_sub_item_en, check_sub_item_zh, icon_item],\n    },\n  ],\n});\n\nawait menu",
      "dependencies": null
    },
    {
      "language": "sh",
      "code": "mkdir -p tauri-learning\n    cd tauri-learning\n    cargo tauri plugin new test\n    cd tauri-plugin-test\n    pnpm install\n    pnpm build\n    cargo build",
      "context": "command",
      "file_path": null,
      "description": "Once you have a recent version installed you can go\n    ahead and create the plugin using the Tauri CLI",
      "dependencies": null
    },
    {
      "language": "rust",
      "code": "pub fn init<R: Runtime>() -> TauriPlugin<R> {\n    Builder::new(\"test\")\n        .invoke_handler(tauri::generate_handler![\n            commands::ping,\n            commands::write_custom_file,\n        ])\n        .setup(|app, api| {\n            #[cfg(mobile)]\n            let test = mobile::init(app, api)?;\n            #[cfg(desktop)]\n            let test = desktop::init(app, api)?;\n            app.manage(test);\n\n            // manage state so it is accessible by the commands\n            app.manage(MyState::default());\n            Ok(())\n        })\n        .build()\n    }",
      "context": "command",
      "file_path": "src/lib.rs",
      "description": "Next we want to expose it to the frontend so it can be consumed",
      "dependencies": null
    },
    {
      "language": "ts",
      "code": "import { invoke } from '@tauri-apps/api/core'\n\n    export async function ping(value: string): Promise<string | null> {\n      return await invoke<{value?: string}>('plugin:test|ping', {\n        payload: {\n          value,\n        },\n      }).then((r) => (r.value ? r.value : null));\n    }\n\n    export async function writeCustomFile(user_input: string): Promise<string> {\n     return await invoke('plugin:test|write_custom_file',{userInput: user_input});\n    }",
      "context": "command",
      "file_path": "guest-js/index.ts",
      "description": "This is for convenience and has\n    no security impact, as the command handler is already generated\n    and the command can be manually invoked from the frontend",
      "dependencies": null
    }
  ],
  "index": {
    "communication": [
      "Calling the Frontend from Rust",
      "Calling Rust from the Frontend",
      "Configuration Files",
      "Develop",
      "Environment Variables",
      "App Icons",
      "App Icons",
      "Updating Dependencies"
    ],
    "ui_customization": [
      "Capabilities for Different Windows and Platforms",
      "System Tray",
      "Window Customization",
      "Window Menu"
    ],
    "security": [
      "Core Permissions",
      "Using Plugin Permissions",
      "Writing Plugin Permissions"
    ],
    "general": [
      "Create a Project",
      "Calling the Frontend from Rust",
      "Prerequisites",
      "Project Structure",
      "Splashscreen",
      "Vite"
    ],
    "debugging": [
      "Debug in VS Code"
    ],
    "migration": [
      "Upgrade from Tauri 1.0",
      "Upgrade from Tauri 2.0 Beta"
    ],
    "resources": [
      "Embedding Additional Files",
      "Node.js as a sidecar",
      "Embedding External Binaries"
    ],
    "state_management": [
      "State Management"
    ],
    "tag:rust": [
      "Calling the Frontend from Rust",
      "Calling Rust from the Frontend",
      "Capabilities for Different Windows and Platforms",
      "Configuration Files",
      "Create a Project",
      "Debug in VS Code",
      "Develop",
      "Calling the Frontend from Rust",
      "Upgrade from Tauri 1.0",
      "Prerequisites",
      "Project Structure",
      "Embedding Additional Files",
      "Node.js as a sidecar",
      "Embedding External Binaries",
      "Splashscreen",
      "State Management",
      "System Tray",
      "Updating Dependencies",
      "Using Plugin Permissions",
      "Vite",
      "Window Customization",
      "Window Menu",
      "Writing Plugin Permissions"
    ],
    "tag:javascript": [
      "Calling the Frontend from Rust",
      "Calling Rust from the Frontend",
      "Capabilities for Different Windows and Platforms",
      "Create a Project",
      "Develop",
      "Upgrade from Tauri 1.0",
      "Prerequisites",
      "Project Structure",
      "Embedding Additional Files",
      "Node.js as a sidecar",
      "Embedding External Binaries",
      "Splashscreen",
      "System Tray",
      "Updating Dependencies",
      "Using Plugin Permissions",
      "Window Customization",
      "Window Menu"
    ],
    "tag:calling": [
      "Calling the Frontend from Rust",
      "Calling Rust from the Frontend"
    ],
    "tag:frontend": [
      "Calling the Frontend from Rust",
      "Calling the Frontend from Rust"
    ],
    "tag:typescript": [
      "Calling Rust from the Frontend",
      "Create a Project",
      "Node.js as a sidecar",
      "Splashscreen",
      "Using Plugin Permissions"
    ],
    "tag:mobile": [
      "Calling Rust from the Frontend",
      "Develop",
      "Calling the Frontend from Rust",
      "App Icons",
      "App Icons",
      "Upgrade from Tauri 1.0",
      "Upgrade from Tauri 2.0 Beta",
      "Prerequisites",
      "Project Structure",
      "Node.js as a sidecar",
      "Splashscreen",
      "Using Plugin Permissions",
      "Writing Plugin Permissions"
    ],
    "tag:ios": [
      "Calling Rust from the Frontend",
      "Capabilities for Different Windows and Platforms",
      "Configuration Files",
      "Develop",
      "Environment Variables",
      "App Icons",
      "App Icons",
      "Upgrade from Tauri 1.0",
      "Upgrade from Tauri 2.0 Beta",
      "Prerequisites",
      "Vite"
    ],
    "tag:windows": [
      "Capabilities for Different Windows and Platforms",
      "Configuration Files",
      "Core Permissions",
      "Create a Project",
      "Debug in VS Code",
      "Develop",
      "Environment Variables",
      "App Icons",
      "App Icons",
      "Upgrade from Tauri 1.0",
      "Prerequisites",
      "Embedding Additional Files",
      "Node.js as a sidecar",
      "Embedding External Binaries",
      "Splashscreen",
      "Using Plugin Permissions",
      "Vite",
      "Window Customization",
      "Window Menu"
    ],
    "tag:capabilities": [
      "Capabilities for Different Windows and Platforms"
    ],
    "tag:platforms": [
      "Capabilities for Different Windows and Platforms"
    ],
    "tag:linux": [
      "Capabilities for Different Windows and Platforms",
      "Configuration Files",
      "Create a Project",
      "Develop",
      "Environment Variables",
      "App Icons",
      "App Icons",
      "Upgrade from Tauri 1.0",
      "Prerequisites",
      "Node.js as a sidecar",
      "Embedding External Binaries",
      "Vite",
      "Window Menu"
    ],
    "tag:android": [
      "Capabilities for Different Windows and Platforms",
      "Configuration Files",
      "Develop",
      "Environment Variables",
      "App Icons",
      "App Icons",
      "Upgrade from Tauri 1.0",
      "Upgrade from Tauri 2.0 Beta",
      "Prerequisites"
    ],
    "tag:macos": [
      "Capabilities for Different Windows and Platforms",
      "Configuration Files",
      "Create a Project",
      "Develop",
      "Environment Variables",
      "App Icons",
      "App Icons",
      "Upgrade from Tauri 1.0",
      "Upgrade from Tauri 2.0 Beta",
      "Prerequisites",
      "Node.js as a sidecar",
      "Vite",
      "Window Customization",
      "Window Menu"
    ],
    "tag:configuration": [
      "Configuration Files"
    ],
    "tag:files": [
      "Configuration Files"
    ],
    "tag:core": [
      "Core Permissions"
    ],
    "tag:permissions": [
      "Core Permissions",
      "Using Plugin Permissions",
      "Writing Plugin Permissions"
    ],
    "tag:vue": [
      "Create a Project"
    ],
    "tag:create": [
      "Create a Project"
    ],
    "tag:react": [
      "Create a Project",
      "Develop"
    ],
    "tag:svelte": [
      "Create a Project",
      "Upgrade from Tauri 2.0 Beta",
      "Writing Plugin Permissions"
    ],
    "tag:project": [
      "Create a Project",
      "Project Structure"
    ],
    "tag:debug": [
      "Debug in VS Code"
    ],
    "tag:vscode": [
      "Debug in VS Code"
    ],
    "tag:desktop": [
      "Develop",
      "App Icons",
      "App Icons",
      "Upgrade from Tauri 1.0",
      "Prerequisites",
      "Project Structure",
      "Embedding Additional Files",
      "Node.js as a sidecar",
      "Embedding External Binaries",
      "Using Plugin Permissions",
      "Window Customization",
      "Window Menu",
      "Writing Plugin Permissions"
    ],
    "tag:develop": [
      "Develop"
    ],
    "tag:variables": [
      "Environment Variables"
    ],
    "tag:environment": [
      "Environment Variables"
    ],
    "tag:listen": [
      "Calling the Frontend from Rust"
    ],
    "tag:icons ": [
      "App Icons"
    ],
    "tag: copy": [
      "App Icons"
    ],
    "tag:icons": [
      "App Icons"
    ],
    "tag:migrate": [
      "Upgrade from Tauri 1.0",
      "Upgrade from Tauri 2.0 Beta"
    ],
    "tag:from": [
      "Upgrade from Tauri 1.0",
      "Upgrade from Tauri 2.0 Beta"
    ],
    "tag:tauri": [
      "Upgrade from Tauri 1.0",
      "Upgrade from Tauri 2.0 Beta"
    ],
    "tag:beta": [
      "Upgrade from Tauri 2.0 Beta"
    ],
    "tag:prerequisites": [
      "Prerequisites"
    ],
    "tag:structure": [
      "Project Structure"
    ],
    "tag:resources": [
      "Embedding Additional Files"
    ],
    "tag:nodejs": [
      "Node.js as a sidecar"
    ],
    "tag:sidecar": [
      "Node.js as a sidecar",
      "Embedding External Binaries"
    ],
    "tag:splashscreen": [
      "Splashscreen"
    ],
    "tag:state": [
      "State Management"
    ],
    "tag:management": [
      "State Management"
    ],
    "tag:system": [
      "System Tray"
    ],
    "tag:tray": [
      "System Tray"
    ],
    "tag:dependencies": [
      "Updating Dependencies"
    ],
    "tag:updating": [
      "Updating Dependencies"
    ],
    "tag:plugin": [
      "Using Plugin Permissions",
      "Writing Plugin Permissions"
    ],
    "tag:using": [
      "Using Plugin Permissions"
    ],
    "tag:vite": [
      "Vite"
    ],
    "tag:customization": [
      "Window Customization"
    ],
    "tag:window": [
      "Window Customization",
      "Window Menu"
    ],
    "tag:menu": [
      "Window Menu"
    ],
    "tag:writing": [
      "Writing Plugin Permissions"
    ],
    "difficulty:intermediate": [
      "Calling the Frontend from Rust",
      "Calling Rust from the Frontend",
      "Capabilities for Different Windows and Platforms",
      "Core Permissions",
      "Develop",
      "Environment Variables",
      "App Icons",
      "App Icons",
      "Upgrade from Tauri 2.0 Beta",
      "Prerequisites",
      "Project Structure",
      "Embedding Additional Files",
      "Node.js as a sidecar",
      "Embedding External Binaries",
      "System Tray",
      "Window Customization",
      "Window Menu",
      "Writing Plugin Permissions"
    ],
    "difficulty:beginner": [
      "Configuration Files",
      "Create a Project",
      "Debug in VS Code",
      "Calling the Frontend from Rust",
      "Updating Dependencies",
      "Vite"
    ],
    "difficulty:advanced": [
      "Upgrade from Tauri 1.0",
      "Splashscreen",
      "State Management",
      "Using Plugin Permissions"
    ],
    "commands": [
      "download",
      "login",
      "open_file",
      "download",
      "download",
      "tauri_application",
      "tauri_application",
      "tauri_application",
      "tauri_application",
      "tauri_application",
      "my_custom_command",
      "my_custom_command",
      "my_custom_command",
      "my_custom_command",
      "read_file",
      "login",
      "my_custom_command",
      "my_custom_command",
      "read",
      "my_custom_command",
      "my_custom_command",
      "load_image",
      "my_custom_command",
      "my_custom_command",
      "my_custom_command",
      "my_custom_command",
      "upload",
      "cmd_a",
      "cmd_b",
      "my_custom_command",
      "tauri_application",
      "tauri_build",
      "tauri_dev",
      "tauri_build",
      "tauri_build",
      "tauri_build",
      "tauri_build",
      "tauri_build",
      "tauri_build",
      "tauri_dev",
      "tauri_build",
      "tauri_Cargo_features",
      "tauri_Cargo_features",
      "tauri_dev",
      "tauri_dev",
      "tauri_dev",
      "tauri_dev",
      "tauri_dev",
      "tauri_dev",
      "tauri_init",
      "tauri_init",
      "tauri_init",
      "tauri_init",
      "tauri_init",
      "tauri_init",
      "tauri_dev",
      "tauri_dev",
      "tauri_dev",
      "tauri_dev",
      "tauri_dev",
      "tauri_dev",
      "tauri_dev",
      "tauri_dev",
      "tauri_dev",
      "tauri_dev",
      "tauri_dev",
      "tauri_dev",
      "tauri_dev",
      "tauri_android_dev",
      "tauri_ios_dev",
      "tauri_ios_dev",
      "tauri_ios_dev",
      "tauri_ios_dev",
      "tauri_ios_dev",
      "tauri_ios_dev",
      "tauri_ios_dev",
      "tauri_ios_dev",
      "tauri_ios_dev",
      "tauri_dev",
      "tauri_folder",
      "tauri_core_crates_and_tauri_CLI",
      "tauri_configuration_file",
      "tauri_application",
      "tauri_bundler",
      "tauri_bundler",
      "tauri_android_project",
      "tauri_iOS_project",
      "tauri_application",
      "tauri_application",
      "tauri_icon",
      "tauri_icon",
      "tauri_icon",
      "tauri_icon",
      "tauri_icon",
      "tauri_icon",
      "tauri_icon",
      "tauri_icon",
      "tauri_icon",
      "tauri_repo",
      "tauri_icon",
      "tauri_icon",
      "tauri_icon",
      "tauri_icon",
      "tauri_icon",
      "tauri_icon",
      "tauri_icon",
      "tauri_icon",
      "tauri_icon",
      "tauri_repo",
      "tauri_migrate",
      "tauri_migrate",
      "tauri_migrate",
      "tauri_migrate",
      "tauri_migrate",
      "tauri_migrate",
      "tauri_migrate",
      "tauri_migrate",
      "tauri_ios_dev",
      "tauri_icon",
      "hello",
      "call_my_sidecar",
      "tauri_dev",
      "tauri_dev",
      "tauri_application",
      "increase_counter",
      "increase_counter",
      "tauri_cargo_update",
      "tauri_dev",
      "tauri_add_fs",
      "tauri_application",
      "tauri_dev",
      "tauri_application",
      "tauri_application",
      "tauri_info",
      "tauri_plugin_new_test\n____cd_tauri"
    ],
    "workflows": [
      "workflow_capabilities-for-windows-and-platforms.mdx_d0c8d388",
      "workflow_capabilities-for-windows-and-platforms.mdx_1",
      "workflow_create-project.mdx_633a2444",
      "workflow_create-project.mdx_2a8f70bd",
      "workflow_create-project.mdx_2",
      "workflow_migrate-from-tauri-1.mdx_0",
      "workflow_prerequisites.mdx_0",
      "workflow_sidecar-nodejs.mdx_23ac22ff",
      "workflow_sidecar-nodejs.mdx_1",
      "workflow_splashscreen.mdx_d8e5e725",
      "workflow_splashscreen.mdx_1",
      "workflow_using-plugin-permissions.mdx_5605c687",
      "workflow_using-plugin-permissions.mdx_1",
      "workflow_vite.mdx_0ff966de",
      "workflow_writing-plugin-permissions.mdx_488518b9",
      "workflow_writing-plugin-permissions.mdx_1"
    ]
  },
  "search_hints": {
    "how_to_start": [
      "prerequisites",
      "create-project",
      "develop"
    ],
    "frontend_backend_communication": [
      "calling-rust",
      "calling-frontend",
      "commands",
      "events"
    ],
    "ui_customization": [
      "window-customization",
      "system-tray",
      "window-menu",
      "splashscreen"
    ],
    "security": [
      "capabilities",
      "permissions",
      "core-permissions"
    ],
    "deployment": [
      "build",
      "icons",
      "resources",
      "sidecar"
    ],
    "state_and_data": [
      "state-management",
      "resources"
    ],
    "debugging": [
      "debug-vscode",
      "environment-variables"
    ],
    "migration": [
      "migrate-from-tauri-1",
      "migrate-from-tauri-2-beta",
      "updating-dependencies"
    ],
    "platform_specific": [
      "windows",
      "macos",
      "linux",
      "android",
      "ios"
    ],
    "plugins": [
      "using-plugin-permissions",
      "writing-plugin-permissions"
    ]
  },
  "v2_changes": {
    "breaking_changes": [],
    "new_features": [],
    "migration_steps": [],
    "deprecated_apis": [],
    "new_permissions_model": [
      {
        "name": "Capabilities for Different Windows and Platforms",
        "description": "import { Steps } from '@astrojs/starlight/components'; import ShowSolution from '@components/ShowSolution.astro' import Cta from '@fragments/cta.mdx';"
      },
      {
        "name": "Core Permissions",
        "description": "A list of all permissions that can be used with the core of the Tauri framework."
      },
      {
        "name": "Using Plugin Permissions",
        "description": "import { Steps } from '@astrojs/starlight/components'; import ShowSolution from '@components/ShowSolution.astro' import Cta from '@fragments/cta.mdx';"
      },
      {
        "name": "Writing Plugin Permissions",
        "description": "import { Steps } from '@astrojs/starlight/components'; import ShowSolution from '@components/ShowSolution.astro' import Cta from '@fragments/cta.mdx';"
      }
    ]
  },
  "permissions": {
    "core_permissions": [
      {
        "name": "Core Permissions",
        "description": "A list of all permissions that can be used with the core of the Tauri framework.",
        "category": "security"
      }
    ],
    "plugin_permissions": [
      {
        "name": "Using Plugin Permissions",
        "description": "import { Steps } from '@astrojs/starlight/components'; import ShowSolution from '@components/ShowSolution.astro' import Cta from '@fragments/cta.mdx';"
      },
      {
        "name": "Writing Plugin Permissions",
        "description": "import { Steps } from '@astrojs/starlight/components'; import ShowSolution from '@components/ShowSolution.astro' import Cta from '@fragments/cta.mdx';"
      }
    ],
    "capability_patterns": [
      {
        "language": "json",
        "pattern": "{\n      \"identifier\": \"fs-read-home\",\n      \"description\": \"Allow access file access to home directory\",\n      \"local\": true,\n      \"windows\": [\"first\"],\n      \"permissions\": [\n        \"fs:allow-home-read\",\n      ]\n    }",
        "context": "window_management"
      },
      {
        "language": "json",
        "pattern": "{\n      \"identifier\": \"dialog\",\n      \"description\": \"Allow to open a dialog\",\n      \"local\": true,\n      \"windows\": [\"first\", \"second\"],\n      \"permissions\": [\"dialog:allow-ask\"]\n    }",
        "context": "window_management"
      },
      {
        "language": "json",
        "pattern": "{\n      \"identifier\": \"fs-read-home\",\n      \"description\": \"Allow access file access to home directory\",\n      \"local\": true,\n      \"windows\": [\"first\"],\n      \"permissions\": [\n        \"fs:allow-home-read\",\n      ],\n      \"platforms\": [\"linux\", \"windows\"]\n    }",
        "context": "window_management"
      },
      {
        "language": "rust",
        "pattern": "use tauri_plugin_notification::NotificationExt;\nuse tauri::plugin::PermissionState;\n\nfn main() {\n    tauri::Builder::default()\n        .plugin(tauri_plugin_notification::init())\n        .setup(|app| {\n            if app.notification().permission_state()? == PermissionState::Unknown {\n               ",
        "context": "plugin"
      },
      {
        "language": "json",
        "pattern": "...\n\"permissions\": [\n    \"path:default\",\n    \"event:default\",\n    \"window:default\",\n    \"app:default\",\n    \"image:default\",\n    \"resources:default\",\n    \"menu:default\",\n    \"tray:default\",\n]\n...",
        "context": "permissions"
      },
      {
        "language": "json",
        "pattern": "...\n\"permissions\": [\n    \"core:path:default\",\n    \"core:event:default\",\n    \"core:window:default\",\n    \"core:app:default\",\n    \"core:image:default\",\n    \"core:resources:default\",\n    \"core:menu:default\",\n    \"core:tray:default\",\n]\n...",
        "context": "window_management"
      },
      {
        "language": "json",
        "pattern": "...\n\"permissions\": [\n    \"core:default\"\n]\n...",
        "context": "permissions"
      },
      {
        "language": "json",
        "pattern": "{\n  \"$schema\": \"../gen/schemas/desktop-schema.json\",\n  \"identifier\": \"main-capability\",\n  \"description\": \"Capability for the main window\",\n  \"windows\": [\"main\"],\n  \"permissions\": [\n    \"core:default\",\n    \"fs:allow-read-text-file\",\n    \"fs:allow-resource-read-recursive\"\n  ]\n}",
        "context": "permissions"
      },
      {
        "language": "json",
        "pattern": "{\n  \"permissions\": [\n    \"core:default\",\n    {\n      \"identifier\": \"shell:allow-execute\",\n      \"allow\": [\n        {\n          \"name\": \"binaries/app\",\n          \"sidecar\": true\n        }\n      ]\n    }\n  ]\n}",
        "context": "permissions"
      },
      {
        "language": "json",
        "pattern": "{\n  \"$schema\": \"../gen/schemas/desktop-schema.json\",\n  \"identifier\": \"default\",\n  \"description\": \"Capability for the main window\",\n  \"windows\": [\"main\"],\n  \"permissions\": [\n    \"core:default\",\n    {\n      \"identifier\": \"shell:allow-execute\",\n      \"allow\": [\n        {\n          \"args\": [\n           ",
        "context": "command"
      },
      {
        "language": "javascript",
        "pattern": "import { Command } from '@tauri-apps/plugin-shell';\n// notice that the args array matches EXACTLY what is specified in `capabilities/default.json`.\nconst command = Command.sidecar('binaries/my-sidecar', [\n  'arg1',\n  '-a',\n  '--arg2',\n  'any-string-that-matches-the-validator',\n]);\nconst output = awa",
        "context": "command"
      },
      {
        "language": "sh",
        "pattern": "[Error] Unhandled Promise Rejection: fs.write_text_file not allowed. Permissions associated with this command: fs:allow-app-write, fs:allow-app-write-recursive, fs:allow-appcache-write, fs:allow-appcache-write-recursive, fs:allow-appconf...\n        (anonymous function) (main.ts:5)",
        "context": "permissions"
      },
      {
        "language": "json",
        "pattern": "{\n  \"$schema\": \"../gen/schemas/desktop-schema.json\",\n  \"identifier\": \"main-capability\",\n  \"description\": \"Capability for the main window\",\n  \"windows\": [\"main\"],\n  \"permissions\": [\"core:window:default\", \"core:window:allow-start-dragging\"]\n}",
        "context": "permissions"
      }
    ],
    "permission_scopes": [],
    "security_best_practices": []
  },
  "worker_patterns": {
    "sidecar_patterns": [
      {
        "language": "javascript",
        "code": "import { Command } from '@tauri-apps/plugin-shell';\n\n        const message = 'Tauri';\n\n        const command = Command.sidecar('binaries/app', ['ping', message]);\n        const output = await command.execute();\n        const response = output.stdout;",
        "context": "command",
        "description": "<Tabs syncKey=\"lang\">\n\n      <TabItem label=\"JavaScript\">\n\n        Let's execute the `ping` command in the Node"
      },
      {
        "language": "rust",
        "code": "#[tauri::command]\n        async fn ping(app: tauri::AppHandle, message: String) -> String {\n          let sidecar_command = app\n            .shell()\n            .sidecar(\"app\")\n            .unwrap()\n            .arg(\"ping\")\n            .arg(message);\n          let output = sidecar_command.output().unwrap();\n          let response = String::from_utf8(output.stdout).unwrap();\n          response\n    ",
        "context": "command",
        "description": "stdout;\n        ```\n\n      </TabItem>\n\n      <TabItem label=\"Rust\">\n\n        Let's pipe a `ping` Tauri command to the Node"
      },
      {
        "language": "json",
        "code": "{\n  \"bundle\": {\n    \"externalBin\": [\n      \"/absolute/path/to/sidecar\",\n      \"../relative/path/to/binary\",\n      \"binaries/my-sidecar\"\n    ]\n  }\n}",
        "context": "general",
        "description": "The `externalBin` configuration expects a list of strings targeting binaries either with absolute or relative paths"
      },
      {
        "language": "javascript",
        "code": "import { execSync } from 'child_process';\nimport fs from 'fs';\n\nconst extension = process.platform === 'win32' ? '.exe' : '';\n\nconst rustInfo = execSync('rustc -vV');\nconst targetTriple = /host: (\\S+)/g.exec(rustInfo)[1];\nif (!targetTriple) {\n  console.error('Failed to determine platform target triple');\n}\nfs.renameSync(\n  `src-tauri/binaries/sidecar${extension}`,\n  `src-tauri/binaries/sidecar-${t",
        "context": "rust_backend",
        "description": "split(\" \")[1]}\n```\n\nHere's a Node"
      },
      {
        "language": "rust",
        "code": "use tauri_plugin_shell::ShellExt;\nuse tauri_plugin_shell::process::CommandEvent;\n\nlet sidecar_command = app.shell().sidecar(\"my-sidecar\").unwrap();\nlet (mut rx, mut _child) = sidecar_command\n  .spawn()\n  .expect(\"Failed to spawn sidecar\");\n\ntauri::async_runtime::spawn(async move {\n  // read events such as stdout\n  while let Some(event) = rx.recv().await {\n    if let CommandEvent::Stdout(line_bytes",
        "context": "plugin",
        "description": ":::\n\nOn the Rust side, import the `tauri_plugin_shell::ShellExt` trait and call the `shell()"
      },
      {
        "language": "json",
        "code": "{\n  \"bundle\": {\n    \"externalBin\": [\"binaries/app\", \"my-sidecar\", \"../scripts/sidecar\"]\n  }\n}",
        "context": "general",
        "description": "unwrap();\n    }\n  }\n});\n```\n\n:::note\nThe `sidecar()` function expects just the filename, NOT the whole path configured in the `externalBin` array"
      },
      {
        "language": "json",
        "code": "{\n  \"permissions\": [\n    \"core:default\",\n    {\n      \"identifier\": \"shell:allow-execute\",\n      \"allow\": [\n        {\n          \"name\": \"binaries/app\",\n          \"sidecar\": true\n        }\n      ]\n    }\n  ]\n}",
        "context": "permissions",
        "description": "Don't forget to name your sidecar according to the relative path mentioned earlier"
      },
      {
        "language": "javascript",
        "code": "import { Command } from '@tauri-apps/plugin-shell';\nconst command = Command.sidecar('binaries/my-sidecar');\nconst output = await command.execute();",
        "context": "command",
        "description": ":::\n\nIn the JavaScript code, import the `Command` class from the `@tauri-apps/plugin-shell` module and use the `sidecar` static method"
      },
      {
        "language": "json",
        "code": "{\n  \"$schema\": \"../gen/schemas/desktop-schema.json\",\n  \"identifier\": \"default\",\n  \"description\": \"Capability for the main window\",\n  \"windows\": [\"main\"],\n  \"permissions\": [\n    \"core:default\",\n    {\n      \"identifier\": \"shell:allow-execute\",\n      \"allow\": [\n        {\n          \"args\": [\n            \"arg1\",\n            \"-a\",\n            \"--arg2\",\n            {\n              \"validator\": \"\\\\S+\"\n   ",
        "context": "command",
        "description": "First, define the arguments that need to be passed to the sidecar command in `src-tauri/capabilities/default"
      },
      {
        "language": "rust",
        "code": "use tauri_plugin_shell::ShellExt;\n#[tauri::command]\nasync fn call_my_sidecar(app: tauri::AppHandle) {\n  let sidecar_command = app\n    .shell()\n    .sidecar(\"my-sidecar\")\n    .unwrap()\n    .args([\"arg1\", \"-a\", \"--arg2\", \"any-string-that-matches-the-validator\"]);\n  let (mut _rx, mut _child) = sidecar_command.spawn().unwrap();\n}",
        "context": "command",
        "description": ":::\n\nThen, to call the sidecar command, simply pass in **all** the arguments as an array"
      },
      {
        "language": "javascript",
        "code": "import { Command } from '@tauri-apps/plugin-shell';\n// notice that the args array matches EXACTLY what is specified in `capabilities/default.json`.\nconst command = Command.sidecar('binaries/my-sidecar', [\n  'arg1',\n  '-a',\n  '--arg2',\n  'any-string-that-matches-the-validator',\n]);\nconst output = await command.execute();",
        "context": "command",
        "description": "spawn()"
      }
    ],
    "worker_execution": [],
    "command_patterns": [
      {
        "language": "javascript",
        "pattern": "import { Command, open } from '@tauri-apps/plugin-shell';\nconst output = await Command.create('echo', 'message').execute();\n\nawait open('https://github.com/tauri-apps/tauri');",
        "context": "plugin"
      },
      {
        "language": "rust",
        "pattern": "use tauri_plugin_shell::{ShellExt, process::CommandEvent};\n\nfn main() {\n    tauri::Builder::default()\n        .plugin(tauri_plugin_shell::init())\n        .setup(|app| {\n            let handle = app.handle().clone();\n            tauri::async_runtime::spawn(async move {\n                let (mut rx, mu",
        "context": "general"
      },
      {
        "language": "javascript",
        "pattern": "import { Command } from '@tauri-apps/plugin-shell';\n\n        const message = 'Tauri';\n\n        const command = Command.sidecar('binaries/app', ['ping', message]);\n        const output = await command.execute();\n        const response = output.stdout;",
        "context": "command"
      },
      {
        "language": "rust",
        "pattern": "use tauri_plugin_shell::ShellExt;\nuse tauri_plugin_shell::process::CommandEvent;\n\nlet sidecar_command = app.shell().sidecar(\"my-sidecar\").unwrap();\nlet (mut rx, mut _child) = sidecar_command\n  .spawn()\n  .expect(\"Failed to spawn sidecar\");\n\ntauri::async_runtime::spawn(async move {\n  // read events s",
        "context": "plugin"
      },
      {
        "language": "javascript",
        "pattern": "import { Command } from '@tauri-apps/plugin-shell';\nconst command = Command.sidecar('binaries/my-sidecar');\nconst output = await command.execute();",
        "context": "command"
      },
      {
        "language": "rust",
        "pattern": "use tauri_plugin_shell::ShellExt;\n#[tauri::command]\nasync fn call_my_sidecar(app: tauri::AppHandle) {\n  let sidecar_command = app\n    .shell()\n    .sidecar(\"my-sidecar\")\n    .unwrap()\n    .args([\"arg1\", \"-a\", \"--arg2\", \"any-string-that-matches-the-validator\"]);\n  let (mut _rx, mut _child) = sidecar_",
        "context": "command"
      },
      {
        "language": "javascript",
        "pattern": "import { Command } from '@tauri-apps/plugin-shell';\n// notice that the args array matches EXACTLY what is specified in `capabilities/default.json`.\nconst command = Command.sidecar('binaries/my-sidecar', [\n  'arg1',\n  '-a',\n  '--arg2',\n  'any-string-that-matches-the-validator',\n]);\nconst output = awa",
        "context": "command"
      },
      {
        "language": "rust",
        "pattern": "// /src-tauri/src/lib.rs\n    // Import functionalities we'll be using\n    use std::sync::Mutex;\n    use tauri::async_runtime::spawn;\n    use tauri::{AppHandle, Manager, State};\n    use tokio::time::{sleep, Duration};\n\n    // Create a struct we'll use to track the completion of\n    // setup related t",
        "context": "window_management"
      }
    ],
    "binary_configuration": [
      {
        "language": "js",
        "config": "import { execSync } from 'child_process';\n    import fs from 'fs';\n\n    const ext = process.platform === 'win32' ? '.exe' : '';\n\n    const rustInfo = execSync('rustc -vV');\n    const targetTriple = /host: (\\S+)/g.exec(rustInfo)[1];\n    if (!targetTri",
        "context": "window_management"
      },
      {
        "language": "json",
        "config": "{\n      \"bundle\": {\n        \"externalBin\": [\"binaries/app\"]\n      }\n    }",
        "context": "general"
      },
      {
        "language": "javascript",
        "config": "import { Command } from '@tauri-apps/plugin-shell';\n\n        const message = 'Tauri';\n\n        const command = Command.sidecar('binaries/app', ['ping', message]);\n        const output = await command.execute();\n        const response = output.stdout;",
        "context": "command"
      },
      {
        "language": "json",
        "config": "{\n  \"bundle\": {\n    \"externalBin\": [\n      \"/absolute/path/to/sidecar\",\n      \"../relative/path/to/binary\",\n      \"binaries/my-sidecar\"\n    ]\n  }\n}",
        "context": "general"
      },
      {
        "language": "javascript",
        "config": "import { execSync } from 'child_process';\nimport fs from 'fs';\n\nconst extension = process.platform === 'win32' ? '.exe' : '';\n\nconst rustInfo = execSync('rustc -vV');\nconst targetTriple = /host: (\\S+)/g.exec(rustInfo)[1];\nif (!targetTriple) {\n  conso",
        "context": "rust_backend"
      },
      {
        "language": "json",
        "config": "{\n  \"bundle\": {\n    \"externalBin\": [\"binaries/app\", \"my-sidecar\", \"../scripts/sidecar\"]\n  }\n}",
        "context": "general"
      },
      {
        "language": "json",
        "config": "{\n  \"permissions\": [\n    \"core:default\",\n    {\n      \"identifier\": \"shell:allow-execute\",\n      \"allow\": [\n        {\n          \"name\": \"binaries/app\",\n          \"sidecar\": true\n        }\n      ]\n    }\n  ]\n}",
        "context": "permissions"
      },
      {
        "language": "javascript",
        "config": "import { Command } from '@tauri-apps/plugin-shell';\nconst command = Command.sidecar('binaries/my-sidecar');\nconst output = await command.execute();",
        "context": "command"
      },
      {
        "language": "json",
        "config": "{\n  \"$schema\": \"../gen/schemas/desktop-schema.json\",\n  \"identifier\": \"default\",\n  \"description\": \"Capability for the main window\",\n  \"windows\": [\"main\"],\n  \"permissions\": [\n    \"core:default\",\n    {\n      \"identifier\": \"shell:allow-execute\",\n      \"a",
        "context": "command"
      },
      {
        "language": "javascript",
        "config": "import { Command } from '@tauri-apps/plugin-shell';\n// notice that the args array matches EXACTLY what is specified in `capabilities/default.json`.\nconst command = Command.sidecar('binaries/my-sidecar', [\n  'arg1',\n  '-a',\n  '--arg2',\n  'any-string-t",
        "context": "command"
      }
    ]
  },
  "plugins": {
    "available_plugins": [
      {
        "name": "Using Plugin Permissions",
        "description": "import { Steps } from '@astrojs/starlight/components'; import ShowSolution from '@components/ShowSolution.astro' import Cta from '@fragments/cta.mdx';",
        "category": "security"
      }
    ],
    "plugin_usage_patterns": [
      {
        "plugin": "cli",
        "language": "json",
        "usage": "// package.json\n{\n  \"dependencies\": {\n    \"@tauri-apps/plugin-cli\": \"^2.0.0\"\n  }\n}",
        "context": "plugin"
      },
      {
        "plugin": "cli",
        "language": "javascript",
        "usage": "import { getMatches } from '@tauri-apps/plugin-cli';\nconst matches = await getMatches();",
        "context": "plugin"
      },
      {
        "plugin": "clipboard-manager",
        "language": "json",
        "usage": "// package.json\n{\n  \"dependencies\": {\n    \"@tauri-apps/plugin-clipboard-manager\": \"^2.0.0\"\n  }\n}",
        "context": "plugin"
      },
      {
        "plugin": "clipboard-manager",
        "language": "javascript",
        "usage": "import { writeText, readText } from '@tauri-apps/plugin-clipboard-manager';\nawait writeText('Tauri is awesome!');\nassert(await readText(), 'Tauri is awesome!');",
        "context": "plugin"
      },
      {
        "plugin": "dialog",
        "language": "json",
        "usage": "// package.json\n{\n  \"dependencies\": {\n    \"@tauri-apps/plugin-dialog\": \"^2.0.0\"\n  }\n}",
        "context": "plugin"
      },
      {
        "plugin": "dialog",
        "language": "javascript",
        "usage": "import { save } from '@tauri-apps/plugin-dialog';\nconst filePath = await save({\n  filters: [\n    {\n      name: 'Image',\n      extensions: ['png', 'jpeg'],\n    },\n  ],\n});",
        "context": "plugin"
      },
      {
        "plugin": "fs",
        "language": "json",
        "usage": "// package.json\n{\n  \"dependencies\": {\n    \"@tauri-apps/plugin-fs\": \"^2.0.0\"\n  }\n}",
        "context": "plugin"
      },
      {
        "plugin": "fs",
        "language": "javascript",
        "usage": "import { mkdir, BaseDirectory } from '@tauri-apps/plugin-fs';\nawait mkdir('db', { baseDir: BaseDirectory.AppLocalData });",
        "context": "plugin"
      },
      {
        "plugin": "global-shortcut",
        "language": "json",
        "usage": "// package.json\n{\n  \"dependencies\": {\n    \"@tauri-apps/plugin-global-shortcut\": \"^2.0.0\"\n  }\n}",
        "context": "plugin"
      },
      {
        "plugin": "global-shortcut",
        "language": "javascript",
        "usage": "import { register } from '@tauri-apps/plugin-global-shortcut';\nawait register('CommandOrControl+Shift+C', () => {\n  console.log('Shortcut triggered');\n});",
        "context": "plugin"
      },
      {
        "plugin": "http",
        "language": "json",
        "usage": "// package.json\n{\n  \"dependencies\": {\n    \"@tauri-apps/plugin-http\": \"^2.0.0\"\n  }\n}",
        "context": "plugin"
      },
      {
        "plugin": "http",
        "language": "javascript",
        "usage": "import { fetch } from '@tauri-apps/plugin-http';\nconst response = await fetch(\n  'https://raw.githubusercontent.com/tauri-apps/tauri/dev/package.json'\n);",
        "context": "plugin"
      },
      {
        "plugin": "notification",
        "language": "json",
        "usage": "// package.json\n{\n  \"dependencies\": {\n    \"@tauri-apps/plugin-notification\": \"^2.0.0\"\n  }\n}",
        "context": "plugin"
      },
      {
        "plugin": "notification",
        "language": "javascript",
        "usage": "import { sendNotification } from '@tauri-apps/plugin-notification';\nsendNotification('Tauri is awesome!');",
        "context": "plugin"
      },
      {
        "plugin": "os",
        "language": "json",
        "usage": "// package.json\n{\n  \"dependencies\": {\n    \"@tauri-apps/plugin-os\": \"^2.0.0\"\n  }\n}",
        "context": "plugin"
      },
      {
        "plugin": "os",
        "language": "javascript",
        "usage": "import { arch } from '@tauri-apps/plugin-os';\nconst architecture = await arch();",
        "context": "plugin"
      },
      {
        "plugin": "process",
        "language": "json",
        "usage": "// package.json\n{\n  \"dependencies\": {\n    \"@tauri-apps/plugin-process\": \"^2.0.0\"\n  }\n}",
        "context": "plugin"
      },
      {
        "plugin": "process",
        "language": "javascript",
        "usage": "import { exit, relaunch } from '@tauri-apps/plugin-process';\nawait exit(0);\nawait relaunch();",
        "context": "plugin"
      },
      {
        "plugin": "shell",
        "language": "json",
        "usage": "// package.json\n{\n  \"dependencies\": {\n    \"@tauri-apps/plugin-shell\": \"^2.0.0\"\n  }\n}",
        "context": "plugin"
      },
      {
        "plugin": "shell",
        "language": "javascript",
        "usage": "import { Command, open } from '@tauri-apps/plugin-shell';\nconst output = await Command.create('echo', 'message').execute();\n\nawait open('https://github.com/tauri-apps/tauri');",
        "context": "plugin"
      },
      {
        "plugin": "updater",
        "language": "json",
        "usage": "// package.json\n{\n  \"dependencies\": {\n    \"@tauri-apps/plugin-updater\": \"^2.0.0\"\n  }\n}",
        "context": "plugin"
      },
      {
        "plugin": "updater",
        "language": "javascript",
        "usage": "import { check } from '@tauri-apps/plugin-updater';\nimport { relaunch } from '@tauri-apps/plugin-process';\n\nconst update = await check();\nif (update?.available) {\n  console.log(`Update to ${update.version} available! Date: ${update.date}`);\n  console.log(`Release notes: ${update.body}`);\n  await upd",
        "context": "plugin"
      },
      {
        "plugin": "fs",
        "language": "javascript",
        "usage": "import { resolveResource } from '@tauri-apps/api/path';\nimport { readTextFile } from '@tauri-apps/plugin-fs';\n\nconst resourcePath = await resolveResource('lang/de.json');\nconst langDe = JSON.parse(await readTextFile(resourcePath));\nconsole.log(langDe.hello); // This will print 'Guten Tag!' to the de",
        "context": "permissions"
      },
      {
        "plugin": "shell",
        "language": "javascript",
        "usage": "import { Command } from '@tauri-apps/plugin-shell';\n\n        const message = 'Tauri';\n\n        const command = Command.sidecar('binaries/app', ['ping', message]);\n        const output = await command.execute();\n        const response = output.stdout;",
        "context": "command"
      },
      {
        "plugin": "shell",
        "language": "javascript",
        "usage": "import { Command } from '@tauri-apps/plugin-shell';\nconst command = Command.sidecar('binaries/my-sidecar');\nconst output = await command.execute();",
        "context": "command"
      },
      {
        "plugin": "shell",
        "language": "javascript",
        "usage": "import { Command } from '@tauri-apps/plugin-shell';\n// notice that the args array matches EXACTLY what is specified in `capabilities/default.json`.\nconst command = Command.sidecar('binaries/my-sidecar', [\n  'arg1',\n  '-a',\n  '--arg2',\n  'any-string-that-matches-the-validator',\n]);\nconst output = awa",
        "context": "command"
      },
      {
        "plugin": "fs",
        "language": "ts",
        "usage": "import { writeTextFile, BaseDirectory } from '@tauri-apps/plugin-fs';\n\n        let greetInputEl: HTMLInputElement | null;\n\n        async function write(message: string) {\n            await writeTextFile('test.txt', message, { baseDir: BaseDirectory.Home });\n        }\n\n        window.addEventListener",
        "context": "general"
      }
    ],
    "plugin_permissions": [
      {
        "language": "rust",
        "permission_code": "use tauri_plugin_notification::NotificationExt;\nuse tauri::plugin::PermissionState;\n\nfn main() {\n    tauri::Builder::default()\n        .plugin(tauri_plugin_notification::init())\n        .setup(|app| {\n            if app.notification().permission_stat",
        "context": "plugin"
      }
    ],
    "migration_to_plugins": [],
    "custom_plugin_dev": [
      {
        "name": "Writing Plugin Permissions",
        "description": "import { Steps } from '@astrojs/starlight/components'; import ShowSolution from '@components/ShowSolution.astro' import Cta from '@fragments/cta.mdx';"
      }
    ]
  }
}